{"meta":{"title":"eric_zht","subtitle":"","description":"","author":"eric_zht","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2025-02-12T00:50:03.386Z","updated":"2025-02-12T00:50:03.386Z","comments":true,"path":"CSS/custom.css","permalink":"http://example.com/CSS/custom.css","excerpt":"","text":"/* 修改标题样式 */ #page-header #site-title, #page-header #site-subtitle{ text-align: left !important; padding-left: 36px; } @media screen and (max-width: 768px) { #page-header #site-title, #page-header #site-subtitle { padding-left: 16px; } } /* 修改头像显示样式 */ .avatar-img img:hover { -webkit-transform: none; -moz-transform: none; -o-transform: none; -ms-transform: none; transform: none; }"}],"posts":[{"title":"javase 数组","slug":"javase 数组","date":"2025-04-24T16:00:00.000Z","updated":"2025-05-25T10:50:11.600Z","comments":true,"path":"2025/04/25/javase 数组/","permalink":"http://example.com/2025/04/25/javase%20%E6%95%B0%E7%BB%84/","excerpt":"","text":"四、数组数组概述 数组是引用数据类型，隐式继承Object，因此可以调用Object类中的方法 数组对象存储在堆内存中 数组的特点 数组长度一旦确定不可改变 所有数组对象都有length属性，用来获取数组元素个数 优点： 根据下标查找某个元素的效率极高 缺点： 随机增删的效率低，需要后移&#x2F;前移很多元素 无法存储大量数据，因为很难在内存上找到非常大的一块连续内存 一维数组静态初始化一维数组已经知道数组中的值时使用 1234// 第一种int[] arr = &#123;11,22,33&#125;; 或者 int arr[] = &#123;11,22,33&#125;; //后者不建议// 第二种int[] arr = new int[] &#123;11,22,33&#125;; 用第一种就好了！ JDK5 新特性：增强for循环 &#x2F; for-each 循环123for(元素数据类型 变量名:数组名)&#123; // 变量名代表数组中的每个元素，可以自己取名 &#125; 优点：代码简洁 缺点：没有下标 动态初始化不知道数组中具体存储哪些元素时使用 1数据类型[] 变量名 = new 数据类型[长度] 数组长度确定，数组中存储的每个元素将采用默认值。 数组中如何存储不同类的对象创建父类类型的数组，即可存子类的对象 eg. 123Apple a = new Apple();Bird b = new Bird();Object[] objs = &#123;a,b&#125;; 存的是对象的地址 关于main方法的形参args 作用：接收命令行参数用的 JVM负责调用main方法时用的 ——JVM负责给main方法准备一个String[ ]一维数组对象 java fileName abc def xyz命令行参数：abc def xyz，JVM会将命令行参数以空格进行拆分，生成一个新的数组对象。 String[ ] args &#x3D; {“abc”,”def”,”xyz”}; ​ 命令行参数有什么用？ ​ 需求：使用该系统的时候，需要提供正确的口令（用户名和密码），非法用户直接退出系统。 ​ 当两个字符串进行equals比较时，如果其中有一个字符串是字面量，建议将字面量写到前面。即：&quot;string&quot;.equals(variable)，避免出现空指针异常。 可变长度的参数function1(int ... nums) 语法格式：数据类型... 在形参列表中，可变长度的参数只能有一个，且只能在参数列表的末尾 可变长度的参数可以当做数组来看待 可通过这种方式访问：nums[0],nums[1] 一维数组的扩容 数组长度一旦确定不可改变 只能新建一个更大的数组，然后将原数组的数据全部拷贝到新数组中，可以使用System.arraycopy() 数组扩容会影响程序的执行效率，因此尽可能预测数据量，减小扩容次数。 二维数组静态初始化123int[][] arr = new int [][]&#123;&#123;1,2,3&#125;,&#123;1,2,3,4,5&#125;,&#123;1&#125;&#125;;int[][] arr = &#123;&#123;1,2,3&#125;,&#123;1,2,3&#125;,&#123;1&#125;&#125;; // 可以等长，也可以不等长 动态初始化1234// 等长int[][] arr = new int [3][4];// 不等长int[][] arr = new int [3][]; Arrays 工具类 自定义类型做比较的话，这个自定义类型必须实现Comparable接口，并实现compareTo方法。使用sort进行排序时也需要实现该方法。 int[] Arrays.copyOf()是系统自动在内部新建一个数组，将原来的数组复制到新建的数组中，并返回新建的数组。而System.arraycopy()没有新建数组，是直接将内容复制到另一个数组中的。而且arraycopy是native方法，由c++代码实现，因此arraycopy的拷贝速度更快。 五、异常什么是异常？java程序执行过程中的意外、错误、不正确的情况 异常在java中的形式以类和对象的形式存在。 定义异常其实本质上就是定义一个类。 异常如果发生的话，在底层其实通过了这个类new了一个对象。 自定义异常 自定义异常的类需要继承Exception或者RuntimeException，如果继承的是Exception就认为这个异常是编译时异常。 提供两个构造方法，一个是无参数的，一个是带有String参数的，并且在构造方法中调用super(String)； 处理异常的两种方法 抛出异常：在类的声明中添加 throws 异常类名 如果有些方法不允许使用thorws，也可以使用try catch然后在catch里面使用throw 捕捉异常 12345678try&#123; // 尝试执行的代码&#125;catch(异常类型1 变量名)&#123; &#125;catch(异常类型2 变量名)&#123; &#125;...... 注：异常类型1,2,3，… 一定是从小到大的，否则如果第一个就是父类，那永远都不可能运行后面的异常处理代码了。 throw和throws的区别： throw是运行时的语句，真正地抛出一个异常实例 throws是编译时的声明，告诉编译器和调用者，如果出现这些问题就抛出。 JAVA7 新特性 —— 异常统一处理方式1. 123456try&#123; // 尝试执行的代码&#125;catch(异常类型1 | 异常类型2 变量名)&#123; &#125;...... 异常对象的方法 getMessage printStackTrace 1234567891011try&#123; // 尝试执行的代码&#125;catch(IllegalNameException e)&#123; // 这个方法可以获取当时创建异常对象时给异常构造方法传递的String message参数的值 String message = e.getMessage(); // 打印异常的堆栈信息 e.printStackTrace();&#125;......后面执行的代码 异常的堆栈信息： 异常信息的打印是符合栈这个数据结构的，因此优先看最上面的异常行数，最上面是最后执行的代码 打印异常堆栈信息可能出现在“后面执行的代码”前面，也可能在后面。因为高版本的底层是用多线程并行打印的。 finally 语句块放在该语句块中的代码是一定会执行的（无论前面的程序是否有异常），一般在finally语句块中完成资源的释放。 顺序：try…(catch)…finally 继承问题子类继承父类后，重写了父类的方法，重写之后不能抛出更多的异常，可以更少。 六、常用类字符串 String为什么string 字面量不可变？因为底层代码中string是用byte数组存的，而byte数组是private final修饰的，因此无法修改它的值。（java8及之前是char数组） 字符串拼接 如果拼接的两个字符串中有一个是变量，那么拼接后的新字符串不会放到字符串常量池中。而是在堆中。 ​ 底层在进行拼接时，会创建一个StringBuilder对象，进行字符串拼接。最后自动调用StringBuilder对象中的toString()方法，再将StringBuilder对象转换成String对象。 两个字符串字面量拼接会在编译阶段做优化，在编译阶段进行拼接（可以这么理解，但不准确）因此字符串常量池中只有拼接后的内容。 怎么把字符串手动放进字符串常量池？12String m = &quot;test&quot;;String str = m.intern(); // 将&quot;test&quot;放入字符串常量池，并且将&quot;test&quot;对象的地址返回。如果字符串常量池已经存在&quot;test&quot;，那么就直接返回地址。 只能加东西，不能删东西。 String类常用的构造方法 String常用方法 正则表达式 String 中正则表达式相关的方法 StringBuffer 与 StringBuilder 可变长度字符串 这两个类是专门为频繁进行字符串拼接而准备的 StringBuffer是先出现的，Java5时新增了StringBuilder。StringBuffer是线程安全的，而StringBuilder效率更高。 两者底层都是byte[]数组，并且没有被final修饰，因此可以扩容。 优化策略：创建对象时预估好字符串的长度，给定一个合适的初始化容量，减少底层数组扩容的次数。 StringBuilder默认初始化容量：16 StringBuilder扩容策略：每次扩容为原来的两倍+2 为什么频繁拼接字符串时使用StringBuilder&#x2F;StringBuffer更好？ 使用“+”进行拼接，底层每次都会创建一个StringBuilder对象，然后再调用toString方法，10000次拼接就要创建10000次对象，同时给垃圾回收也造成了很大的压力。 而StringBuilder的append不创建新对象，直接在原来的位置进行拼接，且不调用toString方法，只有用print输出的时候才调用一次，因此节省了大量的时间。 包装类 包装类中的6个数字类型都继承了Number类 装箱boxing：将基本数据类型包装成引用数据类型 Integer i = new Integer(100); 拆箱：int num = i.intValue() Integer 常用方法 String、int、Integer 三者相互转换 自动装箱&#x2F;拆箱（JAVA5新特性）编译阶段的功能，底层仍然是之前的装箱&#x2F;拆箱。只是让你编程的时候方便一点。 自动装箱Integer x = 100; 自动拆箱int num = x; 整数型常量池[-128~127]这些数字太常用了，为了提高效率，Java提供了一个整数型常量池。 这个常量池是一个数组：Integer[ ] integerCache; 数组中存储了256个Integer的引用，只要没有超出这个范围的数字，直接从整数型常量池中取。 BigInteger大数字： 超过long了使用java.math.BigInteger 他的父类是Number 他是引用数据类型 常用方法： BigDecimal浮点型超过double就使用BigDecimal 构造方法：BigDecimal(String val) 常用方法： DecimalFormat该类是专门用来对数字进行格式化的。 常用数字格式： ###,###.## 三个数字为一组，组和组之间使用逗号隔开，保留两位小数 ###,###.0000 三个数字为一组，组和组之间使用逗号隔开，保留4位小数，不够补0 构造方法：DecimalFormat(String pattern) 常用方法：String format(数字) 日期相关API获取时间123456789// java.util.Date 日期API// 获取系统当前时间Date date = new Date() // 获取指定的时间Date date1 = new Date(输入毫秒数) //1970年0时0分0秒 + 输入的毫秒数 // 获取1970到当前的毫秒数,这是java.lang.System类的方法。long time = System.currentTimeMillis(); 日期格式化123456789import java.util.Date;import java.text.SimpleDateFormat;public class DateTest01&#123; public static void main(String[] args)&#123; SimpleDateFormat sdf = new SimpleDateFormat(输入格式的字符串) // 各种格式见文档 String str = sdf.format(输入要转换的时间) // 日期转格式化字符串 &#125;&#125; 将String转化成Date1234String strDate = &quot;2008-08-08 08:08:08 888&quot;;SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);Date date = sdf2.parse(strDate); // 用自己创建的格式去解析字符串中的日期 java.util.Calend ar 日历类获取当前时间的日历对象1Calendar c = Calendar.getInstance(); 获取日历中的某部分 修改日历中的内容 日历的新API（java8）日期传统的日期API存在线程安全问题，于是java8提供了一套全新的日期API 时间戳 计算时间间隔、日期间隔 时间矫正器 日期格式化 注意：这里使用LocalDateTime去调用parse方法，还需要把格式作为参数传入。 数学类 Math回顾：工具类的方法都是静态的，直接使用类名调用。 枚举类优点 可读性强 做了类型的限定，在编译阶段就可以确定类型是否正确，不正确会报错 定义123enum 枚举类型名 &#123; 枚举值1,枚举值2,枚举值3,枚举值4&#125; 特点： 高级用法 Random 随机数生成器 12Random random = new Random();int num = random.nextInt(101); // 生成一个[0,101)的随机数 System类 UUID 通用唯一标识符UUID是一种软件构建的标准，用来生成具有唯一性的ID。 12UUID uuid = UUID.randomUUID();String s = uuid.toString(); 七、集合集合概述 集合是一种容器，用来组织和管理数据。 Java的集合框架对应的这套类库其实就是对各种数据结构的实现。 集合存储的是引用。 默认情况下，如果不使用泛型，集合中可以存储任何类型的引用。 Java集合框架分为两部分： Collection结构：元素以单个的形式存储 Map结构：元素以键值对的映射关系存储 Collection 关系图 Collection接口的通用方法 Collection的通用遍历&#x2F;迭代方式面向接口编程 1234567891011Collection col = new ArrayList();// 第一步：获取集合的迭代器对象Iterator it = col.iterator();// 第二步：判断光标当前指向的位置是否有元素while(it.hasNext())&#123; // 第三步：光标返回当前指向的内容，并移动到下一个元素 Object obj = it.next(); System.out.println(obj);&#125; SequencedCollection接口所有的有序集合都实现了SequencedCollection接口 泛型 java5新特性，是编译阶段的功能。 泛型初体验 程序编写时看帮助文档中是否有”&lt;&gt;”符号，如果有这个符号就可以使用泛型。 创建一个集合，要求这个集合中只能存放某种类型的对象，就可以使用泛型 12345678Collection&lt;User&gt; users = new ArrayList&lt;User&gt;();Iterator&lt;User&gt; it = users.iterator();while(it.hasNext())&#123; User user = it.next(); user.pay()&#125;// 如果不用泛型，it.next()返回的类型是Object，还需要向下转型才能使用子类独有的方法。而使用了泛型后，迭代器返回的类型就自动向下转型为子类了。 泛型的作用 钻石表达式 （Java7新特性）1Collection&lt;User&gt; users = new ArrayList&lt;&gt;() // 后面尖括号中的内容可以省略 泛型擦除与补偿（了解） 泛型的定义在类上自定义泛型12345678public class vip&lt;NameType, AgeType&gt;&#123; // 在声明类时写上泛型名称 public vip(NameType name, AgeType age)&#123; this.name = name; this.age = age; &#125; private NameType name; private AgeType age;&#125; 在类上定义的泛型，在静态方法中无法使用。（因为静态方法直接通过类名调用，此时还没有通过声明类的对象来指定泛型的类型。） 在静态方法上定义泛型123456789101112public class test&#123; public static &lt;T&gt; void print(T element)&#123; // 在使用前需要先定义泛型 System.out.println(element); &#125; public static void main(String[] args)&#123; String a = &quot;Hello World!&quot;; test.print(a); &#125;&#125; 在接口上定义泛型和类定义泛型差不多。 12345678910111213141516171819public interface MyCompare&lt;T&gt;&#123; public int compare(T element); &#125;// 第一种实现接口的方式：此时我已经知道泛型要用什么类型了public class Product implements MyCompare&lt;int&gt;&#123; @Override public int compare(int a)&#123; 比较的代码; &#125;&#125;// 第二种实现接口的方式：此时还不知道泛型用什么类型public class test&lt;T&gt; implements MyCompare&lt;T&gt;&#123; // 再给类定义一个泛型，然后等创建对象时再确定泛型的类型 @Override public int compare(T a)&#123; // 或者这个时候就不要用泛型了，直接把参数的类型写成 Object 比较的代码; &#125;&#125; 泛型的使用泛型通配符无限定通配符&lt;?&gt; 此处表示后面填写的泛型可以是任意数据类型。 上限通配符&lt;? extends Number&gt; 表示泛型必须为Number及其子类 下限通配符&lt;？ super Number&gt; 表示泛型必须为Number及其父类 集合的并发修改问题 fail-fast 机制 集合中设置了一个modCount属性，用来记录修改的次数，使用集合对象执行增删改的操作时，modCount就会自动加1。 获取迭代器对象时，会给迭代器对象初始化一个expectedModCount属性，并且将modCount的值赋值给expectedModCount。 即int expectedModCount = modCount; 当使用集合对象删除元素时，modCount会加1，但是迭代器中的expectedModCount没有加1。而当迭代起对象的next()方法执行时，会检测expectedModCount和modCount是否相等，如果不相等，就会抛出ConcurrentModificationException异常 而如果使用迭代起删除元素时，modCount和expectedModCount都会加1.这样next()方法在检测时就是相等的，不会出现异常。 注：即使没有使用多线程编程，但是用迭代器去遍历的同时使用集合去删除元素，这个行为将被认为并发修改。 所以，迭代集合时，要使用 迭代器对象.remove()，移除的是当前光标所执行的元素。 List 接口特点有序、可重复 常见的实现类 ArrayList 数组 Vector、Stack 数组（线程安全的） LinkedList 双向链表 List接口特有的方法 List特有的迭代方式 注：调用迭代器的remove和set方法的前提是之前调用了next或者previous方法获取了一个元素，remove和set是作用于之前获取的那个元素上的。 List接口使用Comparator排序回顾数组中自定义类型是如何排序的？ 所有自定义类型排序时必须指定排序规则，实现Comparable接口，并重写compareTo方法。 重写是override List集合的排序 default void sort(Comparator&lt;? super E&gt; c); sort方法需要一个参数：java.util.Comparator ，我们把它叫做比较器，它是一个接口。 如何给自定义类型指定比较规则？可以对Comparator提供一个实现类，并重写compare方法来指定比较规则 这个实现类也可以看采用匿名内部类的方式。 对数组的排序是在类里面重写比较规则，对List集合的排序是单独设定一个比较规则并在需要时使用。 ArrayList 类回顾：数组的优缺点优点数组在内存中是连续存储的，有下标就有偏移量，可以通过偏移量计算出对应元素的内存地址。检索效率高，时间复杂度O（1） 缺点 不能存储大数据（因为内存地址是连续的） 随机增删元素耗时很长 使用场景需要频繁检索元素，很少进行随机增删的情况。 ArrrayList扩容策略 当调用无参构造方法时，初始化容量为0。 当第一次调用add方法时，将ArrayList容量初始化为10个长度。 后续扩容时，底层会创建一个新的数组，然后使用数组拷贝。新数组的容量是原容量的1.5倍。 Vector 类（*不怎么使用了） LinkedList 双向链表类 栈 数据结构 队列 数据结构 入队：offer 出队：poll 三种Set map和set的关系 map是键值对，把键那一列单独拿出来，就是set集合。 Map Map 接口的常用方法 Map 集合的遍历方法一：获取Map集合的所有key，然后遍历每个key，通过key获取value12345678910111213Set&lt;Integer&gt; keys = maps.keySet();// 写法一Iterator&lt;Integer&gt; it = keys.iterator();while(it.hasNext())&#123; Integer key = it.next(); System.out.println(key + &quot;=&quot; + maps.get(key))&#125;// 写法二for(Integer key : keys)&#123; System.out.println(key + &quot;=&quot; + maps.get(key))&#125; 方法二：获取Map的内部类Map.Entry (效率更高，常用这个)不需要再通过key去找value了 12345678910111213Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();// 写法一Iterator it = entries.iterator();while(it.hasNext())&#123; Map.Entry&lt;Integer,String&gt; entry = it.next(); System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());&#125;// 写法二for(Map.Entry&lt;Integer,String&gt; entry : entries)&#123; System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());&#125; HashMap哈希表存储原理 ！！hashCode和equals方法要同时重写使用equals的前提条件是两个元素计算得到的索引值是相同的，在同一个链表中。那么保证这两个元素使用hashCode()返回的结果是相同的才能准确的保证索引值相同。 因此，存放在HashMap集合key部分的元素，以及存放在HashSet集合中的元素，需要同时重写hashCode和equals方法 HashMap在Java8后的改进初始化时机java8之前，构造方法执行初始化table数组 java8之后，第一次调用put方法时初始化table数组 插入方法java8之前：头插法 java8之后：尾插法 数据结构java8之前：数组+单向链表 java8之后：数组+单向链表&#x2F;红黑树 如果结点数量&gt;&#x3D;8，且table长度&gt;&#x3D;64，单向链表转为红黑树 当删除红黑树上的结点，使节点数量&lt;&#x3D;6时，红黑树转换为单向链表 HashMap的容量永远是2的次幂原因： 提高哈希计算的效率（位运算的效率比%取模运算效率高） 当length为2的次幂时,length-1的二进制低位全是1，此时hash &amp; (length - 1) 相当于 保留 hash 的低 n 位，结果与hash%length一致，使用位运算效率更高。 减少哈希冲突，让散列分布更加均匀 假设length是偶数，length-1结果一定是奇数，它的二进制中的最后一位一定是1，和别人相与可能是0或1。如果length是奇数，length-1是偶数，那么二进制最后一位是0，和别人相与只能是0，那么最后table有一半都是空的，存不了东西。 HashMap的初始化容量设置 当哈希表中的元素越来越多时，散列碰撞的几率就会越来越高，导致单链表过长，降低了哈希表的性能，此时要进行哈希表扩容 而一旦进行扩容，由于length改变，所有元素的hash值都会改变，效率比较低，所以在初始化的时候最好设置好数组大小，避免过多次数的扩容。 扩容时间点：当哈希表中的元素个数超过数组大小*0.75后进行扩容，新数组大小为2*原数组大小 LinkedHashMap LinkedHashMap是HashMap集合的子类 用法和HashMap几乎一样 只不过LinkedHashMap可以保证元素的插入顺序 底层数据结构：哈希表+双向链表（记录顺序） Hashtable（效率低，不常用） Properties 属性类 TreeMap排序二叉树按照左小右大存储，按照中序遍历自动得到升序排列的元素。 缺点：如果插入的节点集本来就是有序的，那么最后得到的二叉树其实就是一个普通链表，检索效率很差。 平衡二叉树 红黑二叉树一棵自平衡的排序二叉树 构造方法一个是没有参数的，一个是需要传比较器的 put() 方法先调用比较器，如果比较器是NULL，就使用类中的compareTo方法进行比较。 因此有两种方式来修改比较方法。 法一：实现Comparable&lt;&gt;接口，并重写compareTo方法 适用于比较规则不会改变的情况，比如数字、字符串的比较 法二：再写一个类去实现Comparator&lt;&gt;接口，重写compare方法，在创建对象时将比较器传递给TreeMap 适用于比较规则会改变的情况 总结：哪些集合不能添加NULL Hashtable的key、value Properties的key、value TreeMap的key ​ -&gt; TreeSet不能添加null Collections 工具类 八、IO流IO流概述分类根据流向分输入流（read）、输出流（write） 根据读写数据的形式分 字节流：一次读取一个字节。适合读取非文本数据，比如图片、音频、视频等。 字符流：一次读取一个字符。只适合读取普通文本，不适合读取二进制文件。因为字符流统一使用Unicode编码，可以避免出现编码混乱的问题。 根据流在IO操作中的作用和实现方式分 节点流：负责数据源和数据目的地的连接，是IO中最基本的组成部分。 处理流：处理流对节点流进行装饰&#x2F;包装，提供更多高级处理操作，方便用户进行数据处理。 IO流体系结构 InputStream 字节输入流 OutputStream 字节输出流 Reader 字符输入流 Writer 字符输出流 所有流都实现了Closable接口，都有close()方法，流用完要关闭。 所有的输出流都实现了Flushable，都有flush()方法，flush方法的作用是，将缓存全部写出并清空。 FileInputStream 类称为文件字节输入流，是一个万能流，任何文件都能读，但还是建议读二进制文件，例如图片、声音、视频。 常用构造方法FileInputStream(String name)通过文件路径构建一个文件字节输入流对象。 注意: 反斜杠需要使用转义字符，即两个反斜杠 \\\\ 也可使用一个正的斜杠 / 使用方法int read();调用一次read()方法就读取一个字节，返回读到的字节本身。如果读不到任何数据则返回-1 int read(byte[] b);一次最多可以读到b.length个字节（只要文件内容足够多），返回值是读取到的字节数。读取的内容存在b数组中。 int read(byte[] b, int off, int len);一次读取len个字节，将读到的数据从byte数组的off位置开始放 long skip(long n);跳过n个字节 int available();获取流中剩余的预估计字节数。 可以用这个初始化数组长度，这样就不需要使用循环来判断是否还有可读取的内容。 void close()；关闭流 FileOutputStream文件字节输出流，负责写。 常用构造方法 FileOutputStream(String name) 创建一个文件字节输出流对象，这个流在使用时，会先将原文件内容全部清空，然后写入。 FileOutputStream(String name, boolean append) ​ 创建一个文件字节输出流对象，当append是true时，不会清空原文件的内容，在原文件末尾追加。 ​ 当append是false时，会清空原文件的内容，在原文件末尾追加。 常用方法void close();void flush();刷新 void write(int b);写一个字节 void write(byte[] b);将整个byte字节数组写入 void write(byte[] b, int off, int len);将byte字节数组的一部分写入 TryWithResources 资源自动关闭 Java7新特性凡是实现了AutoCloseable接口的流都可以使用try-with-resources，都会自动关闭。 格式： 123456789try( 声明流; 声明流; 声明流; 声明流)&#123; // 最后一个不用写分号 &#125;catch()&#123; &#125; FileReader 读取普通文本 FileWriter 注意：只能复制普通文本文件！！！ 路径绝对路径、相对路径、类路径 12String path = Thread.currentThread().getContextClassLoader().getResource(&quot;filename&quot;).getPath();System.out.println(path); Thread.currentThread() 获取当前线程 Thread.currentThread().getContextClassLoader() 获取当前线程的类加载器 getResource(&quot;filename&quot;) 从类的根路径下开始加载资源 src文件夹是类路径的根路径 优点：通用，在进行系统移植的时候，仍然可以使用。 注：这种方式只能从类路径中加载资源，如果这个资源在类路径之外，就无法访问到。 BufferedInputStream&#x2F;BufferedOutputStream对缓冲流的理解 使用 1️⃣为什么这里仍然需要使用数组呢？ 这个数组是接收缓冲区中的大数组中的内容，它本身不和文件进行交互。 标记mark() 在当前位置打上标记 reset() 回到上一次打标记的位置 一个文件中最多只有一个标记 调用顺序：先调用mark，再调用reset 如何解决乱码问题 所有输入输出底层都需要使用字节流，而字符流是将字节流包装后得到的。进行了这种包装操作的流叫包装流。 使用InputStreamReader&#x2F;OutputStreamWriter时可以指定解码的字符集。 常用构造方法： InputStreamReader(InputStream in) 采用平台默认的字符集进行解码 InputStreamReader(InputStream in, String charsetName) 采用指定的字符集进行解码 FileReader是InputStreamReader的子类，是一个包装流。 ​ FileWriter同理。 InputStreamReader&#x2F;OutputStreamWriter 的创建需要传入字节流，而FileReader&#x2F;FileWriter 的创建直接输入文件地址即可。 数据流 将java程序中的数据直接写入文件，写进去就是二进制。 效率很高——写的过程不用转码 DataOutputStream写到文件中的数据，只能由DataInputStream来读取 读取顺序必须按照写入顺序！ 123456789101112131415161718// 写入DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;filename&quot;)); byte b1 = 127;short s1 = 222;dos.writeByte(b1);dos.writeShort(s1);dos.flush();dos.close();// 读取DataInputStream dis = new DataInputStream(new FileInputStream(&quot;filename&quot;)); byte b2 = dis.readByte();short s2 = dis.readShort();dis.close(); 对象的序列化与反序列化序列化：将对象变成二进制文件 1234567ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;filename&quot;));Date nowDate = new Date();// 序列化Serialoos.writeObject(nowTime); oos.flush();oos.close(); 反序列化：将字节序列转换成JVM中的java对象 1234ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;filename&quot;));//反序列化Object o = ois.readObject(); // 如果明确知道对象的类型，可以强转。ois.close(); 如果是多个对象，那就把这些对象放在集合中。 要参与序列化与反序列化的对象，必须实现 java.io.Serializable 接口。该接口是一个标志接口，没有任何方法。 ObjectOutputStream也有关于数据输出的方法，比如writeInt()、writeBoolean()等，和DataOutputStream中的方法一样。 序列化版本号 为了保证序列化的安全，只有同一个类的对象才能序列化和反序列化。在java中 通过 类名 + 序列化版本号（serialVersionUID）来判断。 当类的内容修改后，serialVersionUID会改变，java程序不允许序列化版本号不同的类进行反序列化。 那如果几个月后，对这个类进行了升级，增加了一些内容怎么办？ ​ 如果确定这个类确实是之前的那个类，类本身是合法的，可以将序列化版本号写死。 1private static final long serialVersionUID = 1231231231231L; serial注解1234import java.io.Serial@Serial // 会自动检查下面的序列号代码是否拼错，在这里alt+回车可以自动生成一个序列号版本。private static final long serialVersionUID = 1231231231231L; transient关键字transient关键字修饰的属性不会参与序列化。 所以进行反序列化的时候这个属性会赋默认值。 打印流 PrintStream&#x2F;PrintWriterPrintStream主要用于打印，提供便携的打印方法和格式化输出。主要打印内容到文件或控制台。 不需要手动刷新。 构造方法PrintStream(OutputStream out); PrintStream(String filename); 常用方法print(Type x); println(Type x); PrintWriter比PrintStream多一个构造方法：PrintWriter(Writer); 标准输入流 System.in用来接收用户在控制台上的输入。 12345678InputStream in = System.in;byte[] bytes = new byte[1024];int readCount = in.read(bytes);for(int i = 0; i &lt; readCount; i++)&#123; System.out.println(bytes[i]); // 这个是逐个输出每个字节的内容，不适合中文等内容&#125; 对于标准输入流来说，也可以改变数据源。不让其从控制台读数据，而是从文件中&#x2F;网络中读取数据。 12345678910// 修改标准输入流的数据源System.setIn(new FileInputStream(&quot;filename&quot;));InputStream in = System.in;byte[] bytes = new byte[1024];int readCount = 0;while((readCount = in.read(bytes)) != -1)&#123; System.out.print(new String(bytes,0,readCount));&#125; 标准输出流 System.out用于输出内容到控制台。 改变输出方向：(常用于记录日志) 123System.setOut(new PrintStream(&quot;filename&quot;));System.out.println(&quot;zhangsan&quot;); File类文件&#x2F;目录的抽象表示形式。 构造方法1234567891011121314151617File file = new File(&quot;e:/filename&quot;);// 如果不存在就以新文件的形式创建if(!file.exists())&#123; file.createNewFile();&#125;// 如果不存在就以目录的形式创建if(!file.exists())&#123; file.mkdir();&#125;// 如果不存在就创建多层文件夹File file2 = new File(&quot;e:/a/b/c/d&quot;);if(!file2.exist())&#123; file2.mkdirs();&#125; 常见方法见文档。12345678File file = new File(&quot;e:/directoryAddress&quot;);File[] files = file.listFiles() // 直接获取所有文档File[] files2 = file.listFiles(new FilenameFilter())&#123; @Override public boolean accept(File dir, String name)&#123; return name.endsWith(&quot;.txt&quot;); // 进行判断，如果结果不是txt就返回false，就不选中这些文件 &#125;&#125; 读取属性配置文件 xxx.properties 文件称为属性配置文件 属性配置文件可以配置一些简单的信息，例如连接数据库的信息通常配置到属性文件中。这样可以做到在不修改java代码的前提下，切换数据库。 属性配置文件的格式: ​ key1 &#x3D; value1 ​ key2 &#x3D; value2 ​ … ​ 注：使用#进行注释，key不能重复，否则value会被覆盖。等号两边不能有空格。 1234567891011String path = Thread.currentThread().getContextClassLoader().getResource(&quot;filename&quot;).getPath();FileReader reader = new FileReader(path); // 创建一个Map集合（属性类对象） Properties pro = new Properties();// 将属性配置文件中的配置信息加载到Properties对象中。pro.load(reader) String driver = pro.getProperty(&quot;driver&quot;);String url = pro.getProperty(&quot;url&quot;); ResourceBundle进行资源绑定 装饰器设计模式符合OCP的情况下怎么完成对类功能的扩展？ 使用子类对父类进行方法扩展。但这种方法会导致两个问题：代码耦合度高、类爆炸问题（会有很多类） 装饰器设计模式：可以做到在不修改原有代码的基础上，完成功能扩展，符合OCP原则，并且避免了使用继承带来的类爆炸问题。 装饰器设计模式中涉及的角色： 抽象的装饰者 具体的装饰者1、具体的装饰者2 被装饰者 装饰者和被装饰者的公共接口&#x2F;公共抽象类 IO流中使用了大量的装饰器设计模式。 压缩流压缩流的使用12345678910111213141516171819202122232425public class GZIPOutputStreamTest &#123; public static void main(String[] args) throws Exception&#123; // 创建文件字节输入流（读某个文件，这个文件将来就是被压缩的。） FileInputStream in = new FileInputStream(&quot;e:/test.txt&quot;); // 创建一个GZIP压缩流对象 GZIPOutputStream gzip = new GZIPOutputStream(new FileOutputStream(&quot;e:/test.txt.gz&quot;)); // 开始压缩（一边读一边写） byte[] bytes = new byte[1024]; int readCount = 0; while((readCount = in.read(bytes)) != -1)&#123; gzip.write(bytes, 0, readCount); &#125; // 非常重要的代码需要调用 // 刷新并且最终生成压缩文件。 gzip.finish(); // 关闭流 in.close(); gzip.close(); &#125;&#125; 解压缩流的使用123456789101112131415161718192021public class GZIPInputStreamTest &#123; public static void main(String[] args) throws Exception &#123; // 创建GZIP解压缩流对象 GZIPInputStream gzip = new GZIPInputStream(new FileInputStream(&quot;e:/test.txt.gz&quot;)); // 创建文件字节输出流 FileOutputStream out = new FileOutputStream(&quot;e:/test.txt&quot;); // 一边读一边写 byte[] bytes = new byte[1024]; int readCount = 0; while((readCount = gzip.read(bytes)) != -1)&#123; out.write(bytes, 0, readCount); &#125; // 关闭流 gzip.close(); // 节点流关闭的时候会自动刷新，包装流是需要手动刷新的。 out.close(); &#125;&#125; 注：节点流关闭时会自动刷新，包装流需要手动刷新。 字节数组流 ByteArrayInputStream、ByteArrayOutputStream都是内存操作流，不需要打开和关闭文件等操作。这些流是非常常用的，可以将它们看作开发中的常用工具，能够方便地读写字节数组、图像数据等内存中的数据。 都是节点流。 使用对象流装饰字节数组流！！为什么要这样做？ 你使用字节数组流直接写入、读出可能只能读取普通的字节数组，还需要自己实现一些转换成复杂类型（各种类）的方法，而包装流已经在内部包含了很多将复杂类型序列化的方法，一行代码就可以帮你直接序列化复杂类型然后写入字节流。 对象深克隆目前为止对象拷贝方式： 调用Object的clone方法，默认是浅克隆，需要深克隆的话，就需要重写clone方法 可以通过序列化和反序列化完成对象的克隆（深克隆） 123456789101112131415161718192021222324252627public class DeepCloneTest &#123; public static void main(String[] args) throws Exception&#123; // 准备对象 Address addr = new Address(&quot;北京&quot;, &quot;朝阳&quot;); User user = new User(&quot;zhangsan&quot;, 20, addr); // 将Java对象写到一个byte数组中。 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(user); oos.flush(); // 从byte数组中读取数据恢复java对象 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); // 这就是那个经过深拷贝之后的新对象 User user2 = (User) ois.readObject(); user2.getAddr().setCity(&quot;南京&quot;); System.out.println(user); System.out.println(user2); &#125;&#125; 九、多线程概述多线程 进程：操作系统中的一段程序，具有独立的内存空间和系统资源，如文件、网络端口等。在计算机程序执行时，先创建进程，再在进程中进行程序的执行。 线程：进程中的一个执行单元。每个线程都有自己的栈和程序计数器，并且可以共享进程的资源。多个线程可以在同一时刻执行不同操作，提高程序的执行效率。一个进程可以有多个线程。 静态变量、实例变量是在堆中的，所以是共享的。 并发使用单核CPU时，同一时刻只能有一条指令执行，但多个指令被快速的轮换执行，使得在宏观上具有多个指令同时执行的效果。 并行多核CPU，同一时刻，多条指令在多个CPU上同时执行。（无论微观还是宏观） 并发与并行 CPU比较繁忙时，如果开启了多个线程，则只能为一个线程分配仅有的CPU资源，多线程会竞争CPU资源。 在CPU资源比较充足时，一个进程内的多个线程可以被分配到不同的CPU资源，实现并行。 多线程实现的是并发还是并行？如上所述，看运行时CPU的资源，都有可能。 线程的调度模型多个线程抢夺一个CPU内核的执行权，需要线程调度策略。 分时调度模型所有线程轮流使用CPU的执行权，并且平均分配每个线程占用的CPU时间 抢占式调度模型让优先级高的线程以较大的概率优先获得CPU的执行权，如果线程的优先级相同，那么就随机选择一个线程获得CPU的执行权。 JAVA采用的就是抢占式调度。 实现多线程的方法第一种 编写一个类继承java.lang.Thread 重写run方法 new线程对象 调用线程对象的start()方法来启动线程 1234567891011121314public class ThreadTest&#123; public static void main(String[] args)&#123; MyThread mt = new MyThread(); mt.start(); &#125;&#125;class MyThread extends Thread&#123; @Override public void run()&#123; 多线程执行的内容; &#125;&#125; start方法的任务是启动一个新线程，分配一个新的栈空间就结束了。 java永远满足一个语法规则：必须自上而下依次逐行运行。 第二种 编写一个类实现java.lang.Runnable接口 实现接口中的run方法 （此处不能thorws异常） new线程对象（把实现Runnable接口的类传给Thread构造方法） 调用线程对象的start()方法来启动线程 这种方式更好，因为以后还可以继承别的类。而第一种已经使用掉继承一个类的名额了。 12345678910111213public class ThreadTest&#123; public static void main(String[] args)&#123; Thread t = new Thread(new MyRunnable()); t.start(); &#125;&#125;class MyRunnable implements Runnable&#123; @Override public void run()&#123; 多线程执行的内容; &#125;&#125; 这种方式还可以使用匿名内部类： 1. 1234567891011public class ThreadTest&#123; public static void main(String[] args)&#123; Thread t = new Thread(new Runnable()&#123; @Override public void run()&#123; 多线程执行的内容; &#125; &#125;); t.start(); &#125;&#125; ​ 2. 1234567891011public class ThreadTest&#123; public static void main(String[] args)&#123; new Thread(new Runnable()&#123; @Override public void run()&#123; 多线程执行的内容; &#125; &#125;).start(); &#125;&#125; 线程常用的三个方法 String getName()； 获取线程对象的名字 void setName(String threadName); 修改线程的名字 static Thread currentThread(); 获取当前线程对象的引用 除了使用setName修改线程的名字，还可以使用有参构造方法。但是需要在类中实现这个有参构造方法。 123public MyThread(String threadName)&#123; super(threadName);&#125; 线程生命周期的7个状态 新建状态 NEW 就绪状态 运行状态 （2-3 官方统称为可运行状态RUNNABLE） 超时等待状态 TIMED_WAITING 等待状态 WAITING 阻塞状态 BLOCKED 终止状态 TERMINATED 线程的休眠Thread.sleep(毫秒数); 在规定的时间内，当前线程没有权利抢夺CPU时间片了。 中断线程的休眠 interrupt()是一个实例方法。 线程对象.interrupt();可以中断线程的休眠。（当然要放在另一个线程里使用才能起作用） 底层原理是利用了异常处理机制。 当调用这个方法的时候，如果t线程正在睡眠，必然会抛出：InterrupttedException，然后捕捉异常，终止睡眠。 停止运行线程线程对象.stop() 已经不建议使用 一般是设置一个标记，然后在线程的循环中使用if语句判断这个标记。 比如 boolean run &#x3D; true; 当达到某个条件后将run改为false，然后if(run){ 运行的内容 } else{return;} return后就终止这个线程了。 守护线程在java中，线程被分为两类：守护线程、用户线程 所有用户线程结束后，守护线程自动退出&#x2F;结束。 在JVM中，有一个隐藏的守护线程一直在守护着，它就是GC线程。 将线程设置为守护线程： 线程对象.setDaemon(true); 定时任务java.util.Timer 定时器 java.util.TimerTask 定时任务 123456789101112131415161718// 创建定时器对象（本质上就是一个线程）Timer timer = new Timer(true); // 这里的true表示设置为守护线程// 指定定时任务SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);Date firstTime = sdf.parse(&quot;2024-01-27 10:22:00&quot;);// 匿名内部类的方式timer.schedule(new TimerTask() &#123; int count = 0; @Override public void run() &#123; // 执行任务 Date now = new Date(); String strTime = sdf.format(now); System.out.println(strTime + &quot;: &quot; + count++); &#125;&#125;,firstTime,1000*5) 线程合并join() 方法是一个实例方法 t.join() 是让当前线程进入阻塞状态，直到t线程结束，当前线程的阻塞状态结束。 个人理解：就是先让t线程打断当前线程自己运行，如果设置的时间结束或者t线程在时间结束前已经运行完了，那当前线程就继续执行。 线程优先级最低1(Thread.MIN_PRIORITY)，最高10(Thread.MAX_PRIORITY) t.setPriority(传入优先级数值) 让位静态方法：Thread.yield() 让当前线程让位。让位不会让其进入阻塞状态，只是放弃当前占有的CPU时间片，进入就绪状态，继续抢夺CPU时间片。 线程安全问题什么情况下需要考虑线程安全问题？ 多线程并发 有共享的数据 共享数据涉及修改操作 一般情况下局部变量不存在线程安全问题。（尤其是基本数据类型，但如果是引用数据类型就另说了。） 实例变量、静态变量可能存在线程安全问题。他们存放在堆中，堆是多线程共享的。 线程同步机制——互斥锁线程排队执行 现有t1和t2线程，t1线程在执行的时候必须等待t2线程执行到某个位置之后，t1线程才能执行。 123synchronized(obj)&#123; // obj为共享对象，在银行取款的例子中，这个共享对象就是账户 // 同步代码块&#125; 假设t1先抢到了CPU时间片，t1线程找到共享对象obj的对象锁后占有这把锁，t2只能在同步代码块之外等待，等t1线程执行完同步代码块之后，才会释放之前占有的对象锁。 synchronized又被称为互斥锁。 synchronized也可以作为标识符直接写在方法（实例方法、静态方法）声明上， 静态方法检测的是类锁，实例方法检测的是对象锁。 线程异步机制线程并发执行 各自执行各自的，谁也不需要等对方。 效率高但可能存在安全隐患。 线程通信涉及到的三个方法：wait()、notify()、notifyAll() 以上三个方法都是Object类的方法。 调用wait方法和notify方法是通过共享对象去调用的。 例如：obj.wait()的效果：在obj对象上活跃的所有线程进入无期限等待，直到调用了该共享对象的notify方法进行唤醒，唤醒后会接着上一次调用wait方法的位置继续执行。 obj.wait() 调用后会释放之前占用的对象锁。 obj.notify() 唤醒优先级最高的等待线程，如果优先级一样，就随机唤醒一个。 obj.notifyAll() 唤醒所有在该共享对象上等待的线程 最完整的生命周期 懒汉式单例模式的线程安全问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151class SingletonTest &#123; // 静态变量 private static Singleton s1; private static Singleton s2; public static void main(String[] args) &#123; // 获取某个类。这是反射机制中的内容。 /*Class stringClass = String.class; Class singletonClass = Singleton.class; Class dateClass = java.util.Date.class;*/ // 创建线程对象t1 Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; s1 = Singleton.getSingleton(); &#125; &#125;); // 创建线程对象t2 Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; s2 = Singleton.getSingleton(); &#125; &#125;); // 启动线程 t1.start(); t2.start(); try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; try &#123; t2.join(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; // 判断这两个Singleton对象是否一样。 System.out.println(s1); System.out.println(s2); System.out.println(s1 == s2); &#125;&#125;/** * 懒汉式单例模式 */public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; System.out.println(&quot;构造方法执行了！&quot;); &#125; // 非线程安全的。 /*public static Singleton getSingleton() &#123; if (singleton == null) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; singleton = new Singleton(); &#125; return singleton; &#125;*/ // 线程安全的：第一种方案（同步方法），找类锁。 /*public static synchronized Singleton getSingleton() &#123; if (singleton == null) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; singleton = new Singleton(); &#125; return singleton; &#125;*/ // 线程安全的：第二种方案（同步代码块），找的类锁 /*public static Singleton getSingleton() &#123; // 这里有一个知识点是反射机制中的内容。可以获取某个类。 synchronized (Singleton.class)&#123; if (singleton == null) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; singleton = new Singleton(); &#125; &#125; return singleton; &#125;*/ // 线程安全的：这个方案对上一个方案进行优化，提升效率。 /*public static Singleton getSingleton() &#123; if(singleton == null)&#123; synchronized (Singleton.class)&#123; if (singleton == null) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;*/ // 使用Lock来实现线程安全 // Lock是接口，从JDK5开始引入的。 // Lock接口下有一个实现类：可重入锁（ReentrantLock） // 注意：要想使用ReentrantLock达到线程安全，假设要让t1 t2 t3线程同步，就需要让t1 t2 t3共享同一个lock。 // Lock 和 synchronized 哪个好？Lock更好。为什么？因为更加灵活。synchronized代码块的大括号必须包住所有语句，而unlock()可以任意插入到一些语句中，但一定要记得执行unlock() private static final ReentrantLock lock = new ReentrantLock(); public static Singleton getSingleton() &#123; if(singleton == null)&#123; try &#123; // 加锁 lock.lock(); if (singleton == null) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; singleton = new Singleton(); &#125; &#125; finally &#123; // 解锁（需要100%保证解锁，怎么办？finally） lock.unlock(); &#125; &#125; return singleton; &#125;&#125; Lock 和 synchronized 哪个好？ Lock更好，因为更加灵活。synchronized代码块的大括号必须包住所有语句，而unlock()可以任意插入到一些语句中，但一定要记得执行unlock() 创建线程的第三种方法——未来任务优点：可以拿到线程执行结束的返回值 123456789101112131415161718192021222324252627// 创建“未来任务”对象 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; // 处理业务...... Thread.sleep(1000 * 5); return 1; &#125; &#125;); // 创建线程对象 Thread t = new Thread(task); t.setName(&quot;t&quot;); // 启动线程 t.start(); try &#123; // 获取“未来任务”线程的返回值 // 阻塞当前线程，等待“未来任务”结束并返回值。 // 拿到返回值，当前线程的阻塞才会解除。继续执行。 Integer i = task.get(); System.out.println(i); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 创建线程的第四种方式——线程池服务器启动时，创建N个线程对象，直接放到线程池中，需要的时候把任务交给线程池即可。 123456789101112131415// 创建一个线程池对象（线程池中有3个线程） ExecutorService executorService = Executors.newFixedThreadPool(3); // 将任务交给线程池（你不需要触碰到这个线程对象，你只需要将要处理的任务交给线程池即可。） executorService.submit(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + i); &#125; &#125; &#125;); // 最后记得关闭线程池 executorService.shutdown(); 十、反射 reflect概述 后续学的大量java框架都是基于反射机制实现的。 反射机制可以让程序更加灵活 反射机制最核心的几个类： ​ java.lang.Class : Class类型的实例代表硬盘上某个class文件，或者说代表某一种类型 ​ java.lang.reflect.Filed : 实例代表类中的属性&#x2F;字段 ​ java.lang.reflect.Constructor : 它的实例代表类中的构造方法 ​ java.lang.reflect.Method : 它的实例代表类中的方法 获取Class的四种方式第一种Class c = Class.forName(&quot;完整的全限定类名&quot;); 注： 全限定类名是带有包名的，不可省略 这是个字符串参数 如果这个类根本不存在，会报异常：java.lang.ClassNotFoundException 这个方法的执行会导致类的加载动作的发生 第二种Class c = obj.getClass(); 第三种Class c = 类名.class; 第四种——使用类加载器123ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();Class&lt;?&gt; aClass = systemClassLoader.loadClass(&quot;完整的全限定类名&quot;) Class.forName() 和 classLoader.loadClass() 的区别： ​ Class.forName() ：类加载时会进行初始化（静态变量赋值、静态代码块执行）。 ​ classLoader.loadClass()：类加载时不会进行初始化，直到第一次使用该类。 通过反射机制实例化对象直接对类使用newInstance方法123Class userClass = Class.forName(&quot;test.User&quot;);User user = (User)userClass.newInstance(); 使用反射机制，只要修改属性配置文件就可以完成不同对象的实例化。非常灵活 12345ResourceBundle bundle = ResourceBundle.getBundle(&quot;test.classInfo&quot;);String className = bundle.getString(&quot;className&quot;);Class classObj = Class.forName(className);Object obj = classObj.newInstance(); 使用这种方式必须要有一个无参数构造方法。如果没有会出现异常。 Java9时被标注已过时，不建议使用。 使用构造方法实例化对象无参构造： 12345Class userClass = Class.forName(&quot;test.User&quot;);// 获取无参数构造方法Constructor defaultCon = userClass.getDeclaredConstructor();// 通过无参数构造方法实例化对象Object obj = defaultCon.newInstance(); 有参构造： 1234Class userClass = Class.forName(&quot;test.User&quot;);// 获取有参构造方法Constructor threeArgsCon = userClass.getDeclaredConstructor(String.class, double.class, String.class); // 根据参数的类型，写上对应的类Object obj = threeArgsCon.newInstance(&quot;001215&quot;, 698.5, &quot;未完成&quot;); 通过反射为对象属性赋值123456789101112131415161718192021Class clazz = Class.forName(&quot;com.powernode.javase.reflect.Customer&quot;); // 获取对应的Field Field ageField = clazz.getDeclaredField(&quot;age&quot;); // 调用方法打破封装（原来类里设置的age是private） ageField.setAccessible(true); // 修改属性的值 // 给对象属性赋值三要素：给哪个对象 的 哪个属性 赋什么值 ageField.set(customer, 30); // 读取属性的值 System.out.println(&quot;年龄：&quot; + ageField.get(customer)); // 通过反射机制给name属性赋值，和读取name属性的值 Field nameField = clazz.getDeclaredField(&quot;name&quot;); // 修改属性name的值 nameField.set(customer, &quot;李四&quot;); // 读取属性name的值 System.out.println(nameField.get(customer)); 反射某一个类的方法类加载的过程 虚拟机的三个类加载器 12345678910111213141516171819// 通过自定义的类获取的类加载器是：应用类加载器。ClassLoader appClassLoader = ReflectTest15.class.getClassLoader();System.out.println(&quot;应用类加载器：&quot; + appClassLoader);// 获取应用类加载器ClassLoader appClassLoader2 = ClassLoader.getSystemClassLoader();System.out.println(&quot;应用类加载器：&quot; + appClassLoader2);// 获取应用类加载器ClassLoader appClassLoader3 = Thread.currentThread().getContextClassLoader();System.out.println(&quot;应用类加载器：&quot; + appClassLoader3);// 通过 getParent() 方法可以获取当前类加载器的 “父 类加载器”。// 获取平台类加载器。System.out.println(&quot;平台类加载器：&quot; + appClassLoader.getParent());// 获取启动类加载器。// 注意：启动类加载器负责加载的是JDK核心类库，这个类加载器的名字看不到，直接输出的时候，结果是null。System.out.println(&quot;启动类加载器：&quot; + appClassLoader.getParent().getParent()); 双亲委派机制 某个类加载器接收到加载类的任务时，通常委托给“父 类加载器”进行加载 最大的“父 类加载器”无法加载时，一级一级向下委托加载任务 作用： 保护程序的安全 防止类加载重复 获取泛型获取父类的泛型1234567891011121314151617181920// 获取类 Class&lt;Cat&gt; catClass = Cat.class; // 获取当前类的父类泛型 Type genericSuperclass = catClass.getGenericSuperclass(); //System.out.println(genericSuperclass instanceof Class); //System.out.println(genericSuperclass instanceof ParameterizedType); // 如果父类使用了泛型 if(genericSuperclass instanceof ParameterizedType)&#123; // 转型为参数化类型 ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass; // 获取泛型数组 Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); // 遍历泛型数组 for(Type a : actualTypeArguments)&#123; // 获取泛型的具体类型名 System.out.println(a.getTypeName()); &#125; &#125; 获取接口的泛型123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args) &#123; Class&lt;Mouse&gt; mouseClass = Mouse.class; // 获取接口上的泛型 类可以单继承、多实现，因此实现一个接口算一个Type，实现多个接口就需要数组了。每个接口上的泛型就是一个Type Type[] genericInterfaces = mouseClass.getGenericInterfaces(); for (Type g : genericInterfaces) &#123; // 使用了泛型 if(g instanceof ParameterizedType)&#123; ParameterizedType parameterizedType = (ParameterizedType) g; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for(Type a : actualTypeArguments)&#123; System.out.println(a.getTypeName()); &#125; &#125; &#125; &#125;&#125;public class Mouse implements Flyable&lt;String, Integer&gt;, Comparable&lt;Mouse&gt;&#123; @Override public int compareTo(Mouse o) &#123; return 0; &#125;&#125; 获取属性上的泛型12345678910111213141516171819202122public class User &#123; private Map&lt;Integer, String&gt; map;&#125;public class Test &#123; public static void main(String[] args) throws Exception&#123; // 获取这个类 Class&lt;User&gt; userClass = User.class; // 需要先获取属性 Field mapField = userClass.getDeclaredField(&quot;map&quot;); // 获取公开的以及私有的 // 获取属性上的泛型 Type genericType = mapField.getGenericType(); // 用泛型了 if(genericType instanceof ParameterizedType)&#123; ParameterizedType parameterizedType = (ParameterizedType) genericType; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for(Type a : actualTypeArguments)&#123; System.out.println(a.getTypeName()); &#125; &#125; &#125;&#125; 获取方法参数、返回值上的泛型12345678910111213141516171819202122232425262728293031323334353637383940public class MyClass &#123; public Map&lt;Integer, Integer&gt; m(List&lt;String&gt; list, List&lt;Integer&gt; list2)&#123; return null; &#125;&#125;public class Test &#123; public static void main(String[] args) throws Exception&#123; // 获取类 Class&lt;MyClass&gt; myClassClass = MyClass.class; // 获取方法 Method mMethod = myClassClass.getDeclaredMethod(&quot;m&quot;, List.class, List.class); // 获取方法参数上的泛型 Type[] genericParameterTypes = mMethod.getGenericParameterTypes(); for(Type g : genericParameterTypes)&#123; // 如果这个参数使用了泛型 if(g instanceof ParameterizedType)&#123; ParameterizedType parameterizedType = (ParameterizedType) g; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for(Type a : actualTypeArguments)&#123; System.out.println(a.getTypeName()); &#125; &#125; &#125; // 获取方法返回值上的泛型 Type genericReturnType = mMethod.getGenericReturnType(); if(genericReturnType instanceof ParameterizedType)&#123; ParameterizedType parameterizedType = (ParameterizedType) genericReturnType; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for(Type a : actualTypeArguments)&#123; System.out.println(a.getTypeName()); &#125; &#125; &#125;&#125; 获取构造方法函数上的泛型1234567891011121314151617181920212223public class User &#123; public User(Map&lt;String ,Integer&gt; map)&#123; &#125;&#125;public class Test &#123; public static void main(String[] args) throws Exception&#123; Class&lt;User&gt; userClass = User.class; Constructor&lt;User&gt; con = userClass.getDeclaredConstructor(Map.class); Type[] genericParameterTypes = con.getGenericParameterTypes(); for(Type g :genericParameterTypes)&#123; if(g instanceof ParameterizedType)&#123; ParameterizedType parameterizedType = (ParameterizedType) g; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for(Type a : actualTypeArguments)&#123; System.out.println(a.getTypeName()); &#125; &#125; &#125; &#125;&#125; 十一、注解概述什么是注解？ JDK1.5引入 可以标注在类上、方法上、属性上、构造方法上、方法参数上等…… 注解可以做到在不改变代码逻辑的前提下在代码中嵌入补充信息 注解与注释注解：给编译器或者其他程序看的，程序根据注解来决定不同的处理方式 注释：给程序员看 框架框架 &#x3D; 反射 + 注解 + 设计模式 内置的注解@Deprecated用来标记过时的元素，在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的类、过时的方法、过时的属性等。 @Override修饰实例方法，则该方法必须是个重写方法，否则就会编译失败。 @SuppressWarnings（抑制警告的注解）在实际开发中，建议尽量不要忽略警告，而是真正的去解决警告。 @SuppressWarnings(“rawtypes”)：抑制未使用泛型的警告 @SuppressWarnings(“resource”)：抑制未关闭资源的警告 @SuppressWarnings(“deprecation”)：抑制使用了已过时资源时的警告 @SuppressWarnings(“all”)：抑制所有警告 @FunctionalInterface“函数式接口”的注解，这个是 JDK1.8 版本引入的新特性。使用@FunctionalInterface标注的接口，则该接口就有且只能存在一个抽象方法，否则就会发生编译错误。 （注意：接口中的默认方法或静态方法可以有多个。） 自定义注解如何自定义创建一个annotation类型的文件，在文件中写入注解的定义。 12public @interface MyAnnotation &#123;&#125; 注解中定义属性属性的类型只能是： byte，short，int，long，float，double，boolean，char String、Class、枚举类型、注解类型 以上所有类型的一维数组形式 12345678public @interface MyAnnotation &#123; String a; int b default 10; // 可以使用default语句指定默认值 int flag;&#125;//注解的使用@interface(a=&quot;test&quot;,flag=0) //带默认值的属性可以不在此赋值 如果属性只有一个，并且属性名是value，那使用注解的时候可以省略value这个属性名。 1234public @interface MyAnnotation &#123; String value;&#125;@interface(&quot;test&quot;) 如果属性是一个数组，使用注解时，数组值只有一个，数组的大括号可以省略。 12345public @interface MyAnnotation &#123; String[] value;&#125;@interface(&quot;test1&quot;)@interface(&#123;&quot;test1&quot;,&quot;test2&quot;&#125;) 元注解@Retention：设置注解的保持性注解存在阶段是保留在源代码（编译期），字节码（类加载）或者运行时（JVM中运行） @Retention(RetentionPolicy.SOURCE)：注解仅存在于源代码中，在字节码文件中不包含。 @Retention(RetentionPolicy.CLASS)：注解在字节码文件中存在，但运行时无法获得（默认）。 @Retention(RetentionPolicy.RUNTIME)：注解在字节码文件中存在，且运行时可通过反射获取。 @Target：设置注解可以使用的位置 @Target(ElementType.TYPE)：作用于接口、类、枚举、注解 @Target(ElementType.FIELD)：作用于属性、枚举的常量 @Target(ElementType.METHOD)：作用于方法 @Target(ElementType.PARAMETER)：作用于方法参数 @Target(ElementType.CONSTRUCTOR)：作用于构造方法 @Target(ElementType.LOCAL_VARIABLE)：作用于局部变量 @Target(ElementType.ANNOTATION_TYPE)：作用于注解 @Target(ElementType.PACKAGE)：作用于包 @Target(ElementType.TYPE_PARAMETER)：作用于泛型，即泛型方法、泛型类和泛型接口。 @Target(ElementType.TYPE_USE)：作用于任意类型。 @Documented：设置注解会被包含在API文档中使用javadoc.exe工具可以从程序源代码中抽取类、方法、属性等注释形成一个源代码配套的API帮助文档，而该工具抽取时默认不包括注解内容。如果注解被@Documented标注，那么就能被javadoc.exe工具提取到API文档。 @Inherited：被标注的注解支持继承使用后子类会继承父类的注解。 @Repeatable：设置后可以在一个地方重复使用同一注解（java8）@Repeatable(原注解的复数形式) 但是需要再声明一个原来注解的复数形式，并在其中包含原注解类型的数组。 123456789public class Test &#123; @Author(name = &quot;张三&quot;) @Author(name = &quot;李四&quot;) public void doSome()&#123; &#125;&#125; 123456789@Repeatable(Authors.class)public @interface Author &#123; /** * 作者的名字 * @return 作者的名字 */ String name();&#125; 12345public @interface Authors &#123; Author[] value();&#125; 反射注解获取类上的所有注解 ​ Annotation[] annotations = clazz.getAnnotations(); 获取类上指定的某个注解 ​ clazz.isAnnotationPresent(AnnotationTest01.class) ​ AnnotationTest01 an = clazz.getAnnotation(AnnotationTest01.class); 获取属性上的所有注解 ​ Annotation[] annotations = field.getAnnotations(); 获取属性上指定的某个注解 ​ field.isAnnotationPresent(AnnotationTest02.class) ​ AnnotationTest02 an = field.getAnnotation(AnnotationTest02.class); 获取方法上的所有注解 ​ Annotation[] annotations = method.getAnnotations(); 获取方法上指定的某个注解 ​ method.isAnnotationPresent(AnnotationTest02.class) ​ AnnotationTest02 an = method.getAnnotation(AnnotationTest02.class); 十二、网络编程概述网络编程的三个基本要素： IP地址：定位网络中的某台计算机 端口号port：定位计算机上的某个进程（某个应用） 通信协议：通过IP地址和端口号定位后，如何保证数据可靠高效的传输，就需要依靠通信协议。 IP地址 IPv4：4字节，xxx.xxx.xxx.xxx 每个xxx表示8位二进制数，范围是0-255 ​ 前三个字节用于表示网络（省市区），最后一个字节用于表示主机（家门牌号） ​ 一些IP地址被保留或者被私有机构使用，不能用于公网的地址分配；还有一些IP地址被用作多播地址，仅用于特定的应用场景。因此实际可以使用的IPv4地址少于总量。 IPv6：16字节，由8组十六进制数表示，如 3ffe:3201:1401:1280:c8ff:fd54:db39:1984 本机地址：127.0.0.1，主机名：localhost 192.168.0.0-192.168.255.255为私有地址，属于非注册地址，专门为组织、机构内部使用。（用于局域网） 端口号port用两个字节（无符号）表示的，取值范围0-65535，计算机端口号可以分为三大类： 公认端口：0-1023，被预先定义的服务通信占用（如http占用80，FTP占用21，Telnet占用23等） 注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。 动态&#x2F;私有端口：49152~65535。 通常情况下，服务器程序使用固定的端口号来监听客户端的请求，而客户端则使用随机端口连接服务器。 OSI参考模型 TCP&#x2F;IP参考模型 网络编程基础类InetAddress类 java.net.IntAddress类用来封装计算机的IP地址和DNS（没有端口信息），它包括一个主机名和一个IP地址，是java对IP地址的高层表示。大多数其它网络类都要用到这个类，包括Socket、ServerSocket、URL、DatagramSocket、DatagramPacket等 常用静态方法 static InetAddress getLocalHost() 得到本机的InetAddress对象，其中封装了IP地址和主机名 lstatic InetAddress getByName(String host) 传入目标主机的名字或IP地址得到对应的InetAddress对象，其中封装了IP地址和主机名（底层会自动连接DNS服务器进行域名解析） 常用实例方法 lpublic String getHostAddress() 获取IP地址 lpublic String getHostName() 获取主机名&#x2F;域名 URL类 URL是统一资源定位符，是互联网上资源位置和访问方法的一种简介表示。每个文件具有唯一的URL。 URL由4部分组成：协议、存放资源的主机域名、端口号、资源文件名。如果未指定端口号，则使用协议默认的端口。HTTP协议的默认端口为80。 URL的标准格式：&lt;协议&gt;:&#x2F;&#x2F;&lt;域名或IP&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;，其中端口和路径有时可以省略。 为了方便程序员编程，JDK提供了java.net.URL类，该类封装了大量复杂的涉及从远程站点获取信息的细节，可以使用它的各种方法对URL对象进行分割、合并等处理 构造方法1URL url = new URL(&quot;http://127.0.0.1:8080/oa/index.html?name=zhangsan#tip&quot;); 常用方法获取协议：url.getProtocol() 获取域名：url.getHost() 获取默认端口：url.getDefaultPort() 获取端口：url.getPort() 获取路径：url.getPath() 获取资源：url.getFile() 获取数据：url.getQuery() 获取锚点：url.getRef() openStream()：可以打开到此URL的连接并返回一个用于从该连接读入的InputStream，实现最简单的爬虫。 TCP 与 UDP 协议Socket 套接字 Socket是传输层供给应用层的编程接口。使用Socket编程可以开发客户端和服务器应用程序，可以在本地网络上进行通信，也可以通过互联网在全球范围内通信。 TCP协议和UDP协议是传输层的两种协议。Socket编程分为TCP编程和UDP编程两类。 TCP、UDP协议 TCP 三次握手（通道打开） 客户端发送SYN（同步）数据包，包含客户端的初始序列号（ISN） 服务器收到SYN数据包后，发送SYN-ACK（同步确认）数据包，包含服务器的初始序列号（ISN）和对客户端ISN的确认号（ACK） 客户端收到SYN-ACK数据包后，发送ACK（确认）数据包，包含对服务器ISN的确认号（ACK） 三次握手完成后，客户端和服务器就可以开始交换数据了。 三次握手的意义：不会丢失、重复、乱序，保证数据在两个设备之间可靠地传输。 四次挥手（通道关闭） 客户端发送FIN（结束）数据包，表示客户端已经完成数据传输，希望关闭连接。 服务器收到FIN数据包后，发送ACK（确认）数据包，表示服务器已经收到客户端的FIN数据包，同意关闭连接。 服务器发送FIN数据包，表示服务器已经完成数据传输，希望关闭连接。 客户端收到FIN数据包，发送ACK（确认）数据包。表示客户端已经收到服务器的FIN数据包，并同意关闭连接。 四次挥手完成后，客户端和服务器之间的连接就关闭了。 四次挥手的意义：不会丢失、重复、乱序，保证数据在两个设备之间可靠地传输。 基于TCP协议的编程概述 在网络通讯中，第一次主动发起通讯的程序被称作客户端(Client)，而在第一次通讯中等待连接的程序被称作服务端(Server)。一旦通讯建立，则客户端和服务器端完全一样，没有本质的区别。 套接字与主机地址和端口号相关联，主机地址就是客户端或服务器程序所在的主机的IP地址，端口地址是指客户端或服务器程序使用的主机的通信端口。在客户端和服务器中，分别创建独立的Socket，并通过Socket的属性，将两个Socket进行连接，这样客户端和服务器通过套接字所建立连接并使用IO流进行通信。 Socket类Socket实现客户端套接字。 构造方法： public Socket(InetAddress a, int p) 创建套接字并连接到指定IP地址的指定端口号 Socket类实例方法： public InetAddress getInetAddress() 返回此套接字连接到的远程 IP 地址 public InputStream getInputStream() 返回此套接字的输入流（接收网络消息） public OutputStream getOutputStream() 返回此套接字的输出流（发送网络消息） public void shutdownInput() 禁用此套接字的输入流 public void shutdownOutput() 禁用此套接字的输出流 public synchronized void close() 关闭此套接字（默认会关闭IO流） ServerSocket类ServerSocket类实现服务器套接字。服务器套接字等待请求通过网络传入，基于该请求执行某些操作，然后向请求者返回结果。 构造方法： public ServerSocket(int port) ServerSocket类实例方法： public Socket accept() 侦听要连接到此套接字并接受它 public InetAddress getInetAddress() 返回此服务器套接字的本地地址 public void close() 关闭此套接字 十三、lambda表达式 面向对象的思想 只做一件事情，找一个能解决这个事情的对象，然后调用对象的方法完成这件事情。 函数式编程思想 只要能获得结果，谁去做的，怎么做的都不重要，重视结果，忽略实现过程 Lambda和匿名内部类的区别 所需类型不同 匿名内部类：可以是接口、抽象类、具体类 Lambda表达式：只能是接口 使用限制不同 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类。 如果接口中有多个抽象方法，就只能使用匿名内部类，而不能使用Lambda表达式。 实现原理不同 匿名内部类：编译之后，会生成一个单独的.class字节码文件 Lambda表达式：编译之后，不会生成一个单独的.class字节码文件 Lambda表达式的语法12345(形参列表) -&gt; &#123; 方法体&#125; 例： 123456789101112131415161718List&lt;Integer&gt; list = Arrays.asList(100,200,350,300);// 对其进行排序// 法一Collections.sort(list);// 法二：匿名内部类Collections.sort(list, new Comparator&lt;Integer&gt;()&#123; @Override public int compare(Integer o1, Integer o2)&#123; return o2-o1; &#125;&#125;) // 法三：Lambda表达式Collections.sort(list,(Integer o1, Integer o2) -&gt; &#123;return b-a;&#125;)// 或者Comparator&lt;Integer&gt; comparator = (Integer a, Integer b) -&gt; &#123;return b-a&#125;;Collections.sort(list,comparator); Lambda 表达式的语法精简四种情况： 形参类型可以省略，如果需要省略，则每个形参的类型都要省略。 如果形参列表只有一个形参，那么形参类型和小括号都可以省略。 如果方法体重只有一行语句，那么方法体的大括号也可以省略。 如果方法体中只有一条return语句，那么大括号可以省略，且必须去掉return关键字。 四个基本的函数式接口 名字 接口名 对应的抽象方法 消费 Consumer void accept(T t); 生产 Supplier T get(); 转换 Function&lt;T, R&gt; R apply(T t); 判断 Predicate boolean test(T t); Lambda表达式的方法引用（简化Lambda表达式）方法引用的概述我们在使用Lambda表达式的时候，如果Lambda表达式的方法体中除了调用现有方法之外什么都不做，满足这样的条件就有机会使用方法引用来实现。在以下的代码中，在重写的apply()方法中仅仅只调用了现有Math类round()方法，也就意味着Lambda表达式中仅仅只调用了现有Math类round()方法，那么该Lambda表达式就可以升级为方法引用，案例如下： 1234567891011121314151617// 需求：实现小数取整的操作// 方式一：使用匿名对象来实现Function&lt;Double, Long&gt; function1 = new Function&lt;Double, Long&gt;() &#123; @Override public Long apply(Double aDouble) &#123; return Math.round(aDouble); &#125;&#125;;System.out.println(function1.apply(3.14));// 方式二：使用Lambda表达式来实现Function&lt;Double, Long&gt; function2 = aDouble -&gt; Math.round(aDouble);System.out.println(function2.apply(3.14));// 方式三：使用方法引用来实现Function&lt;Double, Long&gt; function3 = Math :: round;System.out.println(function3.apply(3.14)); 对于方法引用，我们可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。在Lambda表达式的方法引用中，主要有实例方法引用、静态方法引用、特殊方法引用和构造方法引用、数组引用这五种情况，接下来我们就对这五种情况进行讲解。 实例方法引用语法：对象 :: 实例方法特点：在Lambda表达式的方法体中，通过“对象”来调用指定的某个“实例方法”。要求：函数式接口中抽象方法的返回值类型和形参列表 与 内部通过对象调用某个实例方法的返回值类型和形参列表 保持一致。【示例】实例化Consumer接口的实现类对象，并在重写的accept()方法中输出形参的值 12345678910111213141516// 方式一：使用匿名内部类来实现Consumer&lt;String&gt; consumer1 = new Consumer&lt;String&gt;() &#123; @Override public void accept(String str) &#123; System.out.println(str); &#125;&#125;;consumer1.accept(&quot;hello world&quot;);// 方式二：使用Lambda表达式来实现Consumer&lt;String&gt; consumer2 = str -&gt; System.out.println(str);consumer2.accept(&quot;hello world&quot;);// 方式三：使用方法引用来实现Consumer&lt;String&gt; consumer3 = System.out :: println;consumer3.accept(&quot;hello world&quot;); 【示例】实例化Supplier接口的实现类对象，并在重写方法中返回Teacher对象的姓名 1234567891011121314151617Teacher teacher = new Teacher(&quot;ande&quot;, 18);// 方式一：使用匿名内部类来实现Supplier&lt;String&gt; supplier1 = new Supplier&lt;String&gt;() &#123; @Override public String get() &#123; return teacher.getName(); &#125;&#125;;System.out.println(supplier1.get());// 方式二：使用Lambda表达式来实现Supplier&lt;String&gt; supplier2 = () -&gt; teacher.getName();System.out.println(supplier2.get());// 方式三：使用方法引用来实现Supplier&lt;String&gt; supplier3 = teacher :: getName;System.out.println(supplier3.get()); 静态方法引用语法：类 :: 静态方法特点：在Lambda表达式的方法体中，通过“类名”来调用指定的某个“静态方法”。要求：函数式接口中抽象方法的返回值类型和形参列表 与 内部通过类名调用某个静态方法的返回值类型和形参列表保持一致。 【示例】实例化Function接口的实现类对象，并在重写的方法中返回小数取整的结果 12345678910111213141516// 方式一：使用匿名内部类来实现Function&lt;Double, Long&gt; function1 = new Function&lt;Double, Long&gt;() &#123; @Override public Long apply(Double aDouble) &#123; return Math.round(aDouble); &#125;&#125;;System.out.println(function1.apply(3.14));// 方式二：使用Lambda表达式来实现Function&lt;Double, Long&gt; function2 = aDouble -&gt; Math.round(aDouble);System.out.println(function2.apply(3.14));// 方式三：使用方法引用来实现Function&lt;Double, Long&gt; function3 = Math :: round;System.out.println(function3.apply(3.14)); 特殊方法引用语法：类名 :: 实例方法特点：在Lambda表达式的方法体中，通过方法的第一个形参来调用指定的某个“实例方法”。要求：把函数式接口中抽象方法的第一个形参作为方法的调用者对象，并且从第二个形参开始（或无参）可以对应到被调用实例方法的参数列表中，并且返回值类型保持一致。【示例】使用Comparator比较器，来判断两个小数的大小 12345678910111213141516// 方式一：使用匿名内部类来实现Comparator&lt;Double&gt; comparator1 = new Comparator&lt;Double&gt;() &#123; @Override public int compare(Double o1, Double o2) &#123; return o1.compareTo(o2); &#125;&#125;;System.out.println(comparator1.compare(10.0, 20.0));// 方式二：使用Lambda表达式来实现Comparator&lt;Double&gt; comparator2 = (o1, o2) -&gt; o1.compareTo(o2);System.out.println(comparator2.compare(10.0, 20.0));// 方式三：使用方法引用来实现Comparator&lt;Double&gt; comparator3 = Double :: compareTo;System.out.println(comparator3.compare(10.0, 20.0)); 需求：实例化Function接口的实现类对象，然后获得传入Teacher对象的姓名。 1234567891011121314151617// 方式一：使用匿名内部类来实现Teacher teacher = new Teacher(&quot;ande&quot;, 18);Function&lt;Teacher, String&gt; function1 = new Function&lt;Teacher, String&gt;() &#123; @Override public String apply(Teacher teacher) &#123; return teacher.getName(); &#125;&#125;;System.out.println(function1.apply(teacher));// 方式二：使用Lambda表达式来实现Function&lt;Teacher, String&gt; function2 = e -&gt; e.getName();System.out.println(function2.apply(teacher));// 方式三：使用方法引用来实现Function&lt;Teacher, String &gt; function3 = Teacher :: getName;System.out.println(function3.apply(teacher)); 构造方法引用语法：类名 :: new特点：在Lambda表达式的方法体中，返回指定“类名”来创建出来的对象。要求：创建对象所调用构造方法形参列表 和 函数式接口中的方法的形参列表 保持一致，并且方法的返回值类型和创建对象的类型保持一致。【示例】实例化Supplier接口的实现类对象，然后调用重写方法返回Teacher对象 1234567891011121314151617// 方式一：使用匿名内部类来实现Supplier&lt;Teacher&gt; supplier1 = new Supplier&lt;Teacher&gt;() &#123; @Override public Teacher get() &#123; return new Teacher(); &#125;&#125;;System.out.println(supplier1.get());// 方式二：使用Lambda表达式来实现Supplier&lt;Teacher&gt; supplier2 = () -&gt; new Teacher();System.out.println(supplier2.get());// 方式二：使用构造方法引用来实现// 注意：根据重写方法的形参列表，那么此处调用了Teacher类的无参构造方法Supplier&lt;Teacher&gt; supplier3 = Teacher :: new;System.out.println(supplier3.get()); 【示例】实例化Function接口的实现类对象，然后调用重写方法返回Teacher对象 1234567891011121314151617// 方式一：使用匿名内部类来实现Function&lt;String, Teacher&gt; function1 = new Function&lt;String, Teacher&gt;() &#123; @Override public Teacher apply(String name) &#123; return new Teacher(name); &#125;&#125;;System.out.println(function1.apply(&quot;ande&quot;));// 方式二：使用Lambda表达式来实现Function&lt;String, Teacher&gt; function2 = name -&gt; new Teacher(name);System.out.println(function2.apply(&quot;ande&quot;));// 方式二：使用构造方法引用来实现// 注意：根据重写方法的形参列表，那么此处调用了Teacher类name参数的构造方法Function&lt;String, Teacher&gt; function3 = Teacher :: new;System.out.println(function3.apply(&quot;ande&quot;)); 数组引用语法：数组类型 :: new特点：在Lambda表达式的方法体中，创建并返回指定类型的“数组”。要求：重写的方法有且只有一个整数型的参数，并且该参数就是用于设置数组的空间长度，并且重写方法的返回值类型和创建数组的类型保持一致。【示例】实例化Function接口的实现类对象，并在重写方法中返回指定长度的int类型数组 12345678910111213141516// 方式一：使用匿名内部类来实Function&lt;Integer, int[]&gt; function1 = new Function&lt;Integer, int[]&gt;() &#123; @Override public int[] apply(Integer integer) &#123; return new int[integer]; &#125;&#125;;System.out.println(Arrays.toString(function1.apply(10)));// 方式二：使用Lambda表达式来实现Function&lt;Integer, int[]&gt; function2 = num -&gt; new int[num];System.out.println(Arrays.toString(function2.apply(20)));// 方式三：使用方法引用来实现Function&lt;Integer, int[]&gt; function3 = int[] :: new;System.out.println(Arrays.toString(function3.apply(30))); Lambda在集合当中的使用为了能够让Lambda和Java的集合类集更好的一起使用，集合当中也新增了部分方法，以便与Lambda表达式对接，要用Lambda操作集合就一定要看懂源码。 forEach()方法在Collection集合和Map集合中，都提供了forEach()方法用于遍历集合。在Collection集合中，提供的forEach()方法的形参为Consumer接口（消费型接口），通过该方法再配合Lambda表达式就可以遍历List和Set集合中的元素。【示例】遍历List集合中的元素 123456789101112131415161718List&lt;Integer&gt; list = Arrays.asList(11, 22, 33, 44, 55);// 方式一：使用匿名内部类来实现list.forEach(new Consumer&lt;Integer&gt;() &#123; /** * 获得遍历出来的元素 * @param element 遍历出来的元素 */ @Override public void accept(Integer element) &#123; System.out.println(element); &#125;&#125;);// 方式二：使用Lambda表达式来实现list.forEach(element -&gt; System.out.println(element));// 方式三：使用方法引用来实现list.forEach(System.out :: println); 【示例】遍历Set集合中的元素 123456789101112131415161718List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(list);// 方式一：使用匿名内部类来实现hashSet.forEach(new Consumer&lt;String&gt;() &#123; /** * 获得遍历出来的元素 * @param element 遍历出来的元素 */ @Override public void accept(String element) &#123; System.out.println(element); &#125;&#125;);// 方式二：使用Lambda表达式来实现hashSet.forEach(element -&gt; System.out.println(element));// 方式三：使用方法引用来实现hashSet.forEach(System.out :: println); 在Map集合中，提供的forEach()方法的形参为BiConsumer接口，而BiConsumer接口属于两个参数的消费型接口，通过该方法再配合Lambda表达式就可以遍历Map集合中的元素。【示例】遍历Map集合中的元素 12345678910111213141516171819// 实例化Map集合并添加键值对HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(&quot;张三&quot;, &quot;成都&quot;);map.put(&quot;李四&quot;, &quot;重庆&quot;);map.put(&quot;王五&quot;, &quot;西安&quot;);// 方式一：使用匿名内部类来实现map.forEach(new BiConsumer&lt;String, String&gt;() &#123; /** * 获得遍历出来的key和value * @param key 键 * @param value 值 */ @Override public void accept(String key, String value) &#123; System.out.println(&quot;key：&quot; + key + &quot;，value：&quot; + value); &#125;&#125;);// 方式二：使用Lambda表达式来实现map.forEach((k, v) -&gt; System.out.println(&quot;key：&quot; + k + &quot;，value：&quot; + v)); removeIf()方法在Collection集合中，提供的removeIf()方法的形参为Predicate接口（判断型接口），通过该方法再配合Lambda表达式就可以遍历List和Set集合中的元素。【示例】删除List集合中的某个元素 12345678910111213141516171819// 创建List集合并添加元素List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;));// 方式一：使用匿名内部类来实现list.removeIf(new Predicate&lt;String&gt;() &#123; /** * 删除指定的某个元素 * @param element 用于保存遍历出来的某个元素 * @return 返回true，代表删除；返回false，代表不删除 */ @Override public boolean test(String element) &#123; return &quot;bb&quot;.equals(element); &#125;&#125;);System.out.println(list); // 输出：[aa, cc, dd]// 方式二：使用Lambda表达式来实现list.removeIf(&quot;cc&quot; :: equals);System.out.println(list); // 输出：[aa, dd] 【示例】删除Set集合中的某个元素 12345678910111213141516171819List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(list);// 方式一：使用匿名内部类来实现hashSet.removeIf(new Predicate&lt;String&gt;() &#123; /** * 删除指定的某个元素 * @param element 用于保存遍历出来的某个元素 * @return 返回true，代表删除；返回false，代表不删除 */ @Override public boolean test(String element) &#123; return &quot;bb&quot;.equals(element); &#125;&#125;);System.out.println(hashSet); // 输出：[aa, cc, dd]// 方式二：使用Lambda表达式来实现hashSet.removeIf(&quot;cc&quot; :: equals);System.out.println(hashSet); // 输出：[aa, dd]","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://example.com/tags/javase/"}]},{"title":"javase 面向对象","slug":"javase 面向对象","date":"2025-04-12T16:00:00.000Z","updated":"2025-05-08T06:09:34.828Z","comments":true,"path":"2025/04/13/javase 面向对象/","permalink":"http://example.com/2025/04/13/javase%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"三、面向对象面向对象概述面向过程关注点在实现功能的步骤上 面向对象关注点在实现功能需要哪些对象的参与，可以把问题拆分成几个对象，对象协作起来解决问题。 面向对象开发方式耦合度低，扩展能力强。 面向对象的三大特征 封装 继承 多态 对象的创建1234[修饰符列表] class 类名&#123; //属性 /&#125; JVM内存分析元空间 metaspace元空间中存储的是类的元信息，字节码等。 元空间是java8之后引入的。是JVM规范中方法区的实现。 方法区：JVM规范 的叫法，各个厂商根据这个规范去实现具体的java虚拟机。 总结：方法区是规范，元空间是实现。java8之前使用永久代实现的。 堆内存所有new的对象，都存储在堆内存中。 栈方法被调用时会给该方法分配空间，在VM Stack中压栈。 JVM有自动垃圾回收机制，主要针对堆区。 实例变量和实例方法通常描述一个对象的行为动作时，不加static——称为实例方法 实例方法不能通过类访问，必须通过对象访问。 方法调用传递引用数据类型传的是地址！！！ ！this关键字 this本质是一个引用 this中保存的是当前对象的内存地址 this.大部分情况可以省略，默认是访问当前的类的实例变量。当需要区分局部变量和实例变量时，不能省略。 this存储在栈帧的局部变量表的第0个槽位上。 this不能出现在静态方法中 this 实参 通过这种语法，可以在构造方法中调用本类的其他构造方法 作用：代码复用 this实参只能出现在构造方法的第一行！！！ 封装通过限制外部对对象内部的直接访问和修改，保证数据的安全性，并提高了代码的可维护性和可复用性。 属性私有化：使用private修饰 对外提供接口 *快速创建getter，setter方法 alt + insert 选择getter and setter 选择要创建的内容 构造器（构造方法） 对象的创建 对象的初始化（默认有super();，先对父类的变量进行初始化） 这两个阶段不能颠倒，也不能分割。 构造方法名需与类名一致。 不需要写return，不需要写返回值类型。 如果没有显式定义构造方法，系统会提供一个无参数的构造方法，并且会给属性赋默认值。 定义有参数的构造方法后，可以手动再写一个无参数的构造方法。【方法重载】 如何调用构造方法new 构造方法名（实参） 写了构造方法，为什么还要单独写set方法？构造方法是对象第一次创建时用于初始化的。set方法可以在后期修改属性值。 构造代码块语法格式123&#123; &#125; //直接写在class体里面 //每次new都会运行一次构造代码块中的内容，运行前对象已经创建好，并且完成了初始值的赋值。 //！！！构造代码块是在构造方法执行之前执行的！！！ 作用如果所有的构造方法在最开始的时候有相同的一部分代码，可以将公共的代码放在构造代码块中，达到复用的效果。 流程 new的时候在堆内存中开辟空间，给所有属性赋默认值 执行构造代码块进行初始化 执行构造方法体进行初始化 构造方法执行结束，对象初始化完毕 static 关键字 static修饰静态变量，当所有对象的某个属性的值是相同的，建议将该属性定义为静态变量，来节省内存。 JDK8后，静态变量存储在堆内存中。在类加载时进行初始化。 静态变量可以通过“引用.”来访问，实际运行时和对象无关（不会出现空指针异常），但不建议。会让程序员造成误解。 静态代码块 语法格式： static{ } 在类加载的时候执行，并且只执行一次。 可以有多个静态代码块，自上而下依次执行。 作用：在类加载的时候运行一段代码，可能是进行一些准备工作。 java虚拟机规范运行时数据区的六个内容 PC Register, PC计数器：是一块较小的内存空间，用于存储下一条要执行的字节码指令地址。 java Virtual Machine Stacks, java虚拟机栈：用于存储栈帧，栈帧存储局部变量表、操作数栈、动态链接、方法出口等信息。 Heap, 堆：java虚拟机所管理的最大的一块内存，用于存储java对象实例以及数组。堆是垃圾回收器主要使用区域。 Method Area, 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量（hotspot把这个内容存到堆里去了）、即时编译器编译后的代码等数据。 Run-Time Constant Pool, 常量池：方法区的一部分，用于存放编译期生成的各种字面量与符号引用（类名、方法名、属性名）。 method stacks, 本地方法栈：在本地方法的执行过程中，会使用本地方法栈。 GoF设计模式什么是设计模式可以重复利用的一套方案 GoF设计模式的分类 创建型：主要解决对象的创建问题 结构型：通过设计和构建对象之间的关系，以达到更好的重用性、扩展性和灵活性 行为型：主要用于处理对象之间的算法和责任分配 单例模式属于创造型设计模式，确保一个类只有一个实例，并提供一个全局访问点来访问该实例。 饿汉式单例模式类加载时对象就创建好了，不管这个对象用还是不用 构造方法私有化 定义一个静态变量，在类加载的时候初始化静态变量（只初始化一次） 对外提供一个公开的静态方法，用这个方法获取单个实例 懒汉式单例模式用到这个对象的时候再创建对象，别在类加载的时候创建对象 构造方法私有化 提供一个静态变量，但这个变量的值为NULL 对外提供一个静态方法，通过这个方法可以获取对象 继承作用 代码复用 有了继承，才有了方法覆盖和多态机制 实现123[修饰符列表] class 类名 extends 父类名 &#123;&#125; 特性 只支持单继承，一个类只能继承一个类 不支持多继承，但支持多重继承（多层继承） 子类继承父类的除私有的、构造方法以外的所有内容 一个类没有显式继承任何类时，默认继承java.lang.Object类 方法覆盖（重写） overwrite什么时候使用？当从父类继承过来的方法，无法满足子类的业务需求时。 特性 当子类将父类方法覆盖之后，将来子类对象调用方法的时候，一定会执行重写之后的方法。 注解：@override，在方法前写这个注解，在编译阶段会检查这个方法是否重写了父类的方法。 如果返回值类型是引用数据类型，那么这个返回值类型可以是原类型的子类型。 访问权限不能变低，可以变高。public最高 抛出异常不能变多，可以变少。 方法覆盖针对的是实例方法，和静态方法无关。 多态向上转型和向下转型的基本概念引用数据类型进行类型转换。 向上转型：子–&gt;父 （可以等同看做自动类型转换）父类型引用指向子类型对象，这是多态机制最核心的语法。 如果父类中没有某个方法，而子类中有，那么就需要向下转型。 向下转型：父–&gt;子（可以等同看做强制类型转换）当调用的方法是子类特有的方法，需要向下转型，进行强制转换。 如果两个子类不是同一类，会出现ClassCastException异常 如何避免ClassCastException异常？使用运算符 instanceof 语法格式： 引用 instanceof 类型 在进行向下转型之前，用if语句判断一下是否是要向下转型的类型，不是就不要转换了。 静态方法和多态没有关系，因此静态方法和方法覆盖无关系。软件开发七大原则 多态在开发中的作用 降低程序耦合度，提高程序的扩展力 尽量使用多态，面向抽象编程，不要面向具体编程。 实例变量无法覆盖，根据声明的类型进行赋值抽象类和抽象方法123456public abstract class Name&#123; //父类：所有子类的公共属性+公共方法的集合体 public abstract void functionName();&#125;// 抽象方法必须在抽象类中//public 和 abstract的顺序没有要求// ！！！继承该抽象类的子类必须覆盖这个抽象方法 存在的意义：强制子类重写抽象方法，编译器会报错。如果类中有一些方法无法实现或者没有意义，就可以将方法定义为抽象方法。 abstract 关键字不能和private、final、static关键字共存 super 关键字 当子类和父类有名称相同的属性&#x2F;方法，此时调用父类中继承而来的属性&#x2F;方法需要使用super.属性/方法 super不能在静态方法中使用 this可以单独输出（本质是引用，内容是地址），super不能单独输出（本质不是引用，只是代表了对象父类型特征的那部分） 如何在子类中在使用父类方法的基础上进行方法覆盖？按正常方法覆盖，但是方法体中先写一个super.方法名()调用一下父类的方法，再写需要添加的内容。 在子类中调用父类的构造方法在子类的构造方法中使用super(参数); 通过此方法可以给继承过来的父类特征进行初始化，达到代码复用。 final 关键字 final修饰的类不可以被继承 final修饰的方法无法被覆盖 final修饰的变量一旦赋值，不能重新赋值 final修饰的实例变量必须在构造方法执行完之前手动赋值。这种变量一般和static联用，得到常量（单词全部大写，每个单词用_连接） final修饰的引用一旦指向某个对象，不能再指向其他对象。但指向的对象内部的数据可以修改。 接口要想解耦合，就是多态+接口 接口在Java中表示一种规范或契约，它定义了一组抽象方法和常量，用来描述一些实现这个接口的类应该具有哪些行为和属性。接口和类一样，也是一种引用数据类型。 分类 普通接口 起标志的作用 如何定义[修饰符列表] interface 接口名{} 接口是完全抽象的抽象类是半抽象的（可以定义抽象的方法，也可以定义非抽象的方法） 接口是完全抽象的，没有构造方法，也无法实例化。 JDK8之前的语法规则接口中只能定义：常量+抽象方法 接口中的常量的static final可以省略，抽象方法的abstract可以省略。 所有方法和变量都是public的 接口与接口之间可以多继承类和接口的关系——实现这里的实现可以等同看做继承。（接口是父，类是子） 这个说法仅供理解 使用implements关键字进行接口的实现。 一个非抽象的类实现接口必须将接口中所有抽象方法全部实现（否则编译器报错）一个类可以实现多个接口class 类名 implements 接口A,接口B&#123; &#125; 使用了接口之后，为了降低程序的耦合度，一定要让接口和多态联合起来使用父类型的引用指向子类型的对象。 JDK8后，接口中允许出现默认方法和静态方法默认方法引入默认方法是为了演变接口演变问题。 接口可以定义抽象方法，但不能实现这些方法。所有实现接口的类都必须实现这些抽象方法，这会导致接口升级问题——当我们向接口添加或删除一个抽象方法时，这会破坏该接口的所有实现，所有与它有关的类都需要修改代码。 覆盖会使用静态方法只能通过接口名去调用 通常将接口作为工具使用时，会使用静态方法 JDK9之后允许定义私有实例方法（为默认方法服务）和私有静态方法（为静态方法服务）私有静态方法便于将静态方法拆分为多个方法，免得一个方法中有几千行。便于代码复用 所有接口隐式继承object，因此接口也可以调用object类的相关方法接口的作用 调用者和实现者通过接口达到了解耦合。调用者不需要关心具体的实现者，实现者也不许要关心具体的调用者，双方只要遵循规范，面向接口进行开发。 面向抽象编程，面向接口编程，可以降低程序的耦合度，提高程序的扩展力。 接口和抽象类的选择 抽象类主要用于公共代码的提取。多个类有共同的属性和方法时，提取出一个父类。 接口主要用于功能的扩展。有一些类需要实现某个方法，另一些类不需要，那就将这个方法定义到接口中，需要这个方法的就去实现这个接口。 一个类单继承父类，多实现接口extends在前，implements在后 UML 统一建模语言 类之间的六种关系 聚合关系：整体和部分各自有自己的生命周期 组合关系：整体和部分有相同的生命周期。eg.人死了，四肢也没了。 三个比较重要的关系l 其他的关系聚合关系 组合关系 依赖关系 访问控制权限 类的访问权限只有两种：public和缺省 访问权限控制符不能修饰局部变量 Object类toString ：将java对象转换成字符串型但默认的方法输出的是地址，因此需要自己覆盖方法。 调用print()打印类时，会自动调用类的toString()（和自己调用toString方法有区别，因为它会先判断是否是NULL，再使用toString） equal ：判断两个对象是否相等默认方法是判断地址是否相等，也需要自己重写方法。 hashCode ：返回一个对象的哈希值通常用来在哈希表中查找该对象的键值。 默认实现是根据对象的内存地址生成一个哈希码（将对象的内存地址转换为整数作为哈希值）。 该方法是为了HashMap、Hashtable、HashSet等集合类进行优化而设置的，便于更快地查找和存储对象。 clone 实现对象拷贝。通常在开发中需要保护原对象数据结构，于是克隆出一份新对象，对新对象进行操作。 默认实现：是protected类型，专门给子类使用的。（本地方法，调用C++程序实现的）【浅克隆】 怎么解决克隆方法调用问题？—— 在子类中重写clone方法，并且为了保证clone方法在任何位置都可以调用，建议将其修饰符修改为public 凡是参加克隆的对象，必须实现一个标志接口：java.lang.Cloneable 需要重写变成【深克隆】 就是先完成浅克隆，再单独克隆其中包含的类，然后赋值给克隆出来的东西。 eg. 内部类什么是内部类定义在一个类中的类 什么时候使用内部类 四种内部类 匿名内部类：","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://example.com/tags/javase/"}]},{"title":"javase 引入、基本语法","slug":"javase 引入、基本语法","date":"2025-04-10T16:00:00.000Z","updated":"2025-05-18T11:12:16.696Z","comments":true,"path":"2025/04/11/javase 引入、基本语法/","permalink":"http://example.com/2025/04/11/javase%20%E5%BC%95%E5%85%A5%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一、引入JAVA语言特性简单性：不像c++支持多继承，无指针。底层由c++实现。 面向对象 可移植性：一次编译，到处运行。在win上编译后可以在Linux上运行。 ​ Java程序在Java虚拟机上运行，JVM : Java virtual machine ​ JDK ：Java开发工具包 多线程 健壮性：产生的垃圾是自动回收的，不需要像c++一样手动回收内存空间。 安全性 JAVA的加载与执行 注：.class文件是字节码文件，不是纯粹的二进制文件，否则操作系统就可以直接运行了。 编译：使用JDK中自带的javac.exe进行编译使用方法： 1javac java源文件的路径 一个源文件可能生成多个.class文件 .class文件生成后，删除.java文件不影响程序的运行，但最好不要删掉，以防后面要修改。 运行：使用java.exe运行使用方法： 磁盘上有一个A.class 1java A JVM会启动类加载器ClassLoader ClassLoader会去硬盘上根据classpath搜索A.class文件，找到该文件则将该字节码文件装载到JVM中 JVM将A.class文件解释成二进制数据 操作系统执行二进制文件，和底层硬件平台交互 三种注释方式123456789101112// 单行注释/* 多行注释 多行注释*//*** 文档注释* 编写在这的信息可以被javadoc命令解析提取并生成到帮助文档中**/ 第一个程序 public class 和class注：公共类与文件名强制绑定 文件名应该改为HelloWorld.java 一个class文件最多只能有一个公共类，也可以没有。 每个类中都可以编写入口main方法，想执行那个就用 java 类名 实际开发中对于一个软件来说一般入口只有1个 二、基本语法标识符 字母（任何一个国家的语言）、数字、下划线、美元符号组成，不能包含其他符号。 数字不能开头 命名规范 加号运算符 求和 字符串拼接（加号两边有任意一边是字符串类型时进行，结果还是一个字符串） 变量数据类型 int 整型 double 浮点型 String 字符串型 …… 变量类型在方法体中定义的变量，是局部变量。 在类体中定义的变量，是成员变量，成员变量又分为静态变量、实例变量。 成员变量如果没有手动赋值，系统会自动赋默认值。 整型自动类型转换如果在整型类型后添加 L 或者 l ，那么这个整型数据就会被当成long类型处理。建议使用L，看的比较清楚。 面试题 强制类型转换大容量无法自动转换成小容量，想让其编译通过，必须手动添加强制类型转换符。如 (int) 需记住： 当一个整型字面量没有超出某类型（byte short char）的取值范围时，可以直接赋值给该类型的变量，不需要强转。 多种数据类型混合运算时，先各自转成容量最大的，再做运算。 byte short char混合运算时，先转成int再运算。 多种数据类型混合运算时，要先转成当前最大的类型再运算 double &gt; float &gt; long &gt; int 12double i = 1; //存在自动类型转换，由整型转换为浮点型。 //如果数值不规定类型，默认为int型 浮点型数值后加F或f表示float类型，否则默认为double型 注：一旦有浮点型数据参与运算得出的结果，不要用“&#x3D;&#x3D;”和别的数字进行相等比较！！！ 一般相减然后小于一个很小的值，就认为相等。 字符型 Java中的char类型统一采用Unicode编码 不允许空字符文字 ‘’ char默认值： \\u0000 空字符（不是空格，空格是\\u0020） 布尔型long , int等类型的数值不能直接赋值给布尔型变量 进制java中规定，0开头的是八进制，0b开头的是二进制，0x开头的是十六进制 接收键盘输入12345678// 创建键盘扫描器对象java.util.Scanner s = new java.util.Scanner(System.in);//获取输入内容int num1 = s.nextInt();double num2 = s.nextDouble();String str = s.next(); //获取第一个空格前的内容String str = s.nextLine(); // 获取一行 注：以上的代码存在问题，nextInt()，nextDouble()，next()在输入时肯定会输入换行符\\r，但是这三个扫描器都不会吸收这个换行符，导致到nextLine()时，直接吸收换行符就完成运行了。 或者在最开始 import scanner对应的包 123456789101112import java.util.Scanner;public class Scan1&#123; public static void main(String[] args)&#123; Scanner s = new Scanner(System.in); int num1 = s.nextInt(); double num2 = s.nextDouble(); String str = s.next(); //获取第一个空格前的内容 String str = s.nextLine(); // 获取一行 &#125;&#125; 逻辑运算符&amp; 逻辑与 |逻辑或 &amp;&amp; 逻辑与（左边是false就短路，不运行右边的内容） ||逻辑或（左边是true就短路，不运行右边的内容） 按位运算符操作数必须是整数 移位运算符 经典面试题：怎么让2快速变成8？左移2位 &gt;&gt;算数右移 &gt;&gt;&gt;逻辑右移 按位或应用：设置某一位的值为1。 如a | (1&lt;&lt;n) 按位异或自反性：a^b^b = a 应用：简单的加密、解密 按位取反应用：对某一位清零 赋值运算符对于扩展的赋值运算符，不会改变变量的数据类型。 自带强制类型转换，把运算符右边的内容强制转换为左边的数据类型。 控制语句字符串的比较不能使用==，因为String是引用数据类型，==此时比较的是两个变量是否指向同一个引用对象，比较的是地址。 比较两个字符串是否相等123String s = &quot;admin&quot;;String t = &quot;adm&quot;;System.out.print(s.equals(t)); switch 语句switch(x){ } 这个x可以是int（byte short char 放进去也可以自动类型转换），字符串，枚举类型。 Java 12 新特性 不需要自己写break了。 方法（C语言中的函数）方法的调用当这个方法修饰符列表有static关键字时，调用的格式为： 类名.方法名（实参列表） 什么时候调用时可以省略类名.？调用者和被调用者在同一个类时，可以省略。 方法重载 overload什么情况构成了方法重载？ 在同一个类中 方法名相同 形参列表不同：类型&#x2F;顺序&#x2F;个数 不同 哪个阶段的机制？编译阶段的。 编译阶段已经完成了方法的绑定，即确定要调用哪个方法了。 什么情况下考虑使用方法重载？功能类似，形参类型不同。 递归递归调用很耗资源能用循环就用循环。在实际开发中，有时候即使结束条件存在且合法，也可能出现栈溢出——递归太深了，栈内存不够导致。 package作用便于文件的管理，不同的类放在不同的包下，好维护。 定义包在代码第一行添加语句 package 包名 包名规范公司域名倒序+项目名+模块名+功能名 所有的包名都是小写 如何带包编译？1javac -d 编译后存放的目录 java源文件路径 有了包机制后的类名包名.类名，在同一个包内不需要写包名，直接写类名即可。 import使用不在同一个包的方法，需要import包 import支持静态导入（最好别用，可读性差）12345import static java.lang.System.*// 下面可以直接用输出的方法。out.print(&quot; &quot;);// 不使用静态导入时： System.out.print(&quot; &quot;) intellij idea 的快捷键 多行注释ctrl shift / 复制一行ctrl D 快速生成创建对象语句类名.new.var getter and setter alt + insert 选择getter and setter 选择要创建的内容 移动一行代码alt shift 上键/下键 快速向下转型变量名.castvar 快速查看方法的参数ctrl + p 返回上一步ctrl + alt + 左方向键 下一步ctrl + alt + 右方向键 代码格式化ctrl + alt + L 查看继承结构ctrl + H 自动代码包裹ctrl + alt + t","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://example.com/tags/javase/"}]},{"title":"C和C++中的易错点","slug":"C和C++中的易错点","date":"2025-03-04T16:00:00.000Z","updated":"2025-03-05T14:19:53.345Z","comments":true,"path":"2025/03/05/C和C++中的易错点/","permalink":"http://example.com/2025/03/05/C%E5%92%8CC++%E4%B8%AD%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/","excerpt":"","text":"一、”.”和”-&gt;”的区别 对于结构体指针，应该使用”-&gt;” 对于结构体，应该使用”.”‘ 举例： 1234567891011121314struct Student &#123; int age; char name[20];&#125;;// 定义结构体变量struct Student s;s.age = 20; // 直接通过变量访问成员strcpy(s.name, &quot;Alice&quot;);struct Student *ptr;ptr = &amp;s; // ptr指向结构体变量sptr-&gt;age = 21; // 通过指针访问成员// 等价于 (*ptr).age = 21;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Swin-Unet 复现记录（记第一次复现）","slug":"Swin-Unet-复现记录（记第一次复现）","date":"2025-02-28T06:44:00.000Z","updated":"2025-03-01T07:19:30.381Z","comments":true,"path":"2025/02/28/Swin-Unet-复现记录（记第一次复现）/","permalink":"http://example.com/2025/02/28/Swin-Unet-%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95%EF%BC%88%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%A4%8D%E7%8E%B0%EF%BC%89/","excerpt":"","text":"一、train中遇到的问题（一）python、pytorch、cuda版本不对应swin-unet官方仓库上写的使用的是python3.7运行的代码，所以我一开始把环境全部朝python3.7去配置。却一直报错。 经过一番搜索后，发现python3.7对应的环境无法在4060laptop上运行。 在多次尝试不同的环境，并结合b站复现别的论文的视频，选择将python版本改为3.8。 1、新建独立环境12conda create -n py.8 python=3.8 # 明确指定Python 3.8conda activate py.8 2、使用pip绕过conda依赖限制1pip install torch==2.5.1 torchvision==0.20.1 torchaudio==2.5.1 --index-url https://download.pytorch.org/whl/cu118 （二）一堆cuda的报错 根据github中issue的讨论，获得修改方法，train.py中的num_classes和n_class都要设置为9 https://github.com/HuCaoFighting/Swin-Unet/issues/121 （三）安装完requirements.txt中的库后仍然缺少部分库根据搜索安装即可 （四）训练集、验证集地址、名称问题对trainer.py中的相关代码进行如下修改 （五）windows中不能使用多线程二、test中遇到的问题（一）找不到best_model.pth.txt文件 （二）文件地址错乱（一）（二）的解决方法相同： 代码中的volum_path统一改为root_path，然后根据报错提示修改对应的地址。 （三）维度出现问题修改utils.py的代码 原代码： 12image, label = image.squeeze(0).cpu().detach().numpy().squeeze(0), label.squeeze(0).cpu().detach().numpy().squeeze(0) 修改后： 12345678910image = image.cpu().detach().numpy() label = label.cpu().detach().numpy() if image.shape[0] == 1: image = image.squeeze(0) if label.shape[0] == 1: label = label.squeeze(0) #image, label = image.squeeze(0).cpu().detach().numpy().squeeze(0), label.squeeze(0).cpu().detach().numpy().squeeze(0) 参考： https://juejin.cn/post/7431728417744175154 三、test结果第六类不知为啥数值都是0… 四、总结这是我第一次尝试复现代码，用时一天半终于把环境配好，第一次成功运行代码。 用时6:16:35训练完成！！！","categories":[],"tags":[{"name":"Swin-Unet","slug":"Swin-Unet","permalink":"http://example.com/tags/Swin-Unet/"},{"name":"pytorch","slug":"pytorch","permalink":"http://example.com/tags/pytorch/"}]},{"title":"动手学深度学习 2","slug":"动手学深度学习 2","date":"2025-01-24T16:00:00.000Z","updated":"2025-02-17T12:59:54.288Z","comments":true,"path":"2025/01/25/动手学深度学习 2/","permalink":"http://example.com/2025/01/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202/","excerpt":"","text":"一、卷积卷积有什么用？ 通过卷积核的不同设置，使得每个输出通道可以识别特定的模式，比如识别边缘、锐化、模糊等操作。 核的参数怎么得到的？ 学出来的，不是自己设置的。 卷积尺寸公式： 输出尺寸*=*[输入尺寸-kernel-size+2*padding+stride]/stride 填充在输入周围添加行&#x2F;列，来控制输出形状的减少量 步幅每次滑动kernal窗口时的行&#x2F;列的步长，可以成倍的减少输出形状 注意： 1、第一个公式里的ph是要上下都加了行，所以要乘以二！！！ 2、padding通常设置为k-1 （核-1） 问题1、为什么通常用3x3或者5x5的卷积核呢？他们的视野不是很小吗？（更常用3x3，计算量更小） 多加几层卷积层，最后的到的层会涵盖初始层中很大范围的内容。 多输入通道 这样只能得到单输出的通道 如何得到多输出通道？输入的三通道数据和多个卷积核进行卷积，得到多通道的输出。 co表示卷积核的个数，ci表示卷积核的维度，第0维的卷积层和第0维的输入进行计算，第1维的卷积层和第1维的输入进行计算…，然后将同一位置不同层的计算结果相加，得到这一块的输出内容，再按此方法进行卷积操作得到第一维度的输出。使用其他的卷积核进行相同操作，最后得到多输出通道。 1x1 卷积层 用于不同通道使用不同权重进行融合。 二、最大&#x2F;平均池化返回滑动窗口中的最大值&#x2F;平均值 缓解卷积层对于位置的敏感性，通常放在卷积层之后。 pytorch中，如果不设置默认：池化窗口&#x3D;步幅，就是保证窗口不重叠 为什么现在池化用的少了？ 现在通常用一个卷积层+stride减少输出 三、LeNet 如何检验层的尺寸有没有搭错： 四、AlexNet在LetNet基础上添加了一些层，效果更好 五、VGG块将AlexNet中的多个卷积层封装成一个块，使用多个VGG块构建深度卷积神经网络，效果更好。 不同的卷积块个数和超参数可以得到不同复杂度的变种。 注：在VGG中，内部卷积层的个数n，通道m是超参数。 六、NiN全连接层的问题： 卷积层后的得到第一个全连接层时的计算量会非常大且容易过拟合 NiN块一个卷积层后跟两个全连接层 为什么用的是两个1x1的卷积层？他们其实相当于没有将输入拍扁的全连接层。 NiN架构 总结Nin块使用卷积层加两个1x1卷积层，后者对每个像素增加了非线性性。 Nin用全局平均池化层来替代VGG和AlexNet中的全连接层——不容易过拟合，更少的参数个数。 七、批量归一化 Batch Normalization——加速收敛、网络训练速度 BN层一般用于深层神经网络，浅层的效果不好。 解释由于学习过程中会调整每个层的超参数，当调整前面的层时，会导致后面的层需要重新进行学习，进而导致最后得到的层很难收敛。所以学习率不能设置太高。 批量归一化将每一层的输出进行归一化，使对下一层的输出相似但不完全相同，这样后面的层就不需要改动太大。因此可以选择较大的学习率，加快了网络的训练。 后有论文指出它可能就是通过在每个小批量里加入噪音来控制模型的复杂度。 因此没必要跟丢弃法混合使用。 分布归一化放在非线性激活前面！ 需要训练的参数增加了γ和β，原来的偏置是定好的不需要学习。所以现在有三个参数需要学习。 调包实现nn.BatchNorm2d(输入的通道数) nn.BatchNorm1d(输入的通道数) 八、ResNet 不断添加层数，得到的模型一定最优吗？ 不一定。反而可能会越来越偏离最优函数。 残差块 f(x)&#x3D;x+g(x) 使得新的模型必须包含之前的模型，因此精度不可能变差。 如果g(x)没什么用，那么系统后面给它的梯度会很小，它对最后的结果影响就很小了。 同时，残差块使得很深的网络更加容易训练。 这样加法的操作使得反向传播计算梯度时，即使g(x)的偏导很小，由于是加法，也可以求出x的偏导，那么f(x)得到的梯度就不至于消失。 解决了深层网络底层比较难以训练的问题。——底层拿到的梯度一般比较小。 九、数据增强增加一个已有的数据集，使其有更多的多样性。 ​ 增加不同的背景噪音 ​ 改变图片的颜色和形状 常见增强方法翻转左右、上下翻转 但不是总是可行。比如建筑之类的翻转不太符合实际。但树叶什么的翻转没关系。 切割从图片中切割一块，然后变形到固定形状 随机高宽比（eg.[3&#x2F;4,4&#x2F;3]） 随机大小（eg.[8%,100%]） 随机位置 颜色改变色调，饱和度，明亮度（当前的情况减少50%或增加50%的范围内） 其他https://github.com/aleju/imgaug 十、微调 fine-tune微调中的权重初始化 源数据集远复杂于目标数据，通常微调的效果更好（速度更快、精度越高）。 使用更小的学习率 使用更少的数据迭代 1、重用分类器权重源数据集可能也有目标数据中的部分标号，可以使用预训练好的模型分类器中对应标号对应的向量来做初始化。 2、固定一些层 神经网络通常学习有层次的特征： 低层次的特征更加通用 高层次的特征更加与数据集有关 可以固定底部一些层的参数，不参与更新。 十一、锚框一类目标检测算法是基于锚框的 提出多个被称为锚框的区域 预测每个锚框里是否含有关注的物体 如果是，预测从这个锚框到真实边缘框的偏移 IoU 交并比 赋予锚框标号 第一步的意思就是使用锚框2去预测边缘框3。 一张图有多少个边缘框，就对应有多少个训练样本。 使用非极大值抑制（NMS）输出 每个锚框预测一个边缘框 NMS可以合并相似的预测 选中是非背景类的最大预测值 去掉其他和它IoU值大于θ的预测 重复上述过程知道所有预测要么被选中，要么被去掉 十二、物体检测算法 R-CNN兴趣区域（RoI）池化层 给定一个锚框，均匀分割成n×m块，输出每块里的最大值 不管锚框多大，总是输出nm个值 强行将图像变成大小一样的。 Fast RCNN 使用CNN对图片抽取特征 再使用RoI池化层对每个锚框生成固定长度特征 在原始图片上搜索到锚框后，把锚框按照比例映射到经过CNN层的特征层。 Faster R-CNN Mask R-CNN如果有像素级别的标号，使用FCN来利用这些信息。 总结 十三、单发多框检测 SSD生成锚框 SSD模型 十四、YOLO: you only look once在SSD的基础上进行改进，避免大量SSD重叠。 十五、语义分割语义分割可以识别并理解图像中每一个像素的内容：其语义区域的标注和预测是像素级的。 即每一个像素都有其对应的类别。 列举RGB值和类名12345678910111213#@saveVOC_COLORMAP = [[0, 0, 0], [128, 0, 0], [0, 128, 0], [128, 128, 0], [0, 0, 128], [128, 0, 128], [0, 128, 128], [128, 128, 128], [64, 0, 0], [192, 0, 0], [64, 128, 0], [192, 128, 0], [64, 0, 128], [192, 0, 128], [64, 128, 128], [192, 128, 128], [0, 64, 0], [128, 64, 0], [0, 192, 0], [128, 192, 0], [0, 64, 128]]#@saveVOC_CLASSES = [&#x27;background&#x27;, &#x27;aeroplane&#x27;, &#x27;bicycle&#x27;, &#x27;bird&#x27;, &#x27;boat&#x27;, &#x27;bottle&#x27;, &#x27;bus&#x27;, &#x27;car&#x27;, &#x27;cat&#x27;, &#x27;chair&#x27;, &#x27;cow&#x27;, &#x27;diningtable&#x27;, &#x27;dog&#x27;, &#x27;horse&#x27;, &#x27;motorbike&#x27;, &#x27;person&#x27;, &#x27;potted plant&#x27;, &#x27;sheep&#x27;, &#x27;sofa&#x27;, &#x27;train&#x27;, &#x27;tv/monitor&#x27;] 构建从RGB到VOC类别索引的映射12345678910111213141516171819#@savedef voc_colormap2label(): &quot;&quot;&quot;构建从RGB到VOC类别索引的映射&quot;&quot;&quot; colormap2label = torch.zeros(256 ** 3, dtype=torch.long) for i, colormap in enumerate(VOC_COLORMAP): colormap2label[ (colormap[0] * 256 + colormap[1]) * 256 + colormap[2]] = i # 把RGB三通道的数值当做256进制的数（因为像素最多从0-255）每个像素值算出对应10进制数存入tensor 这样可以对应到每个像素所属类别。 # i表示这个颜色对应类别的序号 return colormap2label#@savedef voc_label_indices(colormap, colormap2label): &quot;&quot;&quot;将VOC标签中的RGB值映射到它们的类别索引&quot;&quot;&quot; colormap = colormap.permute(1, 2, 0).numpy().astype(&#x27;int32&#x27;) # 将输入的彩色标签图像的维度从（通道，高度，宽度）重排为（高度，宽度，通道），然后将其转换为NumPy数组，并将数据类型转换为32位整数，以便进行后续计算。 idx = ((colormap[:, :, 0] * 256 + colormap[:, :, 1]) * 256 + colormap[:, :, 2]) # 计算RGB值对应的类别的索引 return colormap2label[idx] #返回对应类别的序号 十六、转置卷积卷积不会增大输入的高宽，通常要么不变、要么减半。 而转置卷积则可以用来增大输入的高宽。 12345678X = torch.tensor([[0.0, 1.0], [2.0, 3.0]])K = torch.tensor([[0.0, 1.0], [2.0, 3.0]])trans_conv(X, K)X, K = X.reshape(1, 1, 2, 2), K.reshape(1, 1, 2, 2)#调用api实现转置卷积tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, bias=False) #输入通道数，输出通道数，核的大小，是否有偏移tconv.weight.data = Ktconv(X) 填充、步幅和多通道转置卷积的填充（padding）是加在输出上的。 如上图的转置卷积过程，如果padding&#x3D;1，则最后的结果为4。（删除第一和最后的行和列） 对于多个输入和输出通道，转置卷积与常规卷积以相同方式运作。假设输入有$c_i$个通道，且转置卷积为每个输入通道分配了一个$k_h\\times k_w$的卷积核张量。当指定多个输出通道时，每个输出通道将有一个$c_i\\times k_h\\times k_w$的卷积核。 如果我们将$\\mathsf{X}$代入卷积层$f$来输出$\\mathsf{Y}&#x3D;f(\\mathsf{X})$，并创建一个与$f$具有相同的超参数、但输出通道数量是$\\mathsf{X}$中通道数的转置卷积层$g$，那么$g(Y)$的形状将与$\\mathsf{X}$相同。 转置卷积与卷积的转换 十七、全连接卷积神经网络 FCN用转置卷积层来替换CNN最后的全连接层，从而实现每个像素的预测 最后的通道数 &#x3D; 类别数 十八、序列模型时序模型中，当前数据和之间观察到的数据相关。 常见的两种方案 十九、注意力机制卷积、全连接、池化层都只考虑不随意线索。 注意力机制则考虑随意线索 随意线索被称之为查询（query） 每个输入是一个值（value）和不随意线索（key）的对 通过注意力池化层来有偏向性的选择某些输入 注意力机制的本质：https://www.bilibili.com/video/BV1dt4y1J7ov/?share_source=copy_web&amp;spm_id_from=333.788.comment.all.click&amp;vd_source=c675206b339487e9755eec554de241a9 非参的注意力池化层 1、一般情况 2、Nadaraya-Watson 核回归 参数化的注意力机制在之前的基础上引入可以学习的w 注意力分数 加性注意力 additive attention12345678910111213141516171819202122232425#@saveclass AdditiveAttention(nn.Module): &quot;&quot;&quot;加性注意力&quot;&quot;&quot; def __init__(self, key_size, query_size, num_hiddens, dropout, **kwargs): super(AdditiveAttention, self).__init__(**kwargs) self.W_k = nn.Linear(key_size, num_hiddens, bias=False) self.W_q = nn.Linear(query_size, num_hiddens, bias=False) self.w_v = nn.Linear(num_hiddens, 1, bias=False) self.dropout = nn.Dropout(dropout) def forward(self, queries, keys, values, valid_lens): queries, keys = self.W_q(queries), self.W_k(keys) # 在维度扩展后， # queries的形状：(batch_size，查询的个数，1，num_hidden) # key的形状：(batch_size，1，“键－值”对的个数，num_hiddens) # 使用广播方式进行求和 —— 广播规则：维度大小为1的轴会自动扩展以匹配另一张量的形状。 # 18行feature的形状：(batch_size，查询的个数，“键－值”对的个数，num_hiddens) features = queries.unsqueeze(2) + keys.unsqueeze(1) features = torch.tanh(features) # self.w_v仅有一个输出，因此从形状中移除最后那个维度。 # scores的形状：(batch_size，查询的个数，“键-值”对的个数) scores = self.w_v(features).squeeze(-1) self.attention_weights = masked_softmax(scores, valid_lens) # 注意力权重 # values的形状：(batch_size，“键－值”对的个数，值的维度) return torch.bmm(self.dropout(self.attention_weights), values) # 将注意力权重与值进行矩阵乘法 为什么要采用广播机制？通过广播机制，一次性生成所有 (query, key) 对的组合特征，避免逐对计算的低效循环。 示例说明假设： 批量大小 batch_size=2 查询数量 num_queries=3 键值对数量 num_kv_pairs=4 隐藏维度 num_hiddens=5 经过 unsqueeze 和广播后： queries 形状：(2, 3, 1, 5) keys 形状：(2, 1, 4, 5) 相加结果 features 形状：(2, 3, 4, 5) 这表示： 对于批量中的每个样本（2个样本）， 每个查询（3个查询）与每个键（4个键）都进行了逐元素相加， 最终得到 3×4=12 个查询-键对的交互特征。 为什么要用masked_softmax？在处理文本数据集时，为了提高计算效率，可能会采用填充的方式使每个文本序列具有相同的长度，便于以相同形状的小批量进行加载，因此可能会存在一些文本序列被填充了没有意义的特殊词源（比如“”词元）。 使用masked_softmax可以过滤掉超出指定范围的位置，不让填充的无意义内容影响结果。 缩放点积注意力见书P290 自注意力完全并行、最长序列为1、但对长序列计算复杂度高 李宏毅：https://www.bilibili.com/video/BV1v3411r78R?spm_id_from=333.788.videopod.episodes&amp;vd_source=ff957cd8fbaeb55d52afc75fbcc87dfd&amp;p=2 一、如何得到b1 二、矩阵表示1整体理解 2具体表示 三、位置编码在输入中加入位置信息 二十、编码器-解码器编码器处理输入，解码器生成输出（其实就是把功能集成到一起，然后起了个新名字） 二十一、Transformer 多头注意力 每个注意力池化层都是不同的weight 有掩码的多头注意力解码器对序列中一个元素输出时，不应该考虑该元素之后的元素。 通过掩码实现 计算xi的输出时，假装当前序列长度为i 基于位置的前馈网络 n是序列的长度，不同数据n会变，不能作为特征处理，即n的变化不能影响模型。 层归一化 信息传递 预测 总结 Transformer是一个纯使用注意力的编码-阶码器 编码器和解码器都有n个transformer块 每个块里使用多头（自）注意力、基于位置的前馈网络、 层归一化","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://example.com/tags/pytorch/"},{"name":"李沐","slug":"李沐","permalink":"http://example.com/tags/%E6%9D%8E%E6%B2%90/"}]},{"title":"动手学深度学习 1","slug":"动手学深度学习 1","date":"2024-12-02T16:00:00.000Z","updated":"2025-02-11T05:05:36.507Z","comments":true,"path":"2024/12/03/动手学深度学习 1/","permalink":"http://example.com/2024/12/03/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%201/","excerpt":"","text":"一、数据操作+预处理N维数组N维数组是机器学习和神经网络的主要数据结构 0-d 标量：一个数字 1-d 向量：一个特征向量 2-d 矩阵：一个样本-特征矩阵 3-d RGB图片（宽×高×通道） 4-d 一个RGB图片的批量（批量大小batch×宽×高×通道） 创建数组需要： 形状 每个元素的数据类型 每个元素的值 访问元素 左下角子区域：1:3表示[1,3) 第二个子区域： ::3表示行是每3行一跳 ​ ::2表示列是每两列一跳 关于内存x +&#x3D; y 就是直接在原来的x上加上y，与加法的形式不一样 x &#x3D; x + y 本质上是将值给了一个新的x，开辟了个新的内存 矩阵乘法 特征向量：不被矩阵改变方向的向量 矩阵范数的求法： https://www.bilibili.com/video/BV1HD4y1u7yD/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bbecda1ec31c9852a00a62b75b7a6154 矩阵按列求和axis&#x3D;0 行 axis&#x3D;1 列 就是照着那个轴拍扁（全相加） 按单个axis求和比如shape [5,4] axis &#x3D; 1 ,sum:[5] 我不要列了–&gt; 按列向右拍扁 按多个axis求和shape [2,5,4] axis&#x3D;[1,2] sum:[2] 如果 keepdims&#x3D;True 那对应的那个维度就不拍扁shape [2,5,4] axis&#x3D;1， sum：[2,1,4] 二、线性回归是对n维输入的加权，外加偏差$$y&#x3D;w_1x_1+w_2x_2+…+w_nx_n+b$$向量版本：y&#x3D;&lt;w,x&gt;+b 可以看做单层神经网络 衡量预估质量 —— 平方损失 L2 Loss$$l &#x3D; \\frac{1}{2}（y-\\hat{y}）^2$$ 缺点：y‘和y相差很多时梯度太大 -》 使用L1 Loss 参数学习 显示解 基础优化方法梯度下降 选择批量大小 batch_size 小的话可能会引入噪声，但这个噪声可能会使模型预测不走偏，因此准确度可能更高 随机梯度下降（SGD）梯度下降是根据所有样本的平均损失进行计算，需要将所有样本重新计算一遍，非常浪费时间。 因此通常采用小批量随机梯度下降（SGD）进行求解。 三、softmax 回归（多类分类模型）得到每个类的预测置信度 使用交叉熵来衡量预测和真实情况的区别，作为损失函数 回归和分类的区别 无校验比例希望预测出的类的置信度和别的类的置信度的差最大 校验比例 作指数是为了将数值变为非负。并且经过操作后使得加起来和为1 交叉熵损失常用来衡量两个概率的区别 损失函数L1 Loss 缺点：原点处不可导；y’和y离得很近的时候不稳定 -》结合L1和L2 Loss得到下面这个损失函数 Huber’s Robust Loss 鲁棒性 robustness系统的健壮性——系统在特殊情况下的稳定性 四、感知机感知机 只输出一个离散的类，因此只能用于二分类 最早的AI模型之一 求解算法等价于使用批量大小为1的梯度下降 不能拟合XOR函数 多层感知机 MLP（Multilayer Perceptron） 这样得到的结果还是线性的，和单一的线性模型没什么区别（只是加权偏移，限制了对复杂任务的处理能力，只能解决线性问题），因此需要加入非线性激活函数 神经网络为什么working？将同一个输入给不同的神经元，每个神经元学习不同的特性，在最后线性计算合并这些特性，输出结果。 https://www.bilibili.com/video/BV1YD4y1f7p6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=bbecda1ec31c9852a00a62b75b7a6154 非线性激活函数激活函数的本质就是引入非线性性 用relu就好了，用其他的区别也不大。而且relu计算更快 nn.ReLU(inplace=True)中的inplace表示直接原地修改内容，而不是新开内存进行修改，可以节省一点内存。 多隐藏层多隐藏层一般是先扩展再压缩，先压缩的话会损失很多信息。 最后一层不要加非线性激活函数，加了会造成层数的塌陷。 为什么是多层而不是一层很宽？ 一层很宽，即让很多神经元在一起学习，不一定会有很好的效果，可能会导致过拟合。而多层的话相当于一次学一点。—&gt;深度学习 五、模型选择训练误差、泛化误差训练误差：模型在训练数据上的误差 泛化误差：模型在新数据上的误差 验证数据集、测试数据集验证数据集：一个用来评估模型好坏的数据集 例如拿出50%的训练数据 不要跟训练数据混在一起！！ 测试数据集：只用一次的数据集 例如： 未来的考试 房子的实际成交价 K-则交叉验证在没有足够多数据时使用 最后选择最好的那一次的参数作为模型的参数 过拟合、欠拟合 过拟合：数据很简单，模型容量很高，模型可能记住这些数据，但别的数据拟合程度不高。 模型容量拟合各种函数的能力 低容量的模型难以拟合训练数据 高容量的模型可以记住所有的训练数据 首先模型要大，再考虑怎么降低泛化误差 估计模型容量 数据复杂度 样本个数 每个样本的元素个数 时间、空间结构 多样性 六、权重衰退范数高维空间中一点到原点的距离 L1范数 —— 曼哈顿距离各坐标值绝对值相加 L2范数 —— 欧几里得距离高维中的勾股定理 LP范数 正则化 —— 权重衰退每一次会缩小w的取值范围 如果模型很复杂，权重衰退也不会带来很好的效果。 为什么需要正则化？模型可能会过度拟合训练数据，过于依赖训练数据中的噪声和细节。正则化通过降低模型的复杂度来防止过度拟合。 正则化会在损失函数中加入一个正则化项，它会使模型中的某些参数不能太大，因此模型会更倾向于选择那些对预测结果有更大影响的参数，减少对其他参数的依赖。 L1正则化L1正则化可能带来稀疏性，某些特征就不起作用了（去耦合，减少过拟合） L2正则化只缩小了W的权重 如何操作1、手动如果是手动加的话，就是在loss函数中加一个正则化的式子 λ自己试，看看什么时候好 2、在trainer中加参数加一个weight_decay的参数，一般设置成1e-3 这里使用的是L2范数的平方 七、丢弃法 dropout在层之间加噪音 只在训练中使用，在预测中不使用。在测试时，Dropout层仅传递数据 动机一个好的模型需要对输入数据的扰动鲁棒robust 无偏差的加入噪音 一定概率变成0，一定概率x值变大，但期望不变 使用丢弃法通常将丢弃法作用在隐藏全连接层的输出上 全连接层——每一个结点都与上一层的所有结点相连 八、数值稳定性数值爆炸 值超出值域，对于16位浮点数尤为严重 对学习率敏感 ​ 如果学习率太大-&gt;参数值会大-&gt;更大的梯度 ​ 如果学习率太小-&gt;训练无法进展 ​ 需要再训练中不断调整学习率 梯度消失 梯度值变成0 对16位浮点数尤为严重 训练无进展 对底部层尤为严重 仅仅顶部层训练的较好 无法让神经网络更深 让训练更稳定 合理的权重初始值和激活函数的选取可以提升数值稳定性 每一层的输出E&#x3D;0，D&#x3D;一个常数 九、kaggle 房价预测标准化数据预处理标准化数据","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://example.com/tags/pytorch/"},{"name":"李沐","slug":"李沐","permalink":"http://example.com/tags/%E6%9D%8E%E6%B2%90/"}]},{"title":"小土堆pytorch 第三天","slug":"小土堆pytorch 第三天","date":"2024-11-26T16:00:00.000Z","updated":"2024-12-02T11:44:15.559Z","comments":true,"path":"2024/11/27/小土堆pytorch 第三天/","permalink":"http://example.com/2024/11/27/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%20%E7%AC%AC%E4%B8%89%E5%A4%A9/","excerpt":"","text":"一、最大池化的使用池化——压缩特征 最大池化——取当前池化核中的最大的数 12345678910111213141516171819202122232425import torchfrom torch import nnfrom torch.nn import MaxPool2dinput = torch.tensor([[1, 2, 0, 3, 1], [0, 1, 2, 3, 1], [1, 2, 1, 0, 0], [5, 2, 3, 1, 1], [2, 1, 0, 1, 1]])input = torch.reshape(input, (-1, 1, 5, 5))class Test(nn.Module): def __init__(self): super(Test,self).__init__() self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=True) def forward(self,input): output = self.maxpool1(input) return outputtest = Test()output = test(input)print(output) 二、非线性激活层Relu sigmoid 三、线性层和其他层dropout用于防止过拟合（过于关注噪点之类的，捡了芝麻丢了西瓜） 四、小实战和sequential的使用 sequential作用：类似compose，可以序列化执行操作，使代码更简洁 五、loss1、计算实际输出和目标之间的差距 2、为更新输出提供一定的依据（反向传播，从loss反向修正参数） 这里backward()函数可以反向传播计算梯度（grad），将这个梯度给合适的优化器，可以对神经网络的参数进行更新。 六、优化器 TIPS1、如果某一步的参数不会算，可以先让程序运行到上一步，然后print(output.size)查看对应属性的值 2、要将数据变为浮点数，后面写dtype=torch,float32","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://example.com/tags/pytorch/"},{"name":"小土堆","slug":"小土堆","permalink":"http://example.com/tags/%E5%B0%8F%E5%9C%9F%E5%A0%86/"}]},{"title":"小土堆pytorch 第四天","slug":"小土堆pytorch 第四天","date":"2024-11-26T16:00:00.000Z","updated":"2024-12-03T08:42:29.318Z","comments":true,"path":"2024/11/27/小土堆pytorch 第四天/","permalink":"http://example.com/2024/11/27/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%20%E7%AC%AC%E5%9B%9B%E5%A4%A9/","excerpt":"","text":"一、现有模型的加载、修改、添加123456789101112131415import torchvisionfrom torch import nnvgg16_false = torchvision.models.vgg16(pretrained=False)vgg16_true = torchvision.models.vgg16(pretrained=True)print(vgg16_true)train_data = torchvision.datasets.CIFAR10(&quot;dataset&quot;, train=True, transform=torchvision.transforms.ToTensor(),download=True)vgg16_true.classifier.add_module(&#x27;add_linear&#x27;, nn.Linear(1000, 10)) # 添加 层print(vgg16_true)print(vgg16_false)vgg16_false.classifier[6] = nn.Linear(4096, 10) # 修改层的内容print(vgg16_false) 二、网络模型的保存和读取保存123456789import torchimport torchvisionvgg16 = torchvision.models.vgg16()# 保存方式1 模型结构+模型参数torch.save(vgg16, &quot;vgg16_method1.pth&quot;)# 保存方式2 模型参数 （将模型中的参数保存为字典）[官方推荐，存储量小]torch.save(vgg16.state_dict(), &quot;vgg16_method2.pth&quot;) 读取123456789101112131415161718192021222324252627import torchimport torchvisionfrom torch import nn# 方式1 对应保存方式1model = torch.load(&quot;vgg16_method1.pth&quot;)print(model)# 方式2vgg16 = torchvision.models.vgg16()vgg16.load_state_dict(torch.load(&quot;vgg16_method2.pth&quot;))print(vgg16)class Test(nn.Module): def __init__(self): super(Test, self).__init__() self.conv1 = nn.Conv2d(3, 64, 3) def forward(self, x): x = self.conv1(x) return x# 陷阱1 需要引入自己的模型，要么在开头from model_save import *,要么在这个文件中把模型复制过来model = torch.load(&#x27;test_method1.pth&#x27;)print(model) 三、完整模型的训练两种类型分类的模型 模型预测得到的outputs&#x3D;[0.3,0.5] (第一张图) ​ [0.5,0.2] (第二张图) 使用argmax（1）方法可以得到该行最大数的位置，即对应的那个类型 argmax（0）是得到列最大数的位置 这里argmax(1)=[2][1] 将模型预测的结果和真实情况进行比较： 123preds = torch.argmax(1)print((preds == targets).sum) # 得到正确率 yourmodel.train()、yourmodel.eval()对某些特定的层有影响，比如dropout层，详见pytorch官网 四、使用gpu训练法一：改动的地方： 网络模型 数据（输入、检测） 损失函数 改动方法:data = data.cuda() 法二：先在开头定义：device = torch.device(&quot;cuda&quot;) ​ 语法糖写法：device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) 接着像法一一样修改： 12test = Test()test = test.to(device) 五、查看开源项目修改参数时有些参数有required = True,可以把这个参数删掉，然后改成default=&#39;data的地址&#39; TIPSctrl + D 可以复制本行内容","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://example.com/tags/pytorch/"},{"name":"小土堆","slug":"小土堆","permalink":"http://example.com/tags/%E5%B0%8F%E5%9C%9F%E5%A0%86/"}]},{"title":"小土堆pytorch 第二天","slug":"小土堆pytorch 第二天","date":"2024-11-25T16:00:00.000Z","updated":"2024-11-27T10:56:58.064Z","comments":true,"path":"2024/11/26/小土堆pytorch 第二天/","permalink":"http://example.com/2024/11/26/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%20%E7%AC%AC%E4%BA%8C%E5%A4%A9/","excerpt":"","text":"一、DataLoader 的使用12345678910111213141516171819import torchvisionfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWritertest_data = torchvision.datasets.CIFAR10(&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor())test_loader = DataLoader(dataset=test_data, batch_size=64, shuffle=True, num_workers=0, drop_last=True) # 每次取的个数 取完后是否打乱 最后如果因为数量无法分配是否舍去writer = SummaryWriter(&quot;dataloader&quot;)for epoch in range(2): step = 0 for data in test_loader: imgs, target = data writer.add_images(f&quot;Epoch:&#123;epoch&#125;&quot;, imgs, step) step = step + 1writer.close() ！！二、python补充： call函数__call__ 可以将类名变为可执行函数 比如在下面的代码中，nn.Module 中包含了__call__函数，使得test(x)直接调用forward函数并得到返回值 call函数举例： 12345678910111213141516class Test(): # def __init__(self): 没内容时可省略不写 def forward(self, input): output = input + 1 return output def __call__(self, input): return self.forward(input) # 在类的方法内部调用另一个方法时，需使用 self 关键字来指向它test = Test()x = 1output = test(x)print(output) 三、神经网络的基本骨架 nn.Module 的使用1234567891011121314151617import torchfrom torch import nnclass Test(nn.Module): # 表示Test继承于Module，它为所有神经网络提供基本的骨架 def __init__(self): super().__init__() def forward(self, input): output = input + 1 return outputtest = Test()x = torch.tensor(1.0)output = test(x)print(output) *四、卷积操作 CONV2D （convolution）（nn.functional.conv2d 为具体方法）12345678910111213141516171819202122import torchimport torch.nn.functional as Finput = torch.tensor([[1, 2, 0, 3, 1], [0, 1, 2, 3, 1], [1, 2, 1, 0, 0], [5, 2, 3, 1, 1], [2, 1, 0, 1, 1]])kernel = torch.tensor([[1, 2, 1], [0, 1, 0], [2, 1, 0]])print(input.shape)input = torch.reshape(input, (1, 1, 5, 5)) # conv2d中要求输入和卷积层的尺寸中有4个属性，而tensor创建出来的只有2个，因此需要reshape增加他们的属性。四个属性分别为：batch_size（每次喂给神经网络多少个数据）填-1的话可以让系统根据后面三个数自动计算，通道数（1为灰度图像，rgb通道数为3），高度，宽度。kernel = torch.reshape(kernel, (1, 1, 3, 3))print(input.shape)output = F.conv2d(input, kernel, stride=1)print(output) Tips: num_workers &gt;0 时可能会出现broken pipe error ，此时把它设置为0试试 举例 padding 举例 stride举例 动图： https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md 五、卷积操作 CONV2D （nn.convv2d 为封装后的函数）（实际使用）123456789101112131415161718192021222324252627import torchimport torchvisionfrom torch import nnfrom torch.nn import Conv2dfrom torch.utils.data import DataLoaderdataset = torchvision.datasets.CIFAR10(&quot;dataset&quot;, train=False, transform=torchvision.transforms.ToTensor(),download=True)DataLoader = DataLoader(dataset, batch_size=64)class Test(nn.Module): def __init__(self): super(Test, self).__init__() self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) def forward(self, x): x=self.conv1(x) return xtest = Test()for data in DataLoader: imgs, targets = data output = test(imgs) print(imgs.shape) print(output.shape) in_channels=3: imput的通道为3 out_channels=6：output的通道为6 &#x3D;卷积核的个数 kernel_size=3：卷积核的高和宽为3 深度由系统自动计算 stride=1：步径为1 padding=0：边缘不需要加行&#x2F;列 注：卷积核中的数值应是自动生成的 训练模型就是训练卷积核中自动生成的数值 *找到的资源对知名模型的代码进行逐行解读的网站 https://nn.labml.ai/ 图神经网络的实现基本都有 Deep Graph Library https://www.dgl.ai","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://example.com/tags/pytorch/"},{"name":"小土堆","slug":"小土堆","permalink":"http://example.com/tags/%E5%B0%8F%E5%9C%9F%E5%A0%86/"}]},{"title":"小土堆pytorch 第一天","slug":"小土堆pytorch 第一天","date":"2024-11-23T16:00:00.000Z","updated":"2024-11-24T14:57:18.659Z","comments":true,"path":"2024/11/24/小土堆pytorch 第一天/","permalink":"http://example.com/2024/11/24/%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%20%E7%AC%AC%E4%B8%80%E5%A4%A9/","excerpt":"","text":"一、两大法宝函数1、dir()打开，看见 2、help()查看说明书 二、三个运行方式的区别 三、如何导入数据两种数据形式：Dataset、Dataloader Dataset1、如何获取每一个数据及其label？ 2、总共有多少条数据？ 12345678910111213141516171819202122232425262728293031from torch.utils.data import Datasetfrom PIL import Imageimport os # 用于获取图片的地址class MyData(Dataset): def __init__(self, root_dir, label_dir): self.root_dir = root_dir self.label_dir = label_dir self.path = str(os.path.join(self.root_dir, self.label_dir)) # 拼接地址 self.img_path = os.listdir(self.path) # 获取当前目录中文件的地址列表 def __getitem__(self, idx): img_name = self.img_path[idx] # 获取文件名 img_item_path = os.path.join(self.root_dir,self.label_dir,img_name) # 拼接地址 img = Image.open(img_item_path) label = self.label_dir return img, label def __len__(self): return len(self.img_path)root_dir = &quot;dataset/train&quot;ants_label_dir = &quot;ants&quot;bees_label_dir = &quot;bees&quot;ants_dataset = MyData(root_dir, ants_label_dir)bees_dataset = MyData(root_dir, bees_label_dir)train_dataset = ants_dataset + bees_dataset 四、Tensorboard的使用12345678from torch.utils.tensorboard import SummaryWriterwriter = SummaryWriter(&quot;logs&quot;) # 文件存放在logs文件夹中for i in range(100): writer.add_scalar(&quot;y=2x&quot;, 2*i, i) # tag 纵轴 横轴writer.close() 如何打开tensorboard界面？终端中： tensorboard –logdir&#x3D;”D:\\pycharm\\learn_pytorch\\learn_pytorch\\logs” 如何切换打开的端口（避免服务器训练时与别人冲突）tensorboard –logdir&#x3D;”D:\\pycharm\\learn_pytorch\\learn_pytorch\\logs” –port&#x3D;6007（修改端口地址） 导入自己的图片123456789101112from torch.utils.tensorboard import SummaryWriterimport numpy as npfrom PIL import Imagewriter = SummaryWriter(&quot;logs&quot;)image_path = &quot;dataset/train/ants/0013035.jpg&quot;img_PIL = Image.open(image_path)img_array = np.array(img_PIL) # 将图片转为numpy格式writer.add_image(&quot;test&quot;, img_array, 1, dataformats=&#x27;HWC&#x27;)# 从PIL到numpy，需要在add_image()中指定shape中每一个数字、维度表示的含义writer.close() 如果改变image的地址并且将writer.add_image(&quot;test&quot;, img_array, 1（横轴）, dataformats=&#39;HWC&#39;)中的横轴改为2，则tensorboard会在之前的图片上显示拖动条，向右拖动即为第二张图片 五、transform的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344from PIL import Imagefrom torch.utils.tensorboard import SummaryWriterfrom torchvision import transformswriter = SummaryWriter(&quot;logs&quot;)img = Image.open(&quot;dataset/train/ants/0013035.jpg&quot;)print(img)# ToTensor (transforms的一种工具)trans_totensor = transforms.ToTensor() # 打开并配置工具img_totensor = trans_totensor(img) # 使用工具writer.add_image(&quot;ToTensor&quot;, img_totensor)# Normalize 归一化 (预处理，确保输入模型的数据在相同的尺度上。将数据缩放到一个小范围)trans_norm = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])img_norm = trans_norm(img_totensor)writer.add_image(&quot;Normalize&quot;, img_norm)# Resizeprint(img.size)trans_resize = transforms.Resize((512, 512))img_resize = trans_resize(img) # 得到的仍然是PIL类型img_resize = trans_totensor(img_resize) # 得到tensor类型的图片writer.add_image(&quot;Resize&quot;, img_resize, 0)print(img_resize)# 方法2 Compose - resize 相当于打包处理的过程trans_resize_2 = transforms.Resize(512)trans_compose = transforms.Compose([trans_resize_2, trans_totensor])# 将resize和转换为tensor的操作用compose打包,第一个操作的输出是第二个操作的输入img_resize2 = trans_compose(img)writer.add_image(&quot;Resize&quot;, img_resize2, 1)# RandomCrop 随机裁剪trans_randomCrop = transforms.RandomCrop((500, 1000)) # 只写一个数就是按正方形裁剪trans_compose2 = transforms.Compose([trans_randomCrop, trans_totensor])for i in range(10): img_crop = trans_compose2(img) writer.add_image(&quot;RandomCropHW&quot;, img_crop, i)writer.close() transforms.Normalize(mean, std)注：需要传递tensor类型图片 将图像的每个通道（RGB，共3个通道）按特定的均值和标准差进行归一化 Resize()注：需要传递PIL类型图片 括号中只给一个数值，那么就将图片短的那个边匹配这个数值进行等比缩放 括号中给两个数值，就将长宽设置为这两个数值 Tips关注输入和输出类型 关注方法需要什么参数 不知道返回值的时候，可以print()或print(type())或debug","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://example.com/tags/pytorch/"},{"name":"小土堆","slug":"小土堆","permalink":"http://example.com/tags/%E5%B0%8F%E5%9C%9F%E5%A0%86/"}]}],"categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://example.com/tags/javase/"},{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Swin-Unet","slug":"Swin-Unet","permalink":"http://example.com/tags/Swin-Unet/"},{"name":"pytorch","slug":"pytorch","permalink":"http://example.com/tags/pytorch/"},{"name":"李沐","slug":"李沐","permalink":"http://example.com/tags/%E6%9D%8E%E6%B2%90/"},{"name":"小土堆","slug":"小土堆","permalink":"http://example.com/tags/%E5%B0%8F%E5%9C%9F%E5%A0%86/"}]}