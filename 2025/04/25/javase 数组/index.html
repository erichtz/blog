<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>javase 数组 | eric_zht</title><meta name="author" content="eric_zht"><meta name="copyright" content="eric_zht"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="四、数组数组概述 数组是引用数据类型，隐式继承Object，因此可以调用Object类中的方法 数组对象存储在堆内存中  数组的特点 数组长度一旦确定不可改变 所有数组对象都有length属性，用来获取数组元素个数  优点：  根据下标查找某个元素的效率极高  缺点：  随机增删的效率低，需要后移&#x2F;前移很多元素 无法存储大量数据，因为很难在内存上找到非常大的一块连续内存  一维数组静态初">
<meta property="og:type" content="article">
<meta property="og:title" content="javase 数组">
<meta property="og:url" content="http://example.com/2025/04/25/javase%20%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="eric_zht">
<meta property="og:description" content="四、数组数组概述 数组是引用数据类型，隐式继承Object，因此可以调用Object类中的方法 数组对象存储在堆内存中  数组的特点 数组长度一旦确定不可改变 所有数组对象都有length属性，用来获取数组元素个数  优点：  根据下标查找某个元素的效率极高  缺点：  随机增删的效率低，需要后移&#x2F;前移很多元素 无法存储大量数据，因为很难在内存上找到非常大的一块连续内存  一维数组静态初">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/icon.png">
<meta property="article:published_time" content="2025-04-24T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-25T10:50:11.600Z">
<meta property="article:author" content="eric_zht">
<meta property="article:tag" content="javase">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/icon.png"><link rel="shortcut icon" href="/image/favicon.png"><link rel="canonical" href="http://example.com/2025/04/25/javase%20%E6%95%B0%E7%BB%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'javase 数组',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/icon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pic.imgdb.cn/item/6741310cd29ded1a8c7a7799.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">eric_zht</span></a><a class="nav-page-title" href="/"><span class="site-name">javase 数组</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">javase 数组</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-24T16:00:00.000Z" title="发表于 2025-04-25 00:00:00">2025-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-25T10:50:11.600Z" title="更新于 2025-05-25 18:50:11">2025-05-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">20.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>73分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h1><h2 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h2><ul>
<li>数组是引用数据类型，隐式继承Object，因此可以调用Object类中的方法</li>
<li>数组对象存储在堆内存中</li>
</ul>
<h2 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h2><ul>
<li>数组长度一旦确定不可改变</li>
<li>所有数组对象都有length属性，用来获取数组元素个数</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>根据下标查找某个元素的效率极高</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>随机增删的效率低，需要后移&#x2F;前移很多元素</li>
<li>无法存储大量数据，因为很难在内存上找到非常大的一块连续内存</li>
</ul>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="静态初始化一维数组"><a href="#静态初始化一维数组" class="headerlink" title="静态初始化一维数组"></a>静态初始化一维数组</h3><p><strong>已经知道数组中的值</strong>时使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;; 或者 <span class="type">int</span> arr[] = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;; <span class="comment">//后者不建议</span></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>用第一种就好了！</strong></p>
<h3 id="JDK5-新特性：增强for循环-for-each-循环"><a href="#JDK5-新特性：增强for循环-for-each-循环" class="headerlink" title="JDK5 新特性：增强for循环 &#x2F; for-each 循环"></a>JDK5 新特性：增强for循环 &#x2F; for-each 循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素数据类型 变量名:数组名)&#123; <span class="comment">// 变量名代表数组中的每个元素，可以自己取名</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：代码简洁</p>
<p>缺点：没有下标</p>
<h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><p><strong>不知道数组中具体存储哪些元素</strong>时使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 变量名 = <span class="keyword">new</span> 数据类型[长度]</span><br></pre></td></tr></table></figure>

<p>数组长度确定，数组中存储的每个元素将采用默认值。</p>
<h3 id="数组中如何存储不同类的对象"><a href="#数组中如何存储不同类的对象" class="headerlink" title="数组中如何存储不同类的对象"></a>数组中如何存储不同类的对象</h3><p>创建父类类型的数组，即可存子类的对象</p>
<p>eg.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Apple</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line"><span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">Object[] objs = &#123;a,b&#125;;</span><br></pre></td></tr></table></figure>

<p>存的是对象的<strong>地址</strong></p>
<h3 id="关于main方法的形参args"><a href="#关于main方法的形参args" class="headerlink" title="关于main方法的形参args"></a>关于main方法的形参args</h3><ul>
<li><p>作用：接收命令行参数用的</p>
</li>
<li><p>JVM负责调用main方法时用的 ——JVM负责给main方法准备一个String[ ]一维数组对象</p>
</li>
<li><p><code>java fileName abc def xyz</code>命令行参数：abc def xyz，JVM会将命令行参数以空格进行拆分，生成一个新的数组对象。</p>
<p>String[ ] args &#x3D; {“abc”,”def”,”xyz”};</p>
</li>
</ul>
<p>​		命令行参数有什么用？</p>
<p>​		需求：使用该系统的时候，需要提供正确的口令（用户名和密码），非法用户直接退出系统。</p>
<p>​		当两个字符串进行equals比较时，如果其中有一个字符串是字面量，建议将字面量写到前面。即：<code>&quot;string&quot;.equals(variable)</code>，避免出现空指针异常。</p>
<h3 id="可变长度的参数"><a href="#可变长度的参数" class="headerlink" title="可变长度的参数"></a>可变长度的参数</h3><p><code>function1(int ... nums)</code></p>
<ul>
<li>语法格式：<code>数据类型...</code>		</li>
<li>在形参列表中，可变长度的参数只能有一个，且只能在参数列表的末尾</li>
<li>可变长度的参数可以当做数组来看待 可通过这种方式访问：nums[0],nums[1]</li>
</ul>
<h3 id="一维数组的扩容"><a href="#一维数组的扩容" class="headerlink" title="一维数组的扩容"></a>一维数组的扩容</h3><ul>
<li><p>数组长度一旦确定不可改变</p>
</li>
<li><p>只能新建一个更大的数组，然后将原数组的数据全部拷贝到新数组中，可以使用<code>System.arraycopy()</code></p>
</li>
<li><p>数组扩容会影响程序的执行效率，因此尽可能预测数据量，减小扩容次数。</p>
</li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span> [][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>&#125;&#125;; </span><br><span class="line"><span class="comment">// 可以等长，也可以不等长</span></span><br></pre></td></tr></table></figure>

<h3 id="动态初始化-1"><a href="#动态初始化-1" class="headerlink" title="动态初始化"></a>动态初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等长</span></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 不等长</span></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>][];</span><br></pre></td></tr></table></figure>

<h2 id="Arrays-工具类"><a href="#Arrays-工具类" class="headerlink" title="Arrays 工具类"></a>Arrays 工具类</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250426165506063.png" alt="image-20250426165506063"></p>
<ul>
<li>自定义类型做比较的话，这个自定义类型必须实现Comparable接口，并实现compareTo方法。使用sort进行排序时也需要实现该方法。</li>
</ul>
<p><img src="https://pic.ericzht.space/PicGo/image-20250504092347101.png" alt="image-20250504092347101"></p>
<ul>
<li><code>int[] Arrays.copyOf()</code>是系统自动在内部新建一个数组，将原来的数组复制到新建的数组中，并返回新建的数组。而<code>System.arraycopy()</code>没有新建数组，是直接将内容复制到另一个数组中的。而且arraycopy是native方法，由c++代码实现，因此<strong>arraycopy的拷贝速度更快</strong>。</li>
</ul>
<h1 id="五、异常"><a href="#五、异常" class="headerlink" title="五、异常"></a>五、异常</h1><h2 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h2><p>java程序执行过程中的意外、错误、不正确的情况</p>
<h2 id="异常在java中的形式"><a href="#异常在java中的形式" class="headerlink" title="异常在java中的形式"></a>异常在java中的形式</h2><p>以<strong>类和对象</strong>的形式存在。</p>
<p>定义异常其实本质上就是定义一个类。</p>
<p>异常如果发生的话，在底层其实通过了这个类new了一个对象。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250504104320928.png" alt="image-20250504104320928"></p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ol>
<li>自定义异常的类需要继承Exception或者RuntimeException，如果继承的是Exception就认为这个异常是编译时异常。</li>
<li>提供两个构造方法，一个是无参数的，一个是带有String参数的，并且在构造方法中调用<code>super(String)；</code></li>
</ol>
<h2 id="处理异常的两种方法"><a href="#处理异常的两种方法" class="headerlink" title="处理异常的两种方法"></a>处理异常的两种方法</h2><ol>
<li><p>抛出异常：在类的声明中添加 <code>throws 异常类名</code></p>
<p>如果有些方法不允许使用thorws，也可以使用try catch然后在catch里面使用throw</p>
</li>
<li><p>捕捉异常</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 尝试执行的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>注：异常类型1,2,3，… 一定是从小到大的，否则如果第一个就是父类，那永远都不可能运行后面的异常处理代码了。</p>
<p>throw和throws的区别：</p>
<ol>
<li>throw是运行时的语句，真正地抛出一个异常实例</li>
<li>throws是编译时的声明，告诉编译器和调用者，如果出现这些问题就抛出。</li>
</ol>
<h2 id="JAVA7-新特性-——-异常统一处理方式"><a href="#JAVA7-新特性-——-异常统一处理方式" class="headerlink" title="JAVA7 新特性 —— 异常统一处理方式"></a>JAVA7 新特性 —— 异常统一处理方式</h2><p>1. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 尝试执行的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> | 异常类型<span class="number">2</span> 变量名)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h2 id="异常对象的方法"><a href="#异常对象的方法" class="headerlink" title="异常对象的方法"></a>异常对象的方法</h2><ul>
<li>getMessage</li>
<li>printStackTrace</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 尝试执行的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IllegalNameException e)&#123;</span><br><span class="line">    <span class="comment">// 这个方法可以获取当时创建异常对象时给异常构造方法传递的String message参数的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> e.getMessage(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印异常的堆栈信息</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">后面执行的代码</span><br></pre></td></tr></table></figure>

<p>异常的堆栈信息：</p>
<ul>
<li><p>异常信息的打印是符合栈这个数据结构的，因此优先看最上面的异常行数，最上面是最后执行的代码</p>
</li>
<li><p>打印异常堆栈信息可能出现在“后面执行的代码”前面，也可能在后面。因为高版本的底层是用多线程并行打印的。</p>
</li>
</ul>
<h2 id="finally-语句块"><a href="#finally-语句块" class="headerlink" title="finally 语句块"></a>finally 语句块</h2><p>放在该语句块中的代码是一定会执行的（无论前面的程序是否有异常），一般在finally语句块中完成资源的释放。</p>
<p>顺序：try…(catch)…finally</p>
<h2 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a>继承问题</h2><p>子类继承父类后，重写了父类的方法，重写之后<strong>不能抛出更多的异常</strong>，可以更少。</p>
<h1 id="六、常用类"><a href="#六、常用类" class="headerlink" title="六、常用类"></a>六、常用类</h1><h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h2><h3 id="为什么string-字面量不可变？"><a href="#为什么string-字面量不可变？" class="headerlink" title="为什么string 字面量不可变？"></a>为什么string 字面量不可变？</h3><p>因为底层代码中string是用byte数组存的，而byte数组是private final修饰的，因此无法修改它的值。（java8及之前是char数组）</p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><ul>
<li>如果拼接的两个字符串中有一个是变量，那么拼接后的新字符串<strong>不会</strong>放到字符串常量池中。而是在堆中。</li>
</ul>
<p>​		<strong>底层在进行拼接时，会创建一个StringBuilder对象，进行字符串拼接。最后自动调用StringBuilder对象中的<code>toString()</code>方法，再将StringBuilder对象转换成String对象。</strong></p>
<ul>
<li>两个字符串字面量拼接会在编译阶段做优化，在编译阶段进行拼接（可以这么理解，但不准确）因此<strong>字符串常量池中只有拼接后的内容</strong>。</li>
</ul>
<h3 id="怎么把字符串手动放进字符串常量池？"><a href="#怎么把字符串手动放进字符串常量池？" class="headerlink" title="怎么把字符串手动放进字符串常量池？"></a>怎么把字符串手动放进字符串常量池？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> m.intern(); <span class="comment">// 将&quot;test&quot;放入字符串常量池，并且将&quot;test&quot;对象的地址返回。如果字符串常量池已经存在&quot;test&quot;，那么就直接返回地址。</span></span><br></pre></td></tr></table></figure>

<p>只能加东西，不能删东西。</p>
<h3 id="String类常用的构造方法"><a href="#String类常用的构造方法" class="headerlink" title="String类常用的构造方法"></a>String类常用的构造方法</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250504170631964.png" alt="image-20250504170631964"></p>
<h3 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250504172720448.png" alt="image-20250504172720448"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250504174128601.png" alt="image-20250504174128601"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250505133142362.png" alt="image-20250505133142362"></p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250505134512560.png" alt="image-20250505134512560"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250505134535133.png" alt="image-20250505134535133"></p>
<h4 id="String-中正则表达式相关的方法"><a href="#String-中正则表达式相关的方法" class="headerlink" title="String 中正则表达式相关的方法"></a>String 中正则表达式相关的方法</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250505135051207.png" alt="image-20250505135051207"></p>
<h2 id="StringBuffer-与-StringBuilder-可变长度字符串"><a href="#StringBuffer-与-StringBuilder-可变长度字符串" class="headerlink" title="StringBuffer 与 StringBuilder 可变长度字符串"></a>StringBuffer 与 StringBuilder 可变长度字符串</h2><ul>
<li>这两个类是专门为频繁进行字符串拼接而准备的</li>
<li>StringBuffer是先出现的，Java5时新增了StringBuilder。StringBuffer是线程安全的，而StringBuilder效率更高。</li>
<li>两者底层都是byte[]数组，并且没有被final修饰，因此可以扩容。</li>
<li><strong>优化策略：创建对象时预估好字符串的长度，给定一个合适的初始化容量，减少底层数组扩容的次数。</strong></li>
<li>StringBuilder默认初始化容量：16</li>
<li><strong>StringBuilder扩容策略：每次扩容为原来的两倍+2</strong></li>
</ul>
<p><strong>为什么频繁拼接字符串时使用StringBuilder&#x2F;StringBuffer更好？</strong></p>
<p>使用“+”进行拼接，底层每次都会创建一个StringBuilder对象，然后再调用toString方法，10000次拼接就要创建10000次对象，同时给垃圾回收也造成了很大的压力。</p>
<p>而StringBuilder的append不创建新对象，直接在原来的位置进行拼接，且不调用toString方法，只有用print输出的时候才调用一次，因此节省了大量的时间。</p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250506204324943.png" alt="image-20250506204324943"></p>
<p>包装类中的6个数字类型都继承了Number类</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250506204542750.png" alt="image-20250506204542750"></p>
<p><strong>装箱boxing：</strong>将基本数据类型包装成引用数据类型 <code>Integer i = new Integer(100);</code></p>
<p>拆箱：<code>int num = i.intValue()</code></p>
<h3 id="Integer-常用方法"><a href="#Integer-常用方法" class="headerlink" title="Integer 常用方法"></a>Integer 常用方法</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250506205907163.png" alt="image-20250506205907163"></p>
<h3 id="String、int、Integer-三者相互转换"><a href="#String、int、Integer-三者相互转换" class="headerlink" title="String、int、Integer 三者相互转换"></a>String、int、Integer 三者相互转换</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250506211343316.png" alt="image-20250506211343316"></p>
<h3 id="自动装箱-拆箱（JAVA5新特性）"><a href="#自动装箱-拆箱（JAVA5新特性）" class="headerlink" title="自动装箱&#x2F;拆箱（JAVA5新特性）"></a>自动装箱&#x2F;拆箱（JAVA5新特性）</h3><p>编译阶段的功能，底层仍然是之前的装箱&#x2F;拆箱。只是让你编程的时候方便一点。</p>
<h4 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h4><p><code>Integer x = 100;</code></p>
<h4 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h4><p><code>int num = x;</code></p>
<h3 id="整数型常量池"><a href="#整数型常量池" class="headerlink" title="整数型常量池"></a>整数型常量池</h3><p>[-128~127]这些数字太常用了，为了提高效率，Java提供了一个整数型常量池。</p>
<p>这个常量池是一个数组：Integer[ ] integerCache; </p>
<p>数组中存储了256个Integer的引用，只要没有超出这个范围的数字，直接从整数型常量池中取。</p>
<h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>大数字：</p>
<ul>
<li>超过long了使用java.math.BigInteger</li>
<li>他的父类是Number</li>
<li>他是引用数据类型</li>
</ul>
<p>常用方法：</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250506213606778.png" alt="image-20250506213606778"></p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>浮点型超过double就使用BigDecimal</p>
<p>构造方法：BigDecimal(String val)</p>
<p>常用方法：</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507104150446.png" alt="image-20250507104150446"></p>
<h3 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>该类是专门用来对数字进行格式化的。</p>
<p>常用数字格式：</p>
<ul>
<li>###,###.##        三个数字为一组，组和组之间使用逗号隔开，保留两位小数</li>
<li>###,###.0000    三个数字为一组，组和组之间使用逗号隔开，保留4位小数，不够补0</li>
</ul>
<p>构造方法：DecimalFormat(String pattern)</p>
<p>常用方法：String format(数字)</p>
<h2 id="日期相关API"><a href="#日期相关API" class="headerlink" title="日期相关API"></a>日期相关API</h2><h3 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.Date 日期API</span></span><br><span class="line"><span class="comment">// 获取系统当前时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取指定的时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(输入毫秒数) <span class="comment">//1970年0时0分0秒 + 输入的毫秒数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取1970到当前的毫秒数,这是java.lang.System类的方法。</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure>

<h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTest01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(输入格式的字符串) <span class="comment">// 各种格式见文档</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sdf.format(输入要转换的时间) <span class="comment">// 日期转格式化字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将String转化成Date"><a href="#将String转化成Date" class="headerlink" title="将String转化成Date"></a>将String转化成Date</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> <span class="string">&quot;2008-08-08 08:08:08 888&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf2.parse(strDate); <span class="comment">// 用自己创建的格式去解析字符串中的日期</span></span><br></pre></td></tr></table></figure>

<h3 id="java-util-Calend-ar-日历类"><a href="#java-util-Calend-ar-日历类" class="headerlink" title="java.util.Calend ar 日历类"></a>java.util.Calend ar 日历类</h3><h4 id="获取当前时间的日历对象"><a href="#获取当前时间的日历对象" class="headerlink" title="获取当前时间的日历对象"></a>获取当前时间的日历对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure>

<h4 id="获取日历中的某部分"><a href="#获取日历中的某部分" class="headerlink" title="获取日历中的某部分"></a>获取日历中的某部分</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250507111805395.png" alt="image-20250507111805395"></p>
<h4 id="修改日历中的内容"><a href="#修改日历中的内容" class="headerlink" title="修改日历中的内容"></a>修改日历中的内容</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250507113921982.png" alt="image-20250507113921982"></p>
<h2 id="日历的新API（java8）"><a href="#日历的新API（java8）" class="headerlink" title="日历的新API（java8）"></a>日历的新API（java8）</h2><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>传统的日期API存在线程安全问题，于是java8提供了一套全新的日期API</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507114255117.png" alt="image-20250507114255117"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507114954817.png" alt="image-20250507114954817"></p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507115444014.png" alt="image-20250507115444014"></p>
<h3 id="计算时间间隔、日期间隔"><a href="#计算时间间隔、日期间隔" class="headerlink" title="计算时间间隔、日期间隔"></a>计算时间间隔、日期间隔</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507115627185.png" alt="image-20250507115627185"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507115736786.png" alt="image-20250507115736786"></p>
<h3 id="时间矫正器"><a href="#时间矫正器" class="headerlink" title="时间矫正器"></a>时间矫正器</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507115810587.png" alt="image-20250507115810587"></p>
<h3 id="日期格式化-1"><a href="#日期格式化-1" class="headerlink" title="日期格式化"></a>日期格式化</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507115949312.png" alt="image-20250507115949312"></p>
<p>注意：这里使用LocalDateTime去调用parse方法，还需要把格式作为参数传入。</p>
<h2 id="数学类-Math"><a href="#数学类-Math" class="headerlink" title="数学类 Math"></a>数学类 Math</h2><p>回顾：工具类的方法都是静态的，直接使用类名调用。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507141230707.png" alt="image-20250507141230707"></p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可读性强</li>
<li>做了类型的限定，在编译阶段就可以确定类型是否正确，不正确会报错</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举类型名 &#123;</span><br><span class="line">	枚举值<span class="number">1</span>,枚举值<span class="number">2</span>,枚举值<span class="number">3</span>,枚举值<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507142735026.png" alt="image-20250507142735026"></p>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507143828351.png" alt="image-20250507143828351"></p>
<h2 id="Random-随机数生成器"><a href="#Random-随机数生成器" class="headerlink" title="Random 随机数生成器"></a>Random 随机数生成器</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250507144042746.png" alt="image-20250507144042746"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">101</span>); <span class="comment">// 生成一个[0,101)的随机数</span></span><br></pre></td></tr></table></figure>



<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250507165944744.png" alt="image-20250507165944744"></p>
<h2 id="UUID-通用唯一标识符"><a href="#UUID-通用唯一标识符" class="headerlink" title="UUID 通用唯一标识符"></a>UUID 通用唯一标识符</h2><p>UUID是一种软件构建的标准，用来生成具有唯一性的ID。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507170341895.png" alt="image-20250507170341895"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> uuid.toString();</span><br></pre></td></tr></table></figure>



<h1 id="七、集合"><a href="#七、集合" class="headerlink" title="七、集合"></a>七、集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><ul>
<li><p>集合是一种容器，用来组织和管理数据。</p>
</li>
<li><p>Java的集合框架对应的这套类库其实就是<strong>对各种数据结构的实现</strong>。</p>
</li>
<li><p>集合存储的是<strong>引用</strong>。</p>
</li>
<li><p>默认情况下，如果不使用泛型，集合中可以存储任何类型的引用。</p>
</li>
</ul>
<p>Java集合框架分为两部分：</p>
<ol>
<li>Collection结构：元素以单个的形式存储</li>
<li>Map结构：元素以键值对的映射关系存储</li>
</ol>
<h2 id="Collection-关系图"><a href="#Collection-关系图" class="headerlink" title="Collection 关系图"></a>Collection 关系图</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250509151443189.png" alt="image-20250509151443189"></p>
<h2 id="Collection接口的通用方法"><a href="#Collection接口的通用方法" class="headerlink" title="Collection接口的通用方法"></a>Collection接口的通用方法</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250507205015673.png" alt="image-20250507205015673"></p>
<h2 id="Collection的通用遍历-迭代方式"><a href="#Collection的通用遍历-迭代方式" class="headerlink" title="Collection的通用遍历&#x2F;迭代方式"></a>Collection的通用遍历&#x2F;迭代方式</h2><p><strong>面向接口编程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步：获取集合的迭代器对象</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> col.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：判断光标当前指向的位置是否有元素</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">// 第三步：光标返回当前指向的内容，并移动到下一个元素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SequencedCollection接口"><a href="#SequencedCollection接口" class="headerlink" title="SequencedCollection接口"></a>SequencedCollection接口</h2><p>所有的有序集合都实现了SequencedCollection接口</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250508113038478.png" alt="image-20250508113038478"></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li>java5新特性，是编译阶段的功能。</li>
</ul>
<h3 id="泛型初体验"><a href="#泛型初体验" class="headerlink" title="泛型初体验"></a>泛型初体验</h3><ul>
<li>程序编写时看帮助文档中是否有”&lt;&gt;”符号，如果有这个符号就可以使用泛型。</li>
<li>创建一个集合，要求这个集合中只能存放某种类型的对象，就可以使用泛型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line"></span><br><span class="line">Iterator&lt;User&gt; it = users.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> it.next();</span><br><span class="line">    user.pay()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不用泛型，it.next()返回的类型是Object，还需要向下转型才能使用子类独有的方法。而使用了泛型后，迭代器返回的类型就自动向下转型为子类了。</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250509192841450.png" alt="image-20250509192841450"></p>
<h3 id="钻石表达式-（Java7新特性）"><a href="#钻石表达式-（Java7新特性）" class="headerlink" title="钻石表达式 （Java7新特性）"></a>钻石表达式 （Java7新特性）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() <span class="comment">// 后面尖括号中的内容可以省略</span></span><br></pre></td></tr></table></figure>



<h3 id="泛型擦除与补偿（了解）"><a href="#泛型擦除与补偿（了解）" class="headerlink" title="泛型擦除与补偿（了解）"></a>泛型擦除与补偿（了解）</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250508140247873.png" alt="image-20250508140247873"></p>
<h3 id="泛型的定义"><a href="#泛型的定义" class="headerlink" title="泛型的定义"></a>泛型的定义</h3><h4 id="在类上自定义泛型"><a href="#在类上自定义泛型" class="headerlink" title="在类上自定义泛型"></a>在类上自定义泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">vip</span>&lt;NameType, AgeType&gt;&#123; <span class="comment">// 在声明类时写上泛型名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">vip</span><span class="params">(NameType name, AgeType age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> NameType name;</span><br><span class="line">    <span class="keyword">private</span> AgeType age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在类上定义的泛型，在静态方法中无法使用。</strong>（因为静态方法直接通过类名调用，此时还没有通过声明类的对象来指定泛型的类型。）</p>
<h4 id="在静态方法上定义泛型"><a href="#在静态方法上定义泛型" class="headerlink" title="在静态方法上定义泛型"></a>在静态方法上定义泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(T element)</span>&#123; <span class="comment">// 在使用前需要先定义泛型</span></span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        test.print(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="在接口上定义泛型"><a href="#在接口上定义泛型" class="headerlink" title="在接口上定义泛型"></a>在接口上定义泛型</h4><p>和类定义泛型差不多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyCompare</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T element)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一种实现接口的方式：此时我已经知道泛型要用什么类型了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> <span class="keyword">implements</span> <span class="title class_">MyCompare</span>&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        比较的代码;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现接口的方式：此时还不知道泛型用什么类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyCompare</span>&lt;T&gt;&#123; <span class="comment">// 再给类定义一个泛型，然后等创建对象时再确定泛型的类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T a)</span>&#123; <span class="comment">// 或者这个时候就不要用泛型了，直接把参数的类型写成 Object</span></span><br><span class="line">        比较的代码;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><h5 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h5><p><code>&lt;?&gt;</code> 此处表示后面填写的泛型可以是任意数据类型。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250508151444447.png" alt="image-20250508151444447"></p>
<h5 id="上限通配符"><a href="#上限通配符" class="headerlink" title="上限通配符"></a>上限通配符</h5><p><code>&lt;? extends Number&gt;</code> 表示泛型必须为Number及其子类</p>
<h5 id="下限通配符"><a href="#下限通配符" class="headerlink" title="下限通配符"></a>下限通配符</h5><p><code>&lt;？ super Number&gt;</code> 表示泛型必须为Number及其父类</p>
<h2 id="集合的并发修改问题-fail-fast-机制"><a href="#集合的并发修改问题-fail-fast-机制" class="headerlink" title="集合的并发修改问题 fail-fast 机制"></a>集合的并发修改问题 fail-fast 机制</h2><ul>
<li><p>集合中设置了一个modCount属性，用来记录修改的次数，使用集合对象执行增删改的操作时，modCount就会自动加1。</p>
</li>
<li><p>获取迭代器对象时，会给迭代器对象初始化一个expectedModCount属性，并且将modCount的值赋值给expectedModCount。</p>
<p>即<code>int expectedModCount = modCount;</code></p>
</li>
<li><p>当使用集合对象删除元素时，modCount会加1，但是迭代器中的expectedModCount没有加1。而当迭代起对象的<code>next()</code>方法执行时，会检测expectedModCount和modCount是否相等，如果不相等，就会抛出ConcurrentModificationException异常</p>
</li>
<li><p>而如果使用迭代起删除元素时，modCount和expectedModCount都会加1.这样next()方法在检测时就是相等的，不会出现异常。</p>
</li>
</ul>
<p>注：即使没有使用多线程编程，但是用迭代器去遍历的同时使用集合去删除元素，这个行为将被认为并发修改。</p>
<p><strong>所以，迭代集合时，要使用 <code>迭代器对象.remove()</code>，移除的是当前光标所执行的元素。</strong></p>
<h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>有序、可重复</p>
<h3 id="常见的实现类"><a href="#常见的实现类" class="headerlink" title="常见的实现类"></a>常见的实现类</h3><ul>
<li>ArrayList 数组</li>
<li>Vector、Stack 数组（线程安全的）</li>
<li>LinkedList 双向链表</li>
</ul>
<h3 id="List接口特有的方法"><a href="#List接口特有的方法" class="headerlink" title="List接口特有的方法"></a>List接口特有的方法</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250508164614700.png" alt="image-20250508164614700"></p>
<h3 id="List特有的迭代方式"><a href="#List特有的迭代方式" class="headerlink" title="List特有的迭代方式"></a>List特有的迭代方式</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250508211934510.png" alt="image-20250508211934510"></p>
<p>注：调用迭代器的remove和set方法的前提是之前调用了next或者previous方法获取了一个元素，remove和set是作用于之前获取的那个元素上的。</p>
<h3 id="List接口使用Comparator排序"><a href="#List接口使用Comparator排序" class="headerlink" title="List接口使用Comparator排序"></a>List接口使用Comparator排序</h3><h4 id="回顾数组中自定义类型是如何排序的？"><a href="#回顾数组中自定义类型是如何排序的？" class="headerlink" title="回顾数组中自定义类型是如何排序的？"></a>回顾数组中自定义类型是如何排序的？</h4><ul>
<li>所有自定义类型排序时必须指定排序规则，实现Comparable接口，并重写compareTo方法。   <em>重写是override</em></li>
</ul>
<h4 id="List集合的排序"><a href="#List集合的排序" class="headerlink" title="List集合的排序"></a>List集合的排序</h4><ul>
<li>default void sort(Comparator&lt;? super E&gt; c);</li>
<li>sort方法需要一个参数：java.util.Comparator ，我们把它叫做比较器，它是一个接口。</li>
<li>如何给自定义类型指定比较规则？可以对Comparator提供一个实现类，并重写compare方法来指定比较规则</li>
<li>这个实现类也可以看采用匿名内部类的方式。</li>
</ul>
<p><strong>对数组的排序是在类里面重写比较规则，对List集合的排序是单独设定一个比较规则并在需要时使用。</strong></p>
<h2 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h2><h3 id="回顾：数组的优缺点"><a href="#回顾：数组的优缺点" class="headerlink" title="回顾：数组的优缺点"></a>回顾：数组的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>数组在内存中是连续存储的，有下标就有偏移量，可以通过偏移量计算出对应元素的内存地址。检索效率高，时间复杂度O（1）</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>不能存储大数据（因为内存地址是连续的）</li>
<li>随机增删元素耗时很长</li>
</ol>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>需要频繁检索元素，很少进行随机增删的情况。</p>
<h3 id="ArrrayList扩容策略"><a href="#ArrrayList扩容策略" class="headerlink" title="ArrrayList扩容策略"></a>ArrrayList扩容策略</h3><ol>
<li>当调用无参构造方法时，初始化容量为0。</li>
<li>当第一次调用add方法时，将ArrayList容量初始化为10个长度。</li>
<li>后续扩容时，底层会创建一个新的数组，然后使用数组拷贝。新数组的容量是原容量的1.5倍。</li>
</ol>
<h2 id="Vector-类（-不怎么使用了）"><a href="#Vector-类（-不怎么使用了）" class="headerlink" title="Vector 类（*不怎么使用了）"></a>Vector 类（*不怎么使用了）</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250509151626055.png" alt="image-20250509151626055"></p>
<h2 id="LinkedList-双向链表类"><a href="#LinkedList-双向链表类" class="headerlink" title="LinkedList 双向链表类"></a>LinkedList 双向链表类</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250509161904153.png" alt="image-20250509161904153"></p>
<h2 id="栈-数据结构"><a href="#栈-数据结构" class="headerlink" title="栈 数据结构"></a>栈 数据结构</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250509162034647.png" alt="image-20250509162034647"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250509162149438.png" alt="image-20250509162149438"></p>
<h2 id="队列-数据结构"><a href="#队列-数据结构" class="headerlink" title="队列 数据结构"></a>队列 数据结构</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250509163049904.png" alt="image-20250509163049904"></p>
<p>入队：offer</p>
<p>出队：poll</p>
<h2 id="三种Set"><a href="#三种Set" class="headerlink" title="三种Set"></a>三种Set</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250509164743958.png" alt="image-20250509164743958"></p>
<p>map和set的关系</p>
<p>map是键值对，把键那一列单独拿出来，就是set集合。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250509165852628.png" alt="image-20250509165852628"></p>
<h3 id="Map-接口的常用方法"><a href="#Map-接口的常用方法" class="headerlink" title="Map 接口的常用方法"></a>Map 接口的常用方法</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250509193744059.png" alt="image-20250509193744059"></p>
<h3 id="Map-集合的遍历"><a href="#Map-集合的遍历" class="headerlink" title="Map 集合的遍历"></a>Map 集合的遍历</h3><h4 id="方法一：获取Map集合的所有key，然后遍历每个key，通过key获取value"><a href="#方法一：获取Map集合的所有key，然后遍历每个key，通过key获取value" class="headerlink" title="方法一：获取Map集合的所有key，然后遍历每个key，通过key获取value"></a>方法一：获取Map集合的所有key，然后遍历每个key，通过key获取value</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; keys = maps.keySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">Iterator&lt;Integer&gt; it = keys.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">	System.out.println(key + <span class="string">&quot;=&quot;</span> + maps.get(key))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">for</span>(Integer key : keys)&#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;=&quot;</span> + maps.get(key))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="方法二：获取Map的内部类Map-Entry-效率更高，常用这个"><a href="#方法二：获取Map的内部类Map-Entry-效率更高，常用这个" class="headerlink" title="方法二：获取Map的内部类Map.Entry (效率更高，常用这个)"></a>方法二：获取Map的内部类Map.Entry (效率更高，常用这个)</h4><p>不需要再通过key去找value了</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250509195622488.png" alt="image-20250509195622488"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> entries.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;Integer,String&gt; entry = it.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer,String&gt; entry : entries)&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="哈希表存储原理"><a href="#哈希表存储原理" class="headerlink" title="哈希表存储原理"></a>哈希表存储原理</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250509210206127.png" alt="image-20250509210206127"></p>
<h4 id="！！hashCode和equals方法要同时重写"><a href="#！！hashCode和equals方法要同时重写" class="headerlink" title="！！hashCode和equals方法要同时重写"></a>！！hashCode和equals方法要同时重写</h4><p>使用equals的前提条件是两个元素计算得到的索引值是相同的，在同一个链表中。那么保证这两个元素使用hashCode()返回的结果是相同的才能准确的保证索引值相同。</p>
<p><strong>因此，存放在HashMap集合key部分的元素，以及存放在HashSet集合中的元素，需要同时重写hashCode和equals方法</strong></p>
<h4 id="HashMap在Java8后的改进"><a href="#HashMap在Java8后的改进" class="headerlink" title="HashMap在Java8后的改进"></a>HashMap在Java8后的改进</h4><h5 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a>初始化时机</h5><p>java8之前，构造方法执行初始化table数组</p>
<p>java8之后，第一次调用put方法时初始化table数组</p>
<h5 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h5><p>java8之前：头插法</p>
<p>java8之后：尾插法</p>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>java8之前：数组+单向链表</p>
<p>java8之后：数组+单向链表&#x2F;红黑树</p>
<ul>
<li>如果结点数量&gt;&#x3D;8，且table长度&gt;&#x3D;64，单向链表转为红黑树</li>
<li>当删除红黑树上的结点，使节点数量&lt;&#x3D;6时，红黑树转换为单向链表</li>
</ul>
<h4 id="HashMap的容量永远是2的次幂"><a href="#HashMap的容量永远是2的次幂" class="headerlink" title="HashMap的容量永远是2的次幂"></a>HashMap的容量永远是2的次幂</h4><p>原因：</p>
<ol>
<li><p>提高哈希计算的效率（位运算的效率比%取模运算效率高）</p>
<p>当length为2的次幂时,length-1的二进制低位全是1，此时<code>hash &amp; (length - 1)</code> 相当于 <strong>保留 <code>hash</code> 的低 <code>n</code> 位</strong>，结果与<code>hash%length</code>一致，使用位运算效率更高。</p>
</li>
<li><p>减少哈希冲突，让散列分布更加均匀</p>
<p>假设length是偶数，length-1结果一定是奇数，它的二进制中的最后一位一定是1，和别人相与可能是0或1。如果length是奇数，length-1是偶数，那么二进制最后一位是0，和别人相与只能是0，那么最后table有一半都是空的，存不了东西。</p>
</li>
</ol>
<h4 id="HashMap的初始化容量设置"><a href="#HashMap的初始化容量设置" class="headerlink" title="HashMap的初始化容量设置"></a>HashMap的初始化容量设置</h4><ol>
<li>当哈希表中的元素越来越多时，散列碰撞的几率就会越来越高，导致单链表过长，降低了哈希表的性能，此时要进行哈希表扩容</li>
<li>而一旦进行扩容，由于length改变，所有元素的hash值都会改变，效率比较低，所以在初始化的时候最好设置好数组大小，避免过多次数的扩容。</li>
<li>扩容时间点：当哈希表中的元素个数超过<code>数组大小*0.75</code>后进行扩容，新数组大小为<code>2*原数组大小</code></li>
</ol>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ol>
<li>LinkedHashMap是HashMap集合的子类</li>
<li>用法和HashMap几乎一样</li>
<li>只不过LinkedHashMap可以保证元素的插入顺序</li>
<li>底层数据结构：哈希表+双向链表（记录顺序）</li>
</ol>
<p><img src="https://pic.ericzht.space/PicGo/image-20250511152438610.png" alt="image-20250511152438610"></p>
<h3 id="Hashtable（效率低，不常用）"><a href="#Hashtable（效率低，不常用）" class="headerlink" title="Hashtable（效率低，不常用）"></a>Hashtable（效率低，不常用）</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250511153454341.png" alt="image-20250511153454341"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250511154424681.png" alt="image-20250511154424681"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250511154408581.png" alt="image-20250511154408581"></p>
<h3 id="Properties-属性类"><a href="#Properties-属性类" class="headerlink" title="Properties 属性类"></a>Properties 属性类</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250511155031484.png" alt="image-20250511155031484"></p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><h4 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h4><p>按照左小右大存储，按照中序遍历自动得到升序排列的元素。</p>
<p>缺点：如果插入的节点集本来就是有序的，那么最后得到的二叉树其实就是一个普通链表，检索效率很差。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250511155728257.png" alt="image-20250511155728257"></p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250511160248989.png" alt="image-20250511160248989"></p>
<h4 id="红黑二叉树"><a href="#红黑二叉树" class="headerlink" title="红黑二叉树"></a>红黑二叉树</h4><p>一棵自平衡的排序二叉树</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>一个是没有参数的，一个是需要传比较器的</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h4><p>先调用比较器，如果比较器是NULL，就使用类中的compareTo方法进行比较。</p>
<p>因此有两种方式来修改比较方法。</p>
<p><strong>法一：</strong>实现Comparable&lt;&gt;接口，并重写compareTo方法</p>
<p><strong>适用于比较规则不会改变的情况</strong>，比如数字、字符串的比较</p>
<p><strong>法二：</strong>再写一个类去实现Comparator&lt;&gt;接口，重写compare方法，在创建对象时将比较器传递给TreeMap</p>
<p>适用于比较规则会改变的情况</p>
<h3 id="总结：哪些集合不能添加NULL"><a href="#总结：哪些集合不能添加NULL" class="headerlink" title="总结：哪些集合不能添加NULL"></a>总结：哪些集合不能添加NULL</h3><ul>
<li><p>Hashtable的key、value</p>
</li>
<li><p>Properties的key、value</p>
</li>
<li><p>TreeMap的key</p>
</li>
</ul>
<p>​        -&gt; TreeSet不能添加null</p>
<h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250512120540553.png" alt="image-20250512120540553"></p>
<h1 id="八、IO流"><a href="#八、IO流" class="headerlink" title="八、IO流"></a>八、IO流</h1><h2 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="根据流向分"><a href="#根据流向分" class="headerlink" title="根据流向分"></a>根据流向分</h4><p>输入流（read）、输出流（write）</p>
<h4 id="根据读写数据的形式分"><a href="#根据读写数据的形式分" class="headerlink" title="根据读写数据的形式分"></a>根据读写数据的形式分</h4><ul>
<li><p>字节流：<strong>一次读取一个字节</strong>。适合读取非文本数据，比如图片、音频、视频等。</p>
</li>
<li><p>字符流：<strong>一次读取一个字符</strong>。只适合读取普通文本，不适合读取二进制文件。因为字符流统一使用Unicode编码，可以避免出现编码混乱的问题。</p>
</li>
</ul>
<h4 id="根据流在IO操作中的作用和实现方式分"><a href="#根据流在IO操作中的作用和实现方式分" class="headerlink" title="根据流在IO操作中的作用和实现方式分"></a>根据流在IO操作中的作用和实现方式分</h4><ul>
<li>节点流：负责数据源和数据目的地的连接，是IO中最基本的组成部分。</li>
<li>处理流：处理流对节点流进行装饰&#x2F;包装，提供更多高级处理操作，方便用户进行数据处理。</li>
</ul>
<h3 id="IO流体系结构"><a href="#IO流体系结构" class="headerlink" title="IO流体系结构"></a>IO流体系结构</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250512150234321.png" alt="image-20250512150234321"></p>
<p>InputStream 字节输入流</p>
<p>OutputStream 字节输出流</p>
<p>Reader 字符输入流</p>
<p>Writer 字符输出流</p>
<ul>
<li><p>所有流都实现了Closable接口，都有<code>close()</code>方法，流用完要关闭。</p>
</li>
<li><p>所有的输出流都实现了Flushable，都有<code>flush()</code>方法，flush方法的作用是，将缓存全部写出并清空。</p>
</li>
</ul>
<h2 id="FileInputStream-类"><a href="#FileInputStream-类" class="headerlink" title="FileInputStream 类"></a>FileInputStream 类</h2><p>称为文件字节输入流，是一个万能流，任何文件都能读，但还是建议读二进制文件，例如图片、声音、视频。</p>
<h3 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h3><p><code>FileInputStream(String name)</code>通过文件路径构建一个文件字节输入流对象。</p>
<p>注意: 反斜杠需要使用转义字符，即两个反斜杠 <code>\\</code></p>
<p>也可使用一个正的斜杠 <code>/</code></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="int-read"><a href="#int-read" class="headerlink" title="int read();"></a>int read();</h4><p>调用一次read()方法就读取一个字节，返回读到的字节本身。如果读不到任何数据则返回-1</p>
<h4 id="int-read-byte-b"><a href="#int-read-byte-b" class="headerlink" title="int read(byte[] b);"></a>int read(byte[] b);</h4><p>一次最多可以读到b.length个字节（只要文件内容足够多），返回值是读取到的字节数。读取的内容存在b数组中。</p>
<h4 id="int-read-byte-b-int-off-int-len"><a href="#int-read-byte-b-int-off-int-len" class="headerlink" title="int read(byte[] b, int off, int len);"></a>int read(byte[] b, int off, int len);</h4><p>一次读取len个字节，将读到的数据从byte数组的off位置开始放</p>
<h4 id="long-skip-long-n"><a href="#long-skip-long-n" class="headerlink" title="long skip(long n);"></a>long skip(long n);</h4><p>跳过n个字节</p>
<h4 id="int-available"><a href="#int-available" class="headerlink" title="int available();"></a>int available();</h4><p>获取流中剩余的预估计字节数。</p>
<p>可以用这个初始化数组长度，这样就不需要使用循环来判断是否还有可读取的内容。</p>
<h4 id="void-close-；"><a href="#void-close-；" class="headerlink" title="void close()；"></a>void close()；</h4><p>关闭流</p>
<h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>文件字节输出流，负责写。</p>
<h3 id="常用构造方法-1"><a href="#常用构造方法-1" class="headerlink" title="常用构造方法"></a>常用构造方法</h3><ol>
<li>FileOutputStream(String name) 创建一个文件字节输出流对象，这个流在使用时，会先将原文件内容全部清空，然后写入。</li>
<li>FileOutputStream(String name, boolean append)</li>
</ol>
<p>​		创建一个文件字节输出流对象，当append是true时，不会清空原文件的内容，在原文件末尾追加。</p>
<p>​		当append是false时，会清空原文件的内容，在原文件末尾追加。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="void-close"><a href="#void-close" class="headerlink" title="void close();"></a>void close();</h4><h4 id="void-flush"><a href="#void-flush" class="headerlink" title="void flush();"></a>void flush();</h4><p>刷新</p>
<h4 id="void-write-int-b"><a href="#void-write-int-b" class="headerlink" title="void write(int b);"></a>void write(int b);</h4><p>写一个字节</p>
<h4 id="void-write-byte-b"><a href="#void-write-byte-b" class="headerlink" title="void write(byte[] b);"></a>void write(byte[] b);</h4><p>将整个byte字节数组写入</p>
<h4 id="void-write-byte-b-int-off-int-len"><a href="#void-write-byte-b-int-off-int-len" class="headerlink" title="void write(byte[] b, int off, int len);"></a>void write(byte[] b, int off, int len);</h4><p>将byte字节数组的一部分写入</p>
<h2 id="TryWithResources-资源自动关闭-Java7新特性"><a href="#TryWithResources-资源自动关闭-Java7新特性" class="headerlink" title="TryWithResources 资源自动关闭 Java7新特性"></a>TryWithResources 资源自动关闭 Java7新特性</h2><p>凡是实现了AutoCloseable接口的流都可以使用try-with-resources，都会自动关闭。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(   </span><br><span class="line">   声明流;</span><br><span class="line">   声明流;</span><br><span class="line">   声明流;</span><br><span class="line">   声明流)&#123;  <span class="comment">// 最后一个不用写分号</span></span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.ericzht.space/PicGo/image-20250512214659872.png" alt="image-20250512214659872"></p>
<h2 id="FileReader-读取普通文本"><a href="#FileReader-读取普通文本" class="headerlink" title="FileReader 读取普通文本"></a>FileReader 读取普通文本</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250513154453660.png" alt="image-20250513154453660"></p>
<h2 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250513155041546.png" alt="image-20250513155041546"></p>
<p><strong>注意：只能复制普通文本文件！！！</strong></p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>绝对路径、相对路径、<strong>类路径</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;filename&quot;</span>).getPath();</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure>

<p><code>Thread.currentThread()</code> 获取当前线程</p>
<p><code>Thread.currentThread().getContextClassLoader()</code> 获取当前线程的类加载器</p>
<p><code>getResource(&quot;filename&quot;)</code> 从类的根路径下开始加载资源</p>
<p><strong>src文件夹是类路径的根路径</strong></p>
<p>优点：通用，在进行系统移植的时候，仍然可以使用。</p>
<p>注：这种方式只能从类路径中加载资源，如果这个资源在类路径之外，就无法访问到。</p>
<h2 id="BufferedInputStream-BufferedOutputStream"><a href="#BufferedInputStream-BufferedOutputStream" class="headerlink" title="BufferedInputStream&#x2F;BufferedOutputStream"></a>BufferedInputStream&#x2F;BufferedOutputStream</h2><h3 id="对缓冲流的理解"><a href="#对缓冲流的理解" class="headerlink" title="对缓冲流的理解"></a>对缓冲流的理解</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250514101835840.png" alt="image-20250514101835840"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250514103000835.png" alt="image-20250514103000835"></p>
<p><strong>1️⃣为什么这里仍然需要使用数组呢？</strong></p>
<p>这个数组是接收缓冲区中的大数组中的内容，它本身不和文件进行交互。</p>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p><code>mark()</code> 在当前位置打上标记</p>
<p><code>reset()</code> 回到<strong>上一次</strong>打标记的位置</p>
<p><strong>一个文件中最多只有一个标记</strong></p>
<p>调用顺序：先调用mark，再调用reset</p>
<h2 id="如何解决乱码问题"><a href="#如何解决乱码问题" class="headerlink" title="如何解决乱码问题"></a>如何解决乱码问题</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250514111017372.png" alt="image-20250514111017372"></p>
<blockquote>
<p><em>所有输入输出底层都需要使用字节流，而字符流是将字节流包装后得到的。进行了这种包装操作的流叫包装流。</em></p>
</blockquote>
<ul>
<li><p>使用InputStreamReader&#x2F;OutputStreamWriter时可以指定解码的字符集。</p>
</li>
<li><p>常用构造方法：</p>
<ol>
<li><code>InputStreamReader(InputStream in)</code> 采用平台默认的字符集进行解码</li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code> 采用指定的字符集进行解码</li>
</ol>
</li>
<li><p>FileReader是InputStreamReader的子类，是一个包装流。</p>
</li>
</ul>
<p>​		FileWriter同理。</p>
<ul>
<li>InputStreamReader&#x2F;OutputStreamWriter 的创建需要传入字节流，而FileReader&#x2F;FileWriter 的创建直接输入文件地址即可。</li>
</ul>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><ul>
<li><p>将java程序中的数据直接写入文件，写进去就是二进制。</p>
</li>
<li><p>效率很高——写的过程不用转码</p>
</li>
<li><p>DataOutputStream写到文件中的数据，只能由DataInputStream来读取</p>
</li>
<li><p>读取顺序必须按照写入顺序！</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入</span></span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;filename&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">222</span>;</span><br><span class="line"></span><br><span class="line">dos.writeByte(b1);</span><br><span class="line">dos.writeShort(s1);</span><br><span class="line"></span><br><span class="line">dos.flush();</span><br><span class="line">dos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;filename&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> dis.readByte();</span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> dis.readShort();</span><br><span class="line">dis.close();</span><br></pre></td></tr></table></figure>

<h2 id="对象的序列化与反序列化"><a href="#对象的序列化与反序列化" class="headerlink" title="对象的序列化与反序列化"></a>对象的序列化与反序列化</h2><p>序列化：将对象变成二进制文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"><span class="type">Date</span> <span class="variable">nowDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 序列化Serial</span></span><br><span class="line">oos.writeObject(nowTime); </span><br><span class="line"></span><br><span class="line">oos.flush();</span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>



<p>反序列化：将字节序列转换成JVM中的java对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject(); <span class="comment">// 如果明确知道对象的类型，可以强转。</span></span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure>

<p>如果是多个对象，那就把这些对象放在集合中。</p>
<p>要参与序列化与反序列化的对象，<strong>必须实现 <code>java.io.Serializable</code> 接口</strong>。该接口是一个标志接口，没有任何方法。</p>
<ul>
<li>ObjectOutputStream也有关于数据输出的方法，比如<code>writeInt()</code>、<code>writeBoolean()</code>等，和DataOutputStream中的方法一样。</li>
</ul>
<h3 id="序列化版本号"><a href="#序列化版本号" class="headerlink" title="序列化版本号"></a>序列化版本号</h3><ul>
<li><p>为了保证序列化的安全，只有同一个类的对象才能序列化和反序列化。在java中 通过 类名 + 序列化版本号（serialVersionUID）来判断。</p>
</li>
<li><p>当类的内容修改后，serialVersionUID会改变，java程序不允许序列化版本号不同的类进行反序列化。</p>
</li>
<li><p>那如果几个月后，对这个类进行了升级，增加了一些内容怎么办？</p>
</li>
</ul>
<p>​		如果确定这个类确实是之前的那个类，类本身是合法的，可以将序列化版本号<strong>写死</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1231231231231L</span>;</span><br></pre></td></tr></table></figure>

<h3 id="serial注解"><a href="#serial注解" class="headerlink" title="serial注解"></a>serial注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serial</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serial</span> <span class="comment">// 会自动检查下面的序列号代码是否拼错，在这里alt+回车可以自动生成一个序列号版本。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1231231231231L</span>;</span><br></pre></td></tr></table></figure>

<h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><p>transient关键字修饰的属性不会参与序列化。</p>
<p>所以进行反序列化的时候这个属性会赋默认值。</p>
<h2 id="打印流-PrintStream-PrintWriter"><a href="#打印流-PrintStream-PrintWriter" class="headerlink" title="打印流 PrintStream&#x2F;PrintWriter"></a>打印流 PrintStream&#x2F;PrintWriter</h2><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><p>主要用于打印，提供便携的打印方法和格式化输出。主要打印内容到文件或控制台。</p>
<p>不需要手动刷新。</p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>PrintStream(OutputStream out);</code></p>
<p><code>PrintStream(String filename);</code></p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><p><code>print(Type x);</code></p>
<p><code>println(Type x);</code></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250514160807745.png" alt="image-20250514160807745"></p>
<h3 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h3><p>比PrintStream多一个构造方法：<code>PrintWriter(Writer);</code></p>
<h2 id="标准输入流-System-in"><a href="#标准输入流-System-in" class="headerlink" title="标准输入流 System.in"></a>标准输入流 System.in</h2><p>用来接收用户在控制台上的输入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> System.in;</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> in.read(bytes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; readCount; i++)&#123;</span><br><span class="line">    System.out.println(bytes[i]); <span class="comment">// 这个是逐个输出每个字节的内容，不适合中文等内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于标准输入流来说，也可以改变数据源。不让其从控制台读数据，而是从文件中&#x2F;网络中读取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改标准输入流的数据源</span></span><br><span class="line">System.setIn(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> System.in;</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((readCount = in.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,readCount));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="标准输出流-System-out"><a href="#标准输出流-System-out" class="headerlink" title="标准输出流 System.out"></a>标准输出流 System.out</h2><p>用于输出内容到控制台。</p>
<p>改变输出方向：(常用于记录日志)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;zhangsan&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>文件&#x2F;目录的抽象表示形式。</p>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:/filename&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不存在就以新文件的形式创建</span></span><br><span class="line"><span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不存在就以目录的形式创建</span></span><br><span class="line"><span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">    file.mkdir();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不存在就创建多层文件夹</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:/a/b/c/d&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!file2.exist())&#123;</span><br><span class="line">    file2.mkdirs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见方法见文档。"><a href="#常见方法见文档。" class="headerlink" title="常见方法见文档。"></a>常见方法见文档。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:/directoryAddress&quot;</span>);</span><br><span class="line">File[] files = file.listFiles() <span class="comment">// 直接获取所有文档</span></span><br><span class="line">File[] files2 = file.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>())&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.txt&quot;</span>); <span class="comment">// 进行判断，如果结果不是txt就返回false，就不选中这些文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读取属性配置文件"><a href="#读取属性配置文件" class="headerlink" title="读取属性配置文件"></a>读取属性配置文件</h2><ul>
<li>xxx.properties 文件称为属性配置文件</li>
<li>属性配置文件可以配置一些简单的信息，例如连接数据库的信息通常配置到属性文件中。这样可以做到在不修改java代码的前提下，切换数据库。</li>
<li>属性配置文件的格式:</li>
</ul>
<p>​		key1 &#x3D; value1</p>
<p>​		key2 &#x3D; value2</p>
<p>​		…</p>
<p>​		注：使用#进行注释，key不能重复，否则value会被覆盖。等号两边不能有空格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;filename&quot;</span>).getPath();</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(path);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建一个Map集合（属性类对象） </span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性配置文件中的配置信息加载到Properties对象中。</span></span><br><span class="line">pro.load(reader) </span><br><span class="line">    </span><br><span class="line"><span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="ResourceBundle进行资源绑定"><a href="#ResourceBundle进行资源绑定" class="headerlink" title="ResourceBundle进行资源绑定"></a>ResourceBundle进行资源绑定</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250514215334331.png" alt="image-20250514215334331"></p>
<h2 id="装饰器设计模式"><a href="#装饰器设计模式" class="headerlink" title="装饰器设计模式"></a>装饰器设计模式</h2><p>符合OCP的情况下怎么完成对类功能的扩展？</p>
<ul>
<li>使用子类对父类进行方法扩展。但这种方法会导致两个问题：代码耦合度高、类爆炸问题（会有很多类）</li>
<li>装饰器设计模式：可以做到在不修改原有代码的基础上，完成功能扩展，符合OCP原则，并且避免了使用继承带来的类爆炸问题。</li>
</ul>
<p>装饰器设计模式中涉及的角色：</p>
<ol>
<li>抽象的装饰者</li>
<li>具体的装饰者1、具体的装饰者2</li>
<li>被装饰者</li>
<li>装饰者和被装饰者的公共接口&#x2F;公共抽象类</li>
</ol>
<p><strong>IO流中使用了大量的装饰器设计模式。</strong></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250515164725487.png" alt="image-20250515164725487"></p>
<h2 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h2><h3 id="压缩流的使用"><a href="#压缩流的使用" class="headerlink" title="压缩流的使用"></a>压缩流的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GZIPOutputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件字节输入流（读某个文件，这个文件将来就是被压缩的。）</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;e:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个GZIP压缩流对象</span></span><br><span class="line">        <span class="type">GZIPOutputStream</span> <span class="variable">gzip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;e:/test.txt.gz&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始压缩（一边读一边写）</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((readCount = in.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            gzip.write(bytes, <span class="number">0</span>, readCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非常重要的代码需要调用</span></span><br><span class="line">        <span class="comment">// 刷新并且最终生成压缩文件。</span></span><br><span class="line">        gzip.finish();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭流</span></span><br><span class="line">        in.close();</span><br><span class="line">        gzip.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解压缩流的使用"><a href="#解压缩流的使用" class="headerlink" title="解压缩流的使用"></a>解压缩流的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GZIPInputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建GZIP解压缩流对象</span></span><br><span class="line">        <span class="type">GZIPInputStream</span> <span class="variable">gzip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;e:/test.txt.gz&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件字节输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;e:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一边读一边写</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((readCount = gzip.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes, <span class="number">0</span>, readCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭流</span></span><br><span class="line">        gzip.close();</span><br><span class="line">        <span class="comment">// 节点流关闭的时候会自动刷新，包装流是需要手动刷新的。</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：节点流关闭时会自动刷新，包装流需要手动刷新。</strong></p>
<h2 id="字节数组流"><a href="#字节数组流" class="headerlink" title="字节数组流"></a>字节数组流</h2><ol>
<li>ByteArrayInputStream、ByteArrayOutputStream都是内存操作流，不需要打开和关闭文件等操作。这些流是非常常用的，可以将它们看作开发中的常用工具，能够方便地读写字节数组、图像数据等内存中的数据。</li>
<li>都是节点流。</li>
</ol>
<p><img src="https://pic.ericzht.space/PicGo/image-20250516105141032.png" alt="image-20250516105141032"></p>
<h3 id="使用对象流装饰字节数组流"><a href="#使用对象流装饰字节数组流" class="headerlink" title="使用对象流装饰字节数组流"></a>使用对象流装饰字节数组流</h3><p><strong>！！为什么要这样做？</strong></p>
<p>你使用字节数组流直接写入、读出可能只能读取普通的字节数组，还需要自己实现一些转换成复杂类型（各种类）的方法，而包装流已经在内部包含了很多将复杂类型序列化的方法，<strong>一行代码就可以帮你直接序列化复杂类型然后写入字节流</strong>。</p>
<h2 id="对象深克隆"><a href="#对象深克隆" class="headerlink" title="对象深克隆"></a>对象深克隆</h2><p>目前为止对象拷贝方式：</p>
<ol>
<li>调用Object的clone方法，默认是浅克隆，需要深克隆的话，就需要重写clone方法</li>
<li>可以通过序列化和反序列化完成对象的克隆（深克隆）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCloneTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 准备对象</span></span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;朝阳&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>, addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将Java对象写到一个byte数组中。</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(user);</span><br><span class="line"></span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从byte数组中读取数据恢复java对象</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这就是那个经过深拷贝之后的新对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line"></span><br><span class="line">        user2.getAddr().setCity(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="九、多线程"><a href="#九、多线程" class="headerlink" title="九、多线程"></a>九、多线程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ol>
<li>进程：操作系统中的一段程序，具有独立的内存空间和系统资源，如文件、网络端口等。在计算机程序执行时，先创建进程，再在进程中进行程序的执行。</li>
<li>线程：进程中的一个执行单元。每个线程都有自己的栈和程序计数器，并且可以共享进程的资源。多个线程可以在同一时刻执行不同操作，提高程序的执行效率。一个进程可以有多个线程。</li>
<li>静态变量、实例变量是在堆中的，所以是共享的。</li>
</ol>
<p><img src="https://pic.ericzht.space/PicGo/image-20250516141939273.png" alt="image-20250516141939273"></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>使用单核CPU时，同一时刻只能有一条指令执行，但多个指令被快速的轮换执行，使得在宏观上具有多个指令同时执行的效果。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250516143428949.png" alt="image-20250516143428949"></p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>多核CPU，同一时刻，多条指令在多个CPU上同时执行。（无论微观还是宏观）</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250516143534577.png" alt="image-20250516143534577"></p>
<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ol>
<li>CPU比较繁忙时，如果开启了多个线程，则只能为一个线程分配仅有的CPU资源，多线程会竞争CPU资源。</li>
<li>在CPU资源比较充足时，一个进程内的多个线程可以被分配到不同的CPU资源，实现并行。</li>
</ol>
<p><strong>多线程实现的是并发还是并行？</strong>如上所述，看运行时CPU的资源，<strong>都有可能</strong>。</p>
<h3 id="线程的调度模型"><a href="#线程的调度模型" class="headerlink" title="线程的调度模型"></a>线程的调度模型</h3><p>多个线程抢夺一个CPU内核的执行权，需要线程调度策略。</p>
<h4 id="分时调度模型"><a href="#分时调度模型" class="headerlink" title="分时调度模型"></a>分时调度模型</h4><p>所有线程轮流使用CPU的执行权，并且平均分配每个线程占用的CPU时间</p>
<h4 id="抢占式调度模型"><a href="#抢占式调度模型" class="headerlink" title="抢占式调度模型"></a>抢占式调度模型</h4><p>让优先级高的线程以较大的概率优先获得CPU的执行权，如果线程的优先级相同，那么就随机选择一个线程获得CPU的执行权。</p>
<p><strong>JAVA采用的就是抢占式调度。</strong></p>
<h2 id="实现多线程的方法"><a href="#实现多线程的方法" class="headerlink" title="实现多线程的方法"></a>实现多线程的方法</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><ol>
<li>编写一个类继承java.lang.Thread</li>
<li>重写run方法</li>
<li>new线程对象</li>
<li>调用线程对象的start()方法来启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        </span><br><span class="line">        mt.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        多线程执行的内容;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>start方法的任务是启动一个新线程，分配一个新的栈空间就结束了。</p>
<p><strong>java永远满足一个语法规则：必须自上而下依次逐行运行。</strong></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250516145644299.png" alt="image-20250516145644299"></p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><ol>
<li>编写一个类实现java.lang.Runnable接口</li>
<li>实现接口中的run方法 （此处不能thorws异常）</li>
<li>new线程对象（把实现Runnable接口的类传给Thread构造方法）</li>
<li>调用线程对象的start()方法来启动线程</li>
</ol>
<p><strong>这种方式更好，因为以后还可以继承别的类。</strong>而第一种已经使用掉继承一个类的名额了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        多线程执行的内容;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式还可以使用匿名内部类：</p>
<p>1. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                多线程执行的内容;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                多线程执行的内容;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程常用的三个方法"><a href="#线程常用的三个方法" class="headerlink" title="线程常用的三个方法"></a>线程常用的三个方法</h2><ol>
<li>String getName()； 获取线程对象的名字</li>
<li>void setName(String threadName); 修改线程的名字</li>
<li>static Thread currentThread(); 获取当前线程对象的引用</li>
</ol>
<p>除了使用setName修改线程的名字，还可以使用有参构造方法。但是需要在类中实现这个有参构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String threadName)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(threadName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程生命周期的7个状态"><a href="#线程生命周期的7个状态" class="headerlink" title="线程生命周期的7个状态"></a>线程生命周期的7个状态</h2><ol>
<li>新建状态 NEW</li>
<li>就绪状态 </li>
<li>运行状态 （2-3 官方统称为可运行状态RUNNABLE）</li>
<li>超时等待状态 TIMED_WAITING</li>
<li>等待状态 WAITING</li>
<li>阻塞状态 BLOCKED</li>
<li>终止状态 TERMINATED</li>
</ol>
<p><img src="https://pic.ericzht.space/PicGo/image-20250517163614959.png" alt="image-20250517163614959"></p>
<h2 id="线程的休眠"><a href="#线程的休眠" class="headerlink" title="线程的休眠"></a>线程的休眠</h2><p>Thread.sleep(毫秒数);</p>
<p>在规定的时间内，当前线程没有权利抢夺CPU时间片了。</p>
<h2 id="中断线程的休眠"><a href="#中断线程的休眠" class="headerlink" title="中断线程的休眠"></a>中断线程的休眠</h2><ul>
<li><p>interrupt()是一个实例方法。</p>
</li>
<li><p><code>线程对象.interrupt();</code>可以中断线程的休眠。（当然要放在另一个线程里使用才能起作用）</p>
</li>
<li><p>底层原理是利用了异常处理机制。</p>
<p>当调用这个方法的时候，如果t线程正在睡眠，必然会抛出：InterrupttedException，然后捕捉异常，终止睡眠。</p>
</li>
</ul>
<h2 id="停止运行线程"><a href="#停止运行线程" class="headerlink" title="停止运行线程"></a>停止运行线程</h2><p><em>线程对象.stop() 已经不建议使用</em></p>
<p>一般是设置一个标记，然后在线程的循环中使用if语句判断这个标记。</p>
<p>比如 boolean run &#x3D; true; 当达到某个条件后将run改为false，然后if(run){ 运行的内容 } else{return;} </p>
<p>return后就终止这个线程了。</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>在java中，线程被分为两类：守护线程、用户线程</p>
<ul>
<li><p>所有用户线程结束后，守护线程自动退出&#x2F;结束。</p>
</li>
<li><p>在JVM中，有一个隐藏的守护线程一直在守护着，它就是GC线程。</p>
</li>
</ul>
<p><strong>将线程设置为守护线程：</strong></p>
<p><code>线程对象.setDaemon(true);</code></p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>java.util.Timer 定时器</p>
<p>java.util.TimerTask 定时任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建定时器对象（本质上就是一个线程）</span></span><br><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="literal">true</span>); <span class="comment">// 这里的true表示设置为守护线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定定时任务SimpleDateFormat </span></span><br><span class="line">sdf = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">firstTime</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2024-01-27 10:22:00&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名内部类的方式</span></span><br><span class="line">timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 执行任务</span></span><br><span class="line">                <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">                <span class="type">String</span> <span class="variable">strTime</span> <span class="operator">=</span> sdf.format(now);</span><br><span class="line">                System.out.println(strTime + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;,firstTime,<span class="number">1000</span>*<span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<h2 id="线程合并"><a href="#线程合并" class="headerlink" title="线程合并"></a>线程合并</h2><p>join() 方法是一个实例方法  </p>
<p><code>t.join()</code> 是让当前线程进入阻塞状态，直到t线程结束，当前线程的阻塞状态结束。</p>
<p>个人理解：就是先让t线程打断当前线程自己运行，如果<strong>设置的时间结束</strong>或者<strong>t线程在时间结束前已经运行完了</strong>，那当前线程就继续执行。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250517113216785.png" alt="image-20250517113216785"></p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>最低1(<code>Thread.MIN_PRIORITY</code>)，最高10(<code>Thread.MAX_PRIORITY</code>)</p>
<p>t.setPriority(传入优先级数值)</p>
<h2 id="让位"><a href="#让位" class="headerlink" title="让位"></a>让位</h2><p>静态方法：<code>Thread.yield()</code></p>
<p>让当前线程让位。让位不会让其进入阻塞状态，只是放弃当前占有的CPU时间片，进入就绪状态，继续抢夺CPU时间片。</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="什么情况下需要考虑线程安全问题？"><a href="#什么情况下需要考虑线程安全问题？" class="headerlink" title="什么情况下需要考虑线程安全问题？"></a>什么情况下需要考虑线程安全问题？</h3><ol>
<li>多线程并发</li>
<li>有共享的数据</li>
<li>共享数据涉及修改操作</li>
</ol>
<h3 id="一般情况下"><a href="#一般情况下" class="headerlink" title="一般情况下"></a>一般情况下</h3><p>局部变量不存在线程安全问题。（尤其是基本数据类型，但如果是引用数据类型就另说了。）</p>
<p>实例变量、静态变量可能存在线程安全问题。他们存放在堆中，堆是多线程共享的。</p>
<h3 id="线程同步机制——互斥锁"><a href="#线程同步机制——互斥锁" class="headerlink" title="线程同步机制——互斥锁"></a>线程同步机制——互斥锁</h3><p><strong>线程排队执行</strong></p>
<p>现有t1和t2线程，t1线程在执行的时候必须等待t2线程执行到某个位置之后，t1线程才能执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123; <span class="comment">// obj为共享对象，在银行取款的例子中，这个共享对象就是账户</span></span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设t1先抢到了CPU时间片，t1线程找到共享对象obj的对象锁后占有这把锁，t2只能在同步代码块之外等待，等t1线程执行完同步代码块之后，才会释放之前占有的对象锁。</p>
<p><strong>synchronized又被称为互斥锁。</strong></p>
<p>synchronized也可以作为标识符直接写在方法（实例方法、静态方法）声明上，</p>
<p>静态方法检测的是类锁，实例方法检测的是对象锁。</p>
<h3 id="线程异步机制"><a href="#线程异步机制" class="headerlink" title="线程异步机制"></a>线程异步机制</h3><p><strong>线程并发执行</strong></p>
<p>各自执行各自的，谁也不需要等对方。</p>
<p>效率高但可能存在安全隐患。</p>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><h3 id="涉及到的三个方法："><a href="#涉及到的三个方法：" class="headerlink" title="涉及到的三个方法："></a>涉及到的三个方法：</h3><p><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code></p>
<ul>
<li>以上三个方法都是Object类的方法。</li>
</ul>
<p><img src="https://pic.ericzht.space/PicGo/image-20250518151102310.png" alt="image-20250518151102310"></p>
<ul>
<li>调用wait方法和notify方法是<strong>通过共享对象去调用</strong>的。</li>
</ul>
<p>例如：obj.wait()的效果：在obj对象上活跃的<strong>所有线程</strong>进入无期限等待，直到调用了该共享对象的notify方法进行唤醒，唤醒后会接着上一次调用wait方法的位置继续执行。</p>
<ul>
<li>obj.wait() 调用后会释放之前占用的对象锁。</li>
<li>obj.notify() 唤醒优先级最高的等待线程，如果优先级一样，就随机唤醒一个。</li>
<li>obj.notifyAll() 唤醒所有在该共享对象上等待的线程</li>
</ul>
<p><img src="https://pic.ericzht.space/PicGo/image-20250518154905701.png" alt="image-20250518154905701"></p>
<h2 id="最完整的生命周期"><a href="#最完整的生命周期" class="headerlink" title="最完整的生命周期"></a>最完整的生命周期</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250518155732527.png" alt="image-20250518155732527"></p>
<h2 id="懒汉式单例模式的线程安全问题"><a href="#懒汉式单例模式的线程安全问题" class="headerlink" title="懒汉式单例模式的线程安全问题"></a>懒汉式单例模式的线程安全问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取某个类。这是反射机制中的内容。</span></span><br><span class="line">        <span class="comment">/*Class stringClass = String.class;</span></span><br><span class="line"><span class="comment">        Class singletonClass = Singleton.class;</span></span><br><span class="line"><span class="comment">        Class dateClass = java.util.Date.class;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象t1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                s1 = Singleton.getSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象t2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                s2 = Singleton.getSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断这两个Singleton对象是否一样。</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非线程安全的。</span></span><br><span class="line">    <span class="comment">/*public static Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            singleton = new Singleton();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全的：第一种方案（同步方法），找类锁。</span></span><br><span class="line">    <span class="comment">/*public static synchronized Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            singleton = new Singleton();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全的：第二种方案（同步代码块），找的类锁</span></span><br><span class="line">    <span class="comment">/*public static Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        // 这里有一个知识点是反射机制中的内容。可以获取某个类。</span></span><br><span class="line"><span class="comment">        synchronized (Singleton.class)&#123;</span></span><br><span class="line"><span class="comment">            if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                    throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                singleton = new Singleton();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全的：这个方案对上一个方案进行优化，提升效率。</span></span><br><span class="line">    <span class="comment">/*public static Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        if(singleton == null)&#123;</span></span><br><span class="line"><span class="comment">            synchronized (Singleton.class)&#123;</span></span><br><span class="line"><span class="comment">                if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">                    try &#123;</span></span><br><span class="line"><span class="comment">                        Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">                    &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                        throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    singleton = new Singleton();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lock来实现线程安全</span></span><br><span class="line">    <span class="comment">// Lock是接口，从JDK5开始引入的。</span></span><br><span class="line">    <span class="comment">// Lock接口下有一个实现类：可重入锁（ReentrantLock）</span></span><br><span class="line">    <span class="comment">// 注意：要想使用ReentrantLock达到线程安全，假设要让t1 t2 t3线程同步，就需要让t1 t2 t3共享同一个lock。</span></span><br><span class="line">    <span class="comment">// Lock 和 synchronized 哪个好？Lock更好。为什么？因为更加灵活。synchronized代码块的大括号必须包住所有语句，而unlock()可以任意插入到一些语句中，但一定要记得执行unlock()</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁（需要100%保证解锁，怎么办？finally）</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lock 和 synchronized 哪个好？</strong></p>
<p>Lock更好，因为更加灵活。synchronized代码块的大括号必须包住所有语句，而unlock()可以任意插入到一些语句中，但一定要记得执行unlock()</p>
<h2 id="创建线程的第三种方法——未来任务"><a href="#创建线程的第三种方法——未来任务" class="headerlink" title="创建线程的第三种方法——未来任务"></a>创建线程的第三种方法——未来任务</h2><p>优点：可以拿到线程执行结束的返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建“未来任务”对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 处理业务......</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取“未来任务”线程的返回值</span></span><br><span class="line">            <span class="comment">// 阻塞当前线程，等待“未来任务”结束并返回值。</span></span><br><span class="line">            <span class="comment">// 拿到返回值，当前线程的阻塞才会解除。继续执行。</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> task.get();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建线程的第四种方式——线程池"><a href="#创建线程的第四种方式——线程池" class="headerlink" title="创建线程的第四种方式——线程池"></a>创建线程的第四种方式——线程池</h2><p>服务器启动时，创建N个线程对象，直接放到线程池中，需要的时候把任务交给线程池即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个线程池对象（线程池中有3个线程）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务交给线程池（你不需要触碰到这个线程对象，你只需要将要处理的任务交给线程池即可。）</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后记得关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br></pre></td></tr></table></figure>



<h1 id="十、反射-reflect"><a href="#十、反射-reflect" class="headerlink" title="十、反射 reflect"></a>十、反射 reflect</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>后续学的大量java框架都是基于反射机制实现的。</li>
<li>反射机制可以让程序更加灵活</li>
<li>反射机制最核心的几个类：</li>
</ul>
<p>​		java.lang.Class : Class类型的实例代表硬盘上某个class文件，或者说代表某一种类型</p>
<p>​		java.lang.reflect.Filed : 实例代表类中的属性&#x2F;字段</p>
<p>​		java.lang.reflect.Constructor : 它的实例代表类中的构造方法</p>
<p>​		java.lang.reflect.Method : 它的实例代表类中的方法</p>
<h2 id="获取Class的四种方式"><a href="#获取Class的四种方式" class="headerlink" title="获取Class的四种方式"></a>获取Class的四种方式</h2><h3 id="第一种-1"><a href="#第一种-1" class="headerlink" title="第一种"></a>第一种</h3><p><code>Class c = Class.forName(&quot;完整的全限定类名&quot;);</code></p>
<p>注：</p>
<ol>
<li>全限定类名是带有包名的，不可省略</li>
<li>这是个字符串参数</li>
<li>如果这个类根本不存在，会报异常：<code>java.lang.ClassNotFoundException</code></li>
<li>这个方法的执行会导致类的加载动作的发生</li>
</ol>
<h3 id="第二种-1"><a href="#第二种-1" class="headerlink" title="第二种"></a>第二种</h3><p><code>Class c = obj.getClass();</code></p>
<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p><code>Class c = 类名.class;</code></p>
<h3 id="第四种——使用类加载器"><a href="#第四种——使用类加载器" class="headerlink" title="第四种——使用类加载器"></a>第四种——使用类加载器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; aClass = systemClassLoader.loadClass(<span class="string">&quot;完整的全限定类名&quot;</span>)</span><br></pre></td></tr></table></figure>



<p><code>Class.forName()</code> 和 <code>classLoader.loadClass()</code> 的区别：</p>
<p>​		<code>Class.forName()</code> ：类加载时会进行初始化（静态变量赋值、静态代码块执行）。</p>
<p>​		<code>classLoader.loadClass()</code>：类加载时不会进行初始化，直到第一次使用该类。</p>
<h2 id="通过反射机制实例化对象"><a href="#通过反射机制实例化对象" class="headerlink" title="通过反射机制实例化对象"></a>通过反射机制实例化对象</h2><h3 id="直接对类使用newInstance方法"><a href="#直接对类使用newInstance方法" class="headerlink" title="直接对类使用newInstance方法"></a>直接对类使用newInstance方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;test.User&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)userClass.newInstance();</span><br></pre></td></tr></table></figure>

<p>使用反射机制，只要修改属性配置文件就可以完成不同对象的实例化。非常灵活</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;test.classInfo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;className&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">classObj</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> classObj.newInstance();</span><br></pre></td></tr></table></figure>

<p><strong>使用这种方式必须要有一个无参数构造方法。如果没有会出现异常。</strong></p>
<p><strong>Java9时被标注已过时，不建议使用。</strong></p>
<h3 id="使用构造方法实例化对象"><a href="#使用构造方法实例化对象" class="headerlink" title="使用构造方法实例化对象"></a>使用构造方法实例化对象</h3><p>无参构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;test.User&quot;</span>);</span><br><span class="line"><span class="comment">// 获取无参数构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">defaultCon</span> <span class="operator">=</span> userClass.getDeclaredConstructor();</span><br><span class="line"><span class="comment">// 通过无参数构造方法实例化对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> defaultCon.newInstance();</span><br></pre></td></tr></table></figure>

<p>有参构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;test.User&quot;</span>);</span><br><span class="line"><span class="comment">// 获取有参构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">threeArgsCon</span> <span class="operator">=</span> userClass.getDeclaredConstructor(String.class, <span class="type">double</span>.class, String.class); <span class="comment">// 根据参数的类型，写上对应的类</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> threeArgsCon.newInstance(<span class="string">&quot;001215&quot;</span>, <span class="number">698.5</span>, <span class="string">&quot;未完成&quot;</span>);</span><br></pre></td></tr></table></figure>





<h2 id="通过反射为对象属性赋值"><a href="#通过反射为对象属性赋值" class="headerlink" title="通过反射为对象属性赋值"></a>通过反射为对象属性赋值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.powernode.javase.reflect.Customer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取对应的Field</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法打破封装（原来类里设置的age是private）</span></span><br><span class="line">        ageField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改属性的值</span></span><br><span class="line">        <span class="comment">// 给对象属性赋值三要素：给哪个对象 的 哪个属性 赋什么值</span></span><br><span class="line">        ageField.set(customer, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取属性的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + ageField.get(customer));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射机制给name属性赋值，和读取name属性的值</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 修改属性name的值</span></span><br><span class="line">        nameField.set(customer, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取属性name的值</span></span><br><span class="line">        System.out.println(nameField.get(customer));</span><br></pre></td></tr></table></figure>



<h2 id="反射某一个类的方法"><a href="#反射某一个类的方法" class="headerlink" title="反射某一个类的方法"></a>反射某一个类的方法</h2><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250521121116429.png" alt="image-20250521121116429"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250521121330986.png" alt="image-20250521121330986"></p>
<h2 id="虚拟机的三个类加载器"><a href="#虚拟机的三个类加载器" class="headerlink" title="虚拟机的三个类加载器"></a>虚拟机的三个类加载器</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250521152802090.png" alt="image-20250521152802090"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过自定义的类获取的类加载器是：应用类加载器。</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">appClassLoader</span> <span class="operator">=</span> ReflectTest15.class.getClassLoader();</span><br><span class="line">System.out.println(<span class="string">&quot;应用类加载器：&quot;</span> + appClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取应用类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">appClassLoader2</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(<span class="string">&quot;应用类加载器：&quot;</span> + appClassLoader2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取应用类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">appClassLoader3</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">System.out.println(<span class="string">&quot;应用类加载器：&quot;</span> + appClassLoader3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 getParent() 方法可以获取当前类加载器的 “父 类加载器”。</span></span><br><span class="line"><span class="comment">// 获取平台类加载器。</span></span><br><span class="line">System.out.println(<span class="string">&quot;平台类加载器：&quot;</span> + appClassLoader.getParent());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取启动类加载器。</span></span><br><span class="line"><span class="comment">// 注意：启动类加载器负责加载的是JDK核心类库，这个类加载器的名字看不到，直接输出的时候，结果是null。</span></span><br><span class="line">System.out.println(<span class="string">&quot;启动类加载器：&quot;</span> + 			appClassLoader.getParent().getParent());</span><br></pre></td></tr></table></figure>

<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ol>
<li>某个类加载器接收到加载类的任务时，通常委托给“父 类加载器”进行加载</li>
<li>最大的“父 类加载器”无法加载时，一级一级向下委托加载任务</li>
</ol>
<p>作用：</p>
<ol>
<li>保护程序的安全</li>
<li>防止类加载重复</li>
</ol>
<p><img src="https://pic.ericzht.space/PicGo/image-20250521153555059.png" alt="image-20250521153555059"></p>
<h2 id="获取泛型"><a href="#获取泛型" class="headerlink" title="获取泛型"></a>获取泛型</h2><h3 id="获取父类的泛型"><a href="#获取父类的泛型" class="headerlink" title="获取父类的泛型"></a>获取父类的泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类</span></span><br><span class="line">      Class&lt;Cat&gt; catClass = Cat.class;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取当前类的父类泛型</span></span><br><span class="line">      <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> catClass.getGenericSuperclass();</span><br><span class="line">      <span class="comment">//System.out.println(genericSuperclass instanceof Class);</span></span><br><span class="line">      <span class="comment">//System.out.println(genericSuperclass instanceof ParameterizedType);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果父类使用了泛型</span></span><br><span class="line">      <span class="keyword">if</span>(genericSuperclass <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">          <span class="comment">// 转型为参数化类型</span></span><br><span class="line">          <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">          <span class="comment">// 获取泛型数组</span></span><br><span class="line">          Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">          <span class="comment">// 遍历泛型数组</span></span><br><span class="line">          <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">              <span class="comment">// 获取泛型的具体类型名</span></span><br><span class="line">              System.out.println(a.getTypeName());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取接口的泛型"><a href="#获取接口的泛型" class="headerlink" title="获取接口的泛型"></a>获取接口的泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;Mouse&gt; mouseClass = Mouse.class;</span><br><span class="line">        <span class="comment">// 获取接口上的泛型   类可以单继承、多实现，因此实现一个接口算一个Type，实现多个接口就需要数组了。每个接口上的泛型就是一个Type</span></span><br><span class="line">        Type[] genericInterfaces = mouseClass.getGenericInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Type g : genericInterfaces) &#123;</span><br><span class="line">            <span class="comment">// 使用了泛型</span></span><br><span class="line">            <span class="keyword">if</span>(g <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) g;</span><br><span class="line">                Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">                    System.out.println(a.getTypeName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>&lt;String, Integer&gt;, Comparable&lt;Mouse&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Mouse o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取属性上的泛型"><a href="#获取属性上的泛型" class="headerlink" title="获取属性上的泛型"></a>获取属性上的泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 获取这个类</span></span><br><span class="line">        Class&lt;User&gt; userClass = User.class;</span><br><span class="line">        <span class="comment">// 需要先获取属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">mapField</span> <span class="operator">=</span> userClass.getDeclaredField(<span class="string">&quot;map&quot;</span>); <span class="comment">// 获取公开的以及私有的</span></span><br><span class="line">        <span class="comment">// 获取属性上的泛型</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericType</span> <span class="operator">=</span> mapField.getGenericType();</span><br><span class="line">        <span class="comment">// 用泛型了</span></span><br><span class="line">        <span class="keyword">if</span>(genericType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericType;</span><br><span class="line">            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">                System.out.println(a.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取方法参数、返回值上的泛型"><a href="#获取方法参数、返回值上的泛型" class="headerlink" title="获取方法参数、返回值上的泛型"></a>获取方法参数、返回值上的泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Integer, Integer&gt; <span class="title function_">m</span><span class="params">(List&lt;String&gt; list, List&lt;Integer&gt; list2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 获取类</span></span><br><span class="line">        Class&lt;MyClass&gt; myClassClass = MyClass.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">mMethod</span> <span class="operator">=</span> myClassClass.getDeclaredMethod(<span class="string">&quot;m&quot;</span>, List.class, List.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法参数上的泛型</span></span><br><span class="line">        Type[] genericParameterTypes = mMethod.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type g : genericParameterTypes)&#123;</span><br><span class="line">            <span class="comment">// 如果这个参数使用了泛型</span></span><br><span class="line">            <span class="keyword">if</span>(g <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) g;</span><br><span class="line">                Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">                    System.out.println(a.getTypeName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法返回值上的泛型</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericReturnType</span> <span class="operator">=</span> mMethod.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span>(genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericReturnType;</span><br><span class="line">            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">                System.out.println(a.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取构造方法函数上的泛型"><a href="#获取构造方法函数上的泛型" class="headerlink" title="获取构造方法函数上的泛型"></a>获取构造方法函数上的泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Map&lt;String ,Integer&gt; map)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class&lt;User&gt; userClass = User.class;</span><br><span class="line">        Constructor&lt;User&gt; con = userClass.getDeclaredConstructor(Map.class);</span><br><span class="line">        Type[] genericParameterTypes = con.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type g :genericParameterTypes)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) g;</span><br><span class="line">                Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">                    System.out.println(a.getTypeName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十一、注解"><a href="#十一、注解" class="headerlink" title="十一、注解"></a>十一、注解</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h3><ol>
<li>JDK1.5引入</li>
<li>可以标注在类上、方法上、属性上、构造方法上、方法参数上等……</li>
<li>注解可以做到在不改变代码逻辑的前提下在代码中嵌入补充信息</li>
</ol>
<h3 id="注解与注释"><a href="#注解与注释" class="headerlink" title="注解与注释"></a>注解与注释</h3><p>注解：给编译器或者其他程序看的，程序根据注解来决定不同的处理方式</p>
<p>注释：给程序员看</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>框架 &#x3D; 反射 + 注解 + 设计模式</p>
<h2 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h2><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>用来标记过时的元素，在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的类、过时的方法、过时的属性等。</p>
<h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p>修饰实例方法，则该方法必须是个重写方法，否则就会编译失败。</p>
<h3 id="SuppressWarnings（抑制警告的注解）"><a href="#SuppressWarnings（抑制警告的注解）" class="headerlink" title="@SuppressWarnings（抑制警告的注解）"></a>@SuppressWarnings（抑制警告的注解）</h3><p>在实际开发中，建议尽量不要忽略警告，而是真正的去解决警告。</p>
<ul>
<li><p>@SuppressWarnings(“rawtypes”)：抑制未使用泛型的警告</p>
</li>
<li><p>@SuppressWarnings(“resource”)：抑制未关闭资源的警告</p>
</li>
<li><p>@SuppressWarnings(“deprecation”)：抑制使用了已过时资源时的警告</p>
</li>
<li><p>@SuppressWarnings(“all”)：抑制所有警告</p>
</li>
</ul>
<h3 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h3><p>“函数式接口”的注解，这个是 JDK1.8 版本引入的新特性。使用@FunctionalInterface标注的接口，则该接口就<strong>有且只能存在一个<em>抽象方法</em></strong>，否则就会发生编译错误。</p>
<p>（注意：接口中的默认方法或静态方法可以有多个。）</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="如何自定义"><a href="#如何自定义" class="headerlink" title="如何自定义"></a>如何自定义</h3><p>创建一个annotation类型的文件，在文件中写入注解的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解中定义属性"><a href="#注解中定义属性" class="headerlink" title="注解中定义属性"></a>注解中定义属性</h3><p>属性的类型只能是：</p>
<ol>
<li>byte，short，int，long，float，double，boolean，char</li>
<li>String、Class、枚举类型、注解类型</li>
<li>以上所有类型的一维数组形式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String a;</span><br><span class="line">    <span class="type">int</span> b <span class="keyword">default</span> <span class="number">10</span>; <span class="comment">// 可以使用default语句指定默认值</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注解的使用</span></span><br><span class="line"><span class="meta">@interface(a=&quot;test&quot;,flag=0)</span> <span class="comment">//带默认值的属性可以不在此赋值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果属性只有一个，并且属性名是value，那使用注解的时候可以省略value这个属性名。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface(&quot;test&quot;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果属性是一个数组，使用注解时，数组值只有一个，数组的大括号可以省略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String[] value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface(&quot;test1&quot;)</span></span><br><span class="line"><span class="meta">@interface(&#123;&quot;test1&quot;,&quot;test2&quot;&#125;)</span></span><br></pre></td></tr></table></figure>



<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><h3 id="Retention：设置注解的保持性"><a href="#Retention：设置注解的保持性" class="headerlink" title="@Retention：设置注解的保持性"></a>@Retention：设置注解的保持性</h3><p>注解存在阶段是保留在源代码（编译期），字节码（类加载）或者运行时（JVM中运行）</p>
<ul>
<li><p><code>@Retention(RetentionPolicy.SOURCE)</code>：注解仅存在于源代码中，在字节码文件中不包含。</p>
</li>
<li><p><code>@Retention(RetentionPolicy.CLASS)</code>：注解在字节码文件中存在，但运行时无法获得（默认）。</p>
</li>
<li><p><code>@Retention(RetentionPolicy.RUNTIME)</code>：注解在字节码文件中存在，且运行时可通过反射获取。</p>
</li>
</ul>
<h3 id="Target：设置注解可以使用的位置"><a href="#Target：设置注解可以使用的位置" class="headerlink" title="@Target：设置注解可以使用的位置"></a>@Target：设置注解可以使用的位置</h3><ul>
<li><p><code>@Target(ElementType.TYPE)</code>：作用于接口、类、枚举、注解</p>
</li>
<li><p><code>@Target(ElementType.FIELD)</code>：作用于属性、枚举的常量</p>
</li>
<li><p><code>@Target(ElementType.METHOD)</code>：作用于方法</p>
</li>
<li><p><code>@Target(ElementType.PARAMETER)</code>：作用于方法参数</p>
</li>
<li><p><code>@Target(ElementType.CONSTRUCTOR)</code>：作用于构造方法</p>
</li>
<li><p><code>@Target(ElementType.LOCAL_VARIABLE)</code>：作用于局部变量</p>
</li>
<li><p><code>@Target(ElementType.ANNOTATION_TYPE)</code>：作用于注解</p>
</li>
<li><p><code>@Target(ElementType.PACKAGE)</code>：作用于包</p>
</li>
<li><p><code>@Target(ElementType.TYPE_PARAMETER)</code>：作用于泛型，即泛型方法、泛型类和泛型接口。</p>
</li>
<li><p><code>@Target(ElementType.TYPE_USE)</code>：作用于任意类型。</p>
</li>
</ul>
<h3 id="Documented：设置注解会被包含在API文档中"><a href="#Documented：设置注解会被包含在API文档中" class="headerlink" title="@Documented：设置注解会被包含在API文档中"></a>@Documented：设置注解会被包含在API文档中</h3><p>使用javadoc.exe工具可以从程序源代码中抽取类、方法、属性等注释形成一个源代码配套的API帮助文档，而该工具抽取时默认不包括注解内容。如果注解被@Documented标注，那么就能被javadoc.exe工具提取到API文档。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250521194851842.png" alt="image-20250521194851842"></p>
<h3 id="Inherited：被标注的注解支持继承"><a href="#Inherited：被标注的注解支持继承" class="headerlink" title="@Inherited：被标注的注解支持继承"></a>@Inherited：被标注的注解支持继承</h3><p>使用后子类会继承父类的注解。</p>
<h3 id="Repeatable：设置后可以在一个地方重复使用同一注解（java8）"><a href="#Repeatable：设置后可以在一个地方重复使用同一注解（java8）" class="headerlink" title="@Repeatable：设置后可以在一个地方重复使用同一注解（java8）"></a>@Repeatable：设置后可以在一个地方重复使用同一注解（java8）</h3><p><code>@Repeatable(原注解的复数形式)</code></p>
<p>但是需要再声明一个原来注解的复数形式，并在其中包含原注解类型的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Author(name = &quot;张三&quot;)</span></span><br><span class="line">    <span class="meta">@Author(name = &quot;李四&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Authors.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Author &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作者的名字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 作者的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authors &#123;</span><br><span class="line"></span><br><span class="line">    Author[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反射注解"><a href="#反射注解" class="headerlink" title="反射注解"></a>反射注解</h2><p>获取类上的所有注解</p>
<p>​		<code>Annotation[] annotations = clazz.getAnnotations();</code></p>
<p>获取类上指定的某个注解</p>
<p>​		<code>clazz.isAnnotationPresent(AnnotationTest01.class)</code></p>
<p>​		<code>AnnotationTest01 an = clazz.getAnnotation(AnnotationTest01.class);</code></p>
<p>获取属性上的所有注解</p>
<p>​		<code>Annotation[] annotations = field.getAnnotations();</code></p>
<p>获取属性上指定的某个注解</p>
<p>​		<code>field.isAnnotationPresent(AnnotationTest02.class)</code></p>
<p>​		<code>AnnotationTest02 an = field.getAnnotation(AnnotationTest02.class);</code></p>
<p>获取方法上的所有注解</p>
<p>​		<code>Annotation[] annotations = method.getAnnotations();</code></p>
<p>获取方法上指定的某个注解</p>
<p>​		<code>method.isAnnotationPresent(AnnotationTest02.class)</code></p>
<p>​		<code>AnnotationTest02 an = method.getAnnotation(AnnotationTest02.class);</code></p>
<h1 id="十二、网络编程"><a href="#十二、网络编程" class="headerlink" title="十二、网络编程"></a>十二、网络编程</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>网络编程的三个基本要素：</p>
<ol>
<li>IP地址：定位网络中的某台计算机</li>
<li>端口号port：定位计算机上的某个进程（某个应用）</li>
<li>通信协议：通过IP地址和端口号定位后，如何保证数据可靠高效的传输，就需要依靠通信协议。</li>
</ol>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li>IPv4：4字节，xxx.xxx.xxx.xxx 每个xxx表示8位二进制数，范围是0-255</li>
</ul>
<p>​					前三个字节用于表示网络（省市区），最后一个字节用于表示主机（家门牌号）</p>
<p>​					一些IP地址被保留或者被私有机构使用，不能用于公网的地址分配；还有一些IP地址被用作多播地址，仅用于特定的应用场景。因此实际可以使用的IPv4地址少于总量。</p>
<ul>
<li><p>IPv6：16字节，由8组十六进制数表示，如 3ffe:3201:1401:1280:c8ff:fd54:db39:1984</p>
</li>
<li><p>本机地址：127.0.0.1，主机名：localhost</p>
</li>
<li><p>192.168.0.0-192.168.255.255为私有地址，属于非注册地址，专门为组织、机构内部使用。（用于局域网）</p>
</li>
</ul>
<h3 id="端口号port"><a href="#端口号port" class="headerlink" title="端口号port"></a>端口号port</h3><p>用两个字节（无符号）表示的，取值范围0-65535，计算机端口号可以分为三大类：</p>
<ol>
<li>公认端口：0-1023，被预先定义的服务通信占用（如http占用80，FTP占用21，Telnet占用23等）</li>
<li>注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。</li>
<li>动态&#x2F;私有端口：49152~65535。</li>
</ol>
<p>通常情况下，服务器程序使用固定的端口号来监听客户端的请求，而客户端则使用随机端口连接服务器。</p>
<h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250522114020569.png" alt="image-20250522114020569"></p>
<h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP&#x2F;IP参考模型"></a>TCP&#x2F;IP参考模型</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250522114318348.png" alt="image-20250522114318348"></p>
<h2 id="网络编程基础类"><a href="#网络编程基础类" class="headerlink" title="网络编程基础类"></a>网络编程基础类</h2><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><ol>
<li>java.net.IntAddress类用来封装计算机的IP地址和DNS（没有端口信息），它包括一个主机名和一个IP地址，是java对IP地址的高层表示。大多数其它网络类都要用到这个类，包括Socket、ServerSocket、URL、DatagramSocket、DatagramPacket等</li>
<li>常用静态方法<ul>
<li><code>static InetAddress getLocalHost()</code> 得到本机的InetAddress对象，其中封装了IP地址和主机名</li>
<li><code>lstatic InetAddress getByName(String host)</code> 传入目标主机的名字或IP地址得到对应的InetAddress对象，其中封装了IP地址和主机名（底层会自动连接DNS服务器进行域名解析）</li>
</ul>
</li>
<li>常用实例方法<ul>
<li><code>lpublic String getHostAddress()</code> 获取IP地址</li>
<li><code>lpublic String getHostName()</code> 获取主机名&#x2F;域名</li>
</ul>
</li>
</ol>
<h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><ol>
<li>URL是统一资源定位符，是互联网上资源位置和访问方法的一种简介表示。每个文件具有唯一的URL。</li>
<li>URL由4部分组成：协议、存放资源的主机域名、端口号、资源文件名。如果未指定端口号，则使用协议默认的端口。HTTP协议的默认端口为80。</li>
<li>URL的标准格式：&lt;协议&gt;:&#x2F;&#x2F;&lt;域名或IP&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;，其中端口和路径有时可以省略。</li>
<li>为了方便程序员编程，JDK提供了java.net.URL类，该类封装了大量复杂的涉及从远程站点获取信息的细节，可以使用它的各种方法对URL对象进行分割、合并等处理</li>
</ol>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://127.0.0.1:8080/oa/index.html?name=zhangsan#tip&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><p>获取协议：<code>url.getProtocol()</code>   获取域名：<code>url.getHost()</code>   </p>
<p>获取默认端口：<code>url.getDefaultPort()</code>   获取端口：<code>url.getPort()</code>   </p>
<p>获取路径：<code>url.getPath()</code>   获取资源：<code>url.getFile()</code> </p>
<p>获取数据：<code>url.getQuery()</code>   获取锚点：<code>url.getRef()</code></p>
<p><code>openStream()</code>：可以打开到此URL的连接并返回一个用于从该连接读入的InputStream，实现最简单的爬虫。</p>
<h2 id="TCP-与-UDP-协议"><a href="#TCP-与-UDP-协议" class="headerlink" title="TCP 与 UDP 协议"></a>TCP 与 UDP 协议</h2><h3 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket 套接字"></a>Socket 套接字</h3><ul>
<li><p>Socket是传输层供给应用层的编程接口。使用Socket编程可以开发客户端和服务器应用程序，可以在本地网络上进行通信，也可以通过互联网在全球范围内通信。</p>
</li>
<li><p>TCP协议和UDP协议是传输层的两种协议。Socket编程分为TCP编程和UDP编程两类。</p>
</li>
</ul>
<h3 id="TCP、UDP协议"><a href="#TCP、UDP协议" class="headerlink" title="TCP、UDP协议"></a>TCP、UDP协议</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250522210035291.png" alt="image-20250522210035291"></p>
<h4 id="TCP-三次握手（通道打开）"><a href="#TCP-三次握手（通道打开）" class="headerlink" title="TCP 三次握手（通道打开）"></a>TCP 三次握手（通道打开）</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250522210727148.png" alt="image-20250522210727148"></p>
<ol>
<li>客户端发送SYN（同步）数据包，包含客户端的初始序列号（ISN）</li>
<li>服务器收到SYN数据包后，发送SYN-ACK（同步确认）数据包，包含<strong>服务器的初始序列号</strong>（ISN）和<strong>对客户端ISN的确认号</strong>（ACK）</li>
<li>客户端收到SYN-ACK数据包后，发送ACK（确认）数据包，包含<strong>对服务器ISN的确认号</strong>（ACK）</li>
</ol>
<p>三次握手完成后，客户端和服务器就可以开始交换数据了。</p>
<p>三次握手的意义：不会丢失、重复、乱序，保证数据在两个设备之间可靠地传输。</p>
<h4 id="四次挥手（通道关闭）"><a href="#四次挥手（通道关闭）" class="headerlink" title="四次挥手（通道关闭）"></a>四次挥手（通道关闭）</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250522211206176.png" alt="image-20250522211206176"></p>
<ol>
<li>客户端发送FIN（结束）数据包，表示客户端已经完成数据传输，希望关闭连接。</li>
<li>服务器收到FIN数据包后，发送ACK（确认）数据包，表示服务器已经收到客户端的FIN数据包，同意关闭连接。</li>
<li>服务器发送FIN数据包，表示服务器已经完成数据传输，希望关闭连接。</li>
<li>客户端收到FIN数据包，发送ACK（确认）数据包。表示客户端已经收到服务器的FIN数据包，并同意关闭连接。</li>
</ol>
<p>四次挥手完成后，客户端和服务器之间的连接就关闭了。</p>
<p>四次挥手的意义：不会丢失、重复、乱序，保证数据在两个设备之间可靠地传输。</p>
<h3 id="基于TCP协议的编程"><a href="#基于TCP协议的编程" class="headerlink" title="基于TCP协议的编程"></a>基于TCP协议的编程</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250522213820740.png" alt="image-20250522213820740"></p>
<ol>
<li>在网络通讯中，第一次主动发起通讯的程序被称作客户端(Client)，而在第一次通讯中等待连接的程序被称作服务端(Server)。一旦通讯建立，则客户端和服务器端完全一样，没有本质的区别。</li>
<li>套接字与主机地址和端口号相关联，主机地址就是客户端或服务器程序所在的主机的IP地址，端口地址是指客户端或服务器程序使用的主机的通信端口。在客户端和服务器中，分别创建独立的Socket，并通过Socket的属性，将两个Socket进行连接，这样客户端和服务器通过套接字所建立连接并使用IO流进行通信。</li>
</ol>
<h4 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h4><p>Socket实现客户端套接字。</p>
<p><strong>构造方法：</strong></p>
<p><code>public Socket(InetAddress a, int p)</code> 创建套接字并连接到指定IP地址的指定端口号</p>
<p><strong>Socket类实例方法：</strong></p>
<p><code>public InetAddress getInetAddress()</code> 返回此套接字连接到的远程 IP 地址</p>
<p><code>public InputStream getInputStream()</code> 返回此套接字的输入流（接收网络消息）</p>
<p><code>public OutputStream getOutputStream()</code> 返回此套接字的输出流（发送网络消息）</p>
<p><code>public void shutdownInput()</code> 禁用此套接字的输入流</p>
<p><code>public void shutdownOutput()</code> 禁用此套接字的输出流</p>
<p><code>public synchronized void close()</code> 关闭此套接字（默认会关闭IO流）</p>
<h4 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h4><p>ServerSocket类实现服务器套接字。服务器套接字等待请求通过网络传入，基于该请求执行某些操作，然后向请求者返回结果。</p>
<p><strong>构造方法：</strong></p>
<p><code>public ServerSocket(int port)</code></p>
<p><strong>ServerSocket类实例方法：</strong></p>
<p><code>public Socket accept()</code> 侦听要连接到此套接字并接受它</p>
<p><code>public InetAddress getInetAddress()</code> 返回此服务器套接字的本地地址</p>
<p><code>public void close()</code> 关闭此套接字</p>
<h1 id="十三、lambda表达式"><a href="#十三、lambda表达式" class="headerlink" title="十三、lambda表达式"></a>十三、lambda表达式</h1><ul>
<li>面向对象的思想<ul>
<li>只做一件事情，找一个能解决这个事情的对象，然后调用对象的方法完成这件事情。</li>
</ul>
</li>
<li>函数式编程思想<ul>
<li>只要能获得结果，谁去做的，怎么做的都不重要，重视结果，忽略实现过程</li>
</ul>
</li>
</ul>
<h2 id="Lambda和匿名内部类的区别"><a href="#Lambda和匿名内部类的区别" class="headerlink" title="Lambda和匿名内部类的区别"></a>Lambda和匿名内部类的区别</h2><ul>
<li>所需类型不同<ul>
<li>匿名内部类：可以是接口、抽象类、具体类</li>
<li>Lambda表达式：只能是接口</li>
</ul>
</li>
<li>使用限制不同<ul>
<li>如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类。</li>
<li>如果接口中有多个抽象方法，就只能使用匿名内部类，而不能使用Lambda表达式。</li>
</ul>
</li>
<li>实现原理不同<ul>
<li>匿名内部类：编译之后，会生成一个单独的.class字节码文件</li>
<li>Lambda表达式：编译之后，不会生成一个单独的.class字节码文件</li>
</ul>
</li>
</ul>
<h2 id="Lambda表达式的语法"><a href="#Lambda表达式的语法" class="headerlink" title="Lambda表达式的语法"></a>Lambda表达式的语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(形参列表) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">	方法体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">100</span>,<span class="number">200</span>,<span class="number">350</span>,<span class="number">300</span>);</span><br><span class="line"><span class="comment">// 对其进行排序</span></span><br><span class="line"><span class="comment">// 法一</span></span><br><span class="line">Collections.sort(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二：匿名内部类</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2-o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 法三：Lambda表达式</span></span><br><span class="line">Collections.sort(list,(Integer o1, Integer o2) -&gt; &#123;<span class="keyword">return</span> b-a;&#125;)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator = (Integer a, Integer b) -&gt; &#123;<span class="keyword">return</span> b-a&#125;;</span><br><span class="line">Collections.sort(list,comparator);</span><br></pre></td></tr></table></figure>



<h2 id="Lambda-表达式的语法精简"><a href="#Lambda-表达式的语法精简" class="headerlink" title="Lambda 表达式的语法精简"></a>Lambda 表达式的语法精简</h2><p>四种情况：</p>
<ol>
<li>形参类型可以省略，如果需要省略，则每个形参的类型都要省略。</li>
<li>如果形参列表只有一个形参，那么形参类型和小括号都可以省略。</li>
<li>如果方法体重只有一行语句，那么方法体的大括号也可以省略。</li>
<li>如果方法体中只有一条return语句，那么大括号可以省略，且必须去掉return关键字。</li>
</ol>
<h2 id="四个基本的函数式接口"><a href="#四个基本的函数式接口" class="headerlink" title="四个基本的函数式接口"></a>四个基本的函数式接口</h2><table>
<thead>
<tr>
<th>名字</th>
<th>接口名</th>
<th>对应的抽象方法</th>
</tr>
</thead>
<tbody><tr>
<td>消费</td>
<td>Consumer<T></td>
<td>void accept(T t);</td>
</tr>
<tr>
<td>生产</td>
<td>Supplier<T></td>
<td>T get();</td>
</tr>
<tr>
<td>转换</td>
<td>Function&lt;T, R&gt;</td>
<td>R apply(T t);</td>
</tr>
<tr>
<td>判断</td>
<td>Predicate<T></td>
<td>boolean test(T t);</td>
</tr>
</tbody></table>
<h2 id="Lambda表达式的方法引用（简化Lambda表达式）"><a href="#Lambda表达式的方法引用（简化Lambda表达式）" class="headerlink" title="Lambda表达式的方法引用（简化Lambda表达式）"></a>Lambda表达式的方法引用（简化Lambda表达式）</h2><h3 id="方法引用的概述"><a href="#方法引用的概述" class="headerlink" title="方法引用的概述"></a>方法引用的概述</h3><p>我们在使用Lambda表达式的时候，如果Lambda表达式的方法体中除了调用现有方法之外什么都不做，满足这样的条件就有机会使用方法引用来实现。<br>在以下的代码中，在重写的apply()方法中仅仅只调用了现有Math类round()方法，也就意味着Lambda表达式中仅仅只调用了现有Math类round()方法，那么该Lambda表达式就可以升级为方法引用，案例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：实现小数取整的操作</span></span><br><span class="line"><span class="comment">// 方式一：使用匿名对象来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.round(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function1.apply(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function2 = aDouble -&gt; Math.round(aDouble);</span><br><span class="line">System.out.println(function2.apply(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function3 = Math :: round;</span><br><span class="line">System.out.println(function3.apply(<span class="number">3.14</span>));</span><br></pre></td></tr></table></figure>

<p>对于方法引用，我们可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。<br>在Lambda表达式的方法引用中，主要有实例方法引用、静态方法引用、特殊方法引用和构造方法引用、数组引用这五种情况，接下来我们就对这五种情况进行讲解。</p>
<h3 id="实例方法引用"><a href="#实例方法引用" class="headerlink" title="实例方法引用"></a>实例方法引用</h3><p>语法：对象 :: 实例方法<br>特点：在Lambda表达式的方法体中，通过“对象”来调用指定的某个“实例方法”。<br>要求：函数式接口中抽象方法的返回值类型和形参列表       与          内部通过对象调用某个实例方法的返回值类型和形参列表            保持一致。<br>【示例】实例化Consumer接口的实现类对象，并在重写的accept()方法中输出形参的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Consumer&lt;String&gt; consumer1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">consumer1.accept(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Consumer&lt;String&gt; consumer2 = str -&gt; System.out.println(str);</span><br><span class="line">consumer2.accept(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Consumer&lt;String&gt; consumer3 = System.out :: println;</span><br><span class="line">consumer3.accept(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>【示例】实例化Supplier接口的实现类对象，并在重写方法中返回Teacher对象的姓名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;ande&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Supplier&lt;String&gt; supplier1 = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> teacher.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(supplier1.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Supplier&lt;String&gt; supplier2 = () -&gt; teacher.getName();</span><br><span class="line">System.out.println(supplier2.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Supplier&lt;String&gt; supplier3 = teacher :: getName;</span><br><span class="line">System.out.println(supplier3.get());</span><br></pre></td></tr></table></figure>



<h3 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h3><p>语法：类 :: 静态方法<br>特点：在Lambda表达式的方法体中，通过“类名”来调用指定的某个“静态方法”。<br>要求：函数式接口中抽象方法的返回值类型和形参列表           与               内部通过类名调用某个静态方法的返回值类型和形参列表保持一致。</p>
<p>【示例】实例化Function接口的实现类对象，并在重写的方法中返回小数取整的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.round(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function1.apply(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function2 = aDouble -&gt; Math.round(aDouble);</span><br><span class="line">System.out.println(function2.apply(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function3 = Math :: round;</span><br><span class="line">System.out.println(function3.apply(<span class="number">3.14</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&from=url&id=RpIg2&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="特殊方法引用"><a href="#特殊方法引用" class="headerlink" title="特殊方法引用"></a>特殊方法引用</h3><p>语法：类名 :: 实例方法<br>特点：在Lambda表达式的方法体中，通过方法的第一个形参来调用指定的某个“实例方法”。<br>要求：把函数式接口中抽象方法的第一个形参作为方法的调用者对象，并且从第二个形参开始（或无参）可以对应到被调用实例方法的参数列表中，并且返回值类型保持一致。<br>【示例】使用Comparator比较器，来判断两个小数的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Comparator&lt;Double&gt; comparator1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Double&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Double o1, Double o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(comparator1.compare(<span class="number">10.0</span>, <span class="number">20.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Comparator&lt;Double&gt; comparator2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">System.out.println(comparator2.compare(<span class="number">10.0</span>, <span class="number">20.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Comparator&lt;Double&gt; comparator3 = Double :: compareTo;</span><br><span class="line">System.out.println(comparator3.compare(<span class="number">10.0</span>, <span class="number">20.0</span>));</span><br></pre></td></tr></table></figure>

<p>需求：实例化Function接口的实现类对象，然后获得传入Teacher对象的姓名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;ande&quot;</span>, <span class="number">18</span>);</span><br><span class="line">Function&lt;Teacher, String&gt; function1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Teacher, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Teacher teacher)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> teacher.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function1.apply(teacher));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Function&lt;Teacher, String&gt; function2 = e -&gt; e.getName();</span><br><span class="line">System.out.println(function2.apply(teacher));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Function&lt;Teacher, String &gt; function3 = Teacher :: getName;</span><br><span class="line">System.out.println(function3.apply(teacher));</span><br></pre></td></tr></table></figure>



<h3 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h3><p>语法：类名 :: new<br>特点：在Lambda表达式的方法体中，返回指定“类名”来创建出来的对象。<br>要求：创建对象所调用构造方法形参列表      和      函数式接口中的方法的形参列表       保持一致，并且方法的返回值类型和创建对象的类型保持一致。<br>【示例】实例化Supplier接口的实现类对象，然后调用重写方法返回Teacher对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Supplier&lt;Teacher&gt; supplier1 = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Teacher&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Teacher <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(supplier1.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Supplier&lt;Teacher&gt; supplier2 = () -&gt; <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">System.out.println(supplier2.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用构造方法引用来实现</span></span><br><span class="line"><span class="comment">// 注意：根据重写方法的形参列表，那么此处调用了Teacher类的无参构造方法</span></span><br><span class="line">Supplier&lt;Teacher&gt; supplier3 = Teacher :: <span class="keyword">new</span>;</span><br><span class="line">System.out.println(supplier3.get());</span><br></pre></td></tr></table></figure>

<p>【示例】实例化Function接口的实现类对象，然后调用重写方法返回Teacher对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Function&lt;String, Teacher&gt; function1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Teacher&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Teacher <span class="title function_">apply</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function1.apply(<span class="string">&quot;ande&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Function&lt;String, Teacher&gt; function2 = name -&gt; <span class="keyword">new</span> <span class="title class_">Teacher</span>(name);</span><br><span class="line">System.out.println(function2.apply(<span class="string">&quot;ande&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用构造方法引用来实现</span></span><br><span class="line"><span class="comment">// 注意：根据重写方法的形参列表，那么此处调用了Teacher类name参数的构造方法</span></span><br><span class="line">Function&lt;String, Teacher&gt; function3 = Teacher :: <span class="keyword">new</span>;</span><br><span class="line">System.out.println(function3.apply(<span class="string">&quot;ande&quot;</span>));</span><br></pre></td></tr></table></figure>



<h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><p>语法：数组类型 :: new<br>特点：在Lambda表达式的方法体中，创建并返回指定类型的“数组”。<br>要求：重写的方法有且只有一个整数型的参数，并且该参数就是用于设置数组的空间长度，并且重写方法的返回值类型和创建数组的类型保持一致。<br>【示例】实例化Function接口的实现类对象，并在重写方法中返回指定长度的int类型数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实</span></span><br><span class="line">Function&lt;Integer, <span class="type">int</span>[]&gt; function1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, <span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] apply(Integer integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[integer];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(Arrays.toString(function1.apply(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Function&lt;Integer, <span class="type">int</span>[]&gt; function2 = num -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">System.out.println(Arrays.toString(function2.apply(<span class="number">20</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Function&lt;Integer, <span class="type">int</span>[]&gt; function3 = <span class="type">int</span>[] :: <span class="keyword">new</span>;</span><br><span class="line">System.out.println(Arrays.toString(function3.apply(<span class="number">30</span>)));</span><br></pre></td></tr></table></figure>



<h2 id="Lambda在集合当中的使用"><a href="#Lambda在集合当中的使用" class="headerlink" title="Lambda在集合当中的使用"></a>Lambda在集合当中的使用</h2><p>为了能够让Lambda和Java的集合类集更好的一起使用，集合当中也新增了部分方法，以便与Lambda表达式对接，要用Lambda操作集合就一定要看懂源码。</p>
<h3 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach()方法"></a>forEach()方法</h3><p>在Collection集合和Map集合中，都提供了forEach()方法用于遍历集合。<br>在Collection集合中，提供的forEach()方法的形参为Consumer接口（消费型接口），通过该方法再配合Lambda表达式就可以遍历List和Set集合中的元素。<br>【示例】遍历List集合中的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>);</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">list.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得遍历出来的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 遍历出来的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer element)</span> &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">list.forEach(element -&gt; System.out.println(element));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">list.forEach(System.out :: println);</span><br></pre></td></tr></table></figure>

<p>【示例】遍历Set集合中的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list);</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">hashSet.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得遍历出来的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 遍历出来的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String element)</span> &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">hashSet.forEach(element -&gt; System.out.println(element));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">hashSet.forEach(System.out :: println);</span><br></pre></td></tr></table></figure>

<p>在Map集合中，提供的forEach()方法的形参为BiConsumer接口，而BiConsumer接口属于两个参数的消费型接口，通过该方法再配合Lambda表达式就可以遍历Map集合中的元素。<br>【示例】遍历Map集合中的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化Map集合并添加键值对</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;重庆&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;王五&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得遍历出来的key和value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key：&quot;</span> + key + <span class="string">&quot;，value：&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key：&quot;</span> + k + <span class="string">&quot;，value：&quot;</span> + v));</span><br></pre></td></tr></table></figure>



<h3 id="removeIf-方法"><a href="#removeIf-方法" class="headerlink" title="removeIf()方法"></a>removeIf()方法</h3><p>在Collection集合中，提供的removeIf()方法的形参为Predicate接口（判断型接口），通过该方法再配合Lambda表达式就可以遍历List和Set集合中的元素。<br>【示例】删除List集合中的某个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建List集合并添加元素</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>));</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">list.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定的某个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 用于保存遍历出来的某个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true，代表删除；返回false，代表不删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String element)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bb&quot;</span>.equals(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list); <span class="comment">// 输出：[aa, cc, dd]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">list.removeIf(<span class="string">&quot;cc&quot;</span> :: equals);</span><br><span class="line">System.out.println(list); <span class="comment">// 输出：[aa, dd]</span></span><br></pre></td></tr></table></figure>

<p>【示例】删除Set集合中的某个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list);</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">hashSet.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定的某个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 用于保存遍历出来的某个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true，代表删除；返回false，代表不删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String element)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bb&quot;</span>.equals(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(hashSet); <span class="comment">// 输出：[aa, cc, dd]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">hashSet.removeIf(<span class="string">&quot;cc&quot;</span> :: equals);</span><br><span class="line">System.out.println(hashSet); <span class="comment">// 输出：[aa, dd]</span></span><br></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javase/">javase</a></div><div class="post-share"><div class="social-share" data-image="/image/icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/25/mysql%E5%88%9D%E7%BA%A7/" title="mysql 初级"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">mysql 初级</div></div><div class="info-2"><div class="info-item-1">第一步操作 以管理员身份运行cmd，输入net start mysql 运行mysql 在cmd中输入mysql -h[地址] -P[端口] -u[用户名] -p[密码]  （使用本机的mysql数据库时，可以省略地址和端口）  MySQL命令行基本命令  列出当前数据库管理系统中有哪些数据库。  1show databases;    创建数据库，起名bjpowernode。  1create database bjpowernode;    使用bjpowernode数据库。  1use bjpowernode;    查看当前用的是哪个数据库。  1select database();    查看当前数据库中有哪些表。  1show tables;    删除数据库bjpowernode。  1drop database bjpowernode;    退出mysql exit quit ctrl + c   查看当前mysql版本  1select version();  还可以使用mysql.exe命令来查看版本信息（在没有登录mysql之前使用）：mysql...</div></div></div></a><a class="pagination-related" href="/2025/04/13/javase%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="javase 面向对象"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">javase 面向对象</div></div><div class="info-2"><div class="info-item-1">三、面向对象面向对象概述面向过程关注点在实现功能的步骤上 面向对象关注点在实现功能需要哪些对象的参与，可以把问题拆分成几个对象，对象协作起来解决问题。 面向对象开发方式耦合度低，扩展能力强。 面向对象的三大特征 封装 继承 多态  对象的创建1234[修饰符列表] class 类名&#123;    //属性    /&#125;    JVM内存分析元空间 metaspace元空间中存储的是类的元信息，字节码等。 元空间是java8之后引入的。是JVM规范中方法区的实现。 方法区：JVM规范 的叫法，各个厂商根据这个规范去实现具体的java虚拟机。 总结：方法区是规范，元空间是实现。java8之前使用永久代实现的。 堆内存所有new的对象，都存储在堆内存中。 栈方法被调用时会给该方法分配空间，在VM...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/11/javase%20%E5%BC%95%E5%85%A5%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" title="javase 引入、基本语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-11</div><div class="info-item-2">javase 引入、基本语法</div></div><div class="info-2"><div class="info-item-1">一、引入JAVA语言特性简单性：不像c++支持多继承，无指针。底层由c++实现。 面向对象 可移植性：一次编译，到处运行。在win上编译后可以在Linux上运行。 ​					Java程序在Java虚拟机上运行，JVM : Java virtual machine ​					JDK ：Java开发工具包 多线程 健壮性：产生的垃圾是自动回收的，不需要像c++一样手动回收内存空间。 安全性 JAVA的加载与执行 注：.class文件是字节码文件，不是纯粹的二进制文件，否则操作系统就可以直接运行了。 编译：使用JDK中自带的javac.exe进行编译使用方法： 1javac java源文件的路径   一个源文件可能生成多个.class文件 .class文件生成后，删除.java文件不影响程序的运行，但最好不要删掉，以防后面要修改。  运行：使用java.exe运行使用方法： 磁盘上有一个A.class 1java A...</div></div></div></a><a class="pagination-related" href="/2025/04/13/javase%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="javase 面向对象"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">javase 面向对象</div></div><div class="info-2"><div class="info-item-1">三、面向对象面向对象概述面向过程关注点在实现功能的步骤上 面向对象关注点在实现功能需要哪些对象的参与，可以把问题拆分成几个对象，对象协作起来解决问题。 面向对象开发方式耦合度低，扩展能力强。 面向对象的三大特征 封装 继承 多态  对象的创建1234[修饰符列表] class 类名&#123;    //属性    /&#125;    JVM内存分析元空间 metaspace元空间中存储的是类的元信息，字节码等。 元空间是java8之后引入的。是JVM规范中方法区的实现。 方法区：JVM规范 的叫法，各个厂商根据这个规范去实现具体的java虚拟机。 总结：方法区是规范，元空间是实现。java8之前使用永久代实现的。 堆内存所有new的对象，都存储在堆内存中。 栈方法被调用时会给该方法分配空间，在VM...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">eric_zht</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/erichtz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">四、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0"><span class="toc-text">数组概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">数组的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">静态初始化一维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK5-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF-for-each-%E5%BE%AA%E7%8E%AF"><span class="toc-text">JDK5 新特性：增强for循环 &#x2F; for-each 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">动态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">数组中如何存储不同类的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Emain%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82args"><span class="toc-text">关于main方法的形参args</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">可变长度的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-text">一维数组的扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">静态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-text">动态初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">Arrays 工具类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BC%82%E5%B8%B8"><span class="toc-text">五、异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-text">什么是异常？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%9C%A8java%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-text">异常在java中的形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">处理异常的两种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA7-%E6%96%B0%E7%89%B9%E6%80%A7-%E2%80%94%E2%80%94-%E5%BC%82%E5%B8%B8%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">JAVA7 新特性 —— 异常统一处理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">异常对象的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finally-%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-text">finally 语句块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-text">继承问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">六、常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-String"><span class="toc-text">字符串 String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88string-%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%9F"><span class="toc-text">为什么string 字面量不可变？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-text">字符串拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%8B%E5%8A%A8%E6%94%BE%E8%BF%9B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-text">怎么把字符串手动放进字符串常量池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">String类常用的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">String常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E4%B8%AD%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">String 中正则表达式相关的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer-%E4%B8%8E-StringBuilder-%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">StringBuffer 与 StringBuilder 可变长度字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Integer 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E3%80%81int%E3%80%81Integer-%E4%B8%89%E8%80%85%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">String、int、Integer 三者相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-%E6%8B%86%E7%AE%B1%EF%BC%88JAVA5%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-text">自动装箱&#x2F;拆箱（JAVA5新特性）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-text">自动装箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1"><span class="toc-text">自动拆箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%9E%8B%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">整数型常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigInteger"><span class="toc-text">BigInteger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal"><span class="toc-text">BigDecimal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DecimalFormat"><span class="toc-text">DecimalFormat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3API"><span class="toc-text">日期相关API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="toc-text">获取时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">日期格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86String%E8%BD%AC%E5%8C%96%E6%88%90Date"><span class="toc-text">将String转化成Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-Calend-ar-%E6%97%A5%E5%8E%86%E7%B1%BB"><span class="toc-text">java.util.Calend ar 日历类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E7%9A%84%E6%97%A5%E5%8E%86%E5%AF%B9%E8%B1%A1"><span class="toc-text">获取当前时间的日历对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%A5%E5%8E%86%E4%B8%AD%E7%9A%84%E6%9F%90%E9%83%A8%E5%88%86"><span class="toc-text">获取日历中的某部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%97%A5%E5%8E%86%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">修改日历中的内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%8E%86%E7%9A%84%E6%96%B0API%EF%BC%88java8%EF%BC%89"><span class="toc-text">日历的新API（java8）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F"><span class="toc-text">日期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">时间戳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E3%80%81%E6%97%A5%E6%9C%9F%E9%97%B4%E9%9A%94"><span class="toc-text">计算时间间隔、日期间隔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%9F%AB%E6%AD%A3%E5%99%A8"><span class="toc-text">时间矫正器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96-1"><span class="toc-text">日期格式化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E7%B1%BB-Math"><span class="toc-text">数学类 Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-text">高级用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Random-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">Random 随机数生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System%E7%B1%BB"><span class="toc-text">System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UUID-%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">UUID 通用唯一标识符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%9B%86%E5%90%88"><span class="toc-text">七、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-text">集合概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-text">Collection 关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Collection接口的通用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E7%9A%84%E9%80%9A%E7%94%A8%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F"><span class="toc-text">Collection的通用遍历&#x2F;迭代方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SequencedCollection%E6%8E%A5%E5%8F%A3"><span class="toc-text">SequencedCollection接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-text">泛型初体验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">泛型的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%BB%E7%9F%B3%E8%A1%A8%E8%BE%BE%E5%BC%8F-%EF%BC%88Java7%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-text">钻石表达式 （Java7新特性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E4%B8%8E%E8%A1%A5%E5%81%BF%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">泛型擦除与补偿（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">泛型的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E4%B8%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-text">在类上自定义泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8A%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-text">在静态方法上定义泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%8A%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-text">在接口上定义泛型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">泛型的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">泛型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">无限定通配符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">上限通配符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">下限通配符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98-fail-fast-%E6%9C%BA%E5%88%B6"><span class="toc-text">集合的并发修改问题 fail-fast 机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-%E6%8E%A5%E5%8F%A3"><span class="toc-text">List 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">常见的实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">List接口特有的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E7%89%B9%E6%9C%89%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F"><span class="toc-text">List特有的迭代方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8Comparator%E6%8E%92%E5%BA%8F"><span class="toc-text">List接口使用Comparator排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E6%8E%92%E5%BA%8F%E7%9A%84%EF%BC%9F"><span class="toc-text">回顾数组中自定义类型是如何排序的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-text">List集合的排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList-%E7%B1%BB"><span class="toc-text">ArrayList 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">回顾：数组的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrrayList%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5"><span class="toc-text">ArrrayList扩容策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-%E7%B1%BB%EF%BC%88-%E4%B8%8D%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E4%BA%86%EF%BC%89"><span class="toc-text">Vector 类（*不怎么使用了）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%B1%BB"><span class="toc-text">LinkedList 双向链表类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">栈 数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">队列 数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8DSet"><span class="toc-text">三种Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Map 接口的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">Map 集合的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%8E%B7%E5%8F%96Map%E9%9B%86%E5%90%88%E7%9A%84%E6%89%80%E6%9C%89key%EF%BC%8C%E7%84%B6%E5%90%8E%E9%81%8D%E5%8E%86%E6%AF%8F%E4%B8%AAkey%EF%BC%8C%E9%80%9A%E8%BF%87key%E8%8E%B7%E5%8F%96value"><span class="toc-text">方法一：获取Map集合的所有key，然后遍历每个key，通过key获取value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%8E%B7%E5%8F%96Map%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BBMap-Entry-%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%8C%E5%B8%B8%E7%94%A8%E8%BF%99%E4%B8%AA"><span class="toc-text">方法二：获取Map的内部类Map.Entry (效率更高，常用这个)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-text">哈希表存储原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%81%EF%BC%81hashCode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E8%A6%81%E5%90%8C%E6%97%B6%E9%87%8D%E5%86%99"><span class="toc-text">！！hashCode和equals方法要同时重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%9C%A8Java8%E5%90%8E%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-text">HashMap在Java8后的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA"><span class="toc-text">初始化时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95"><span class="toc-text">插入方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E7%9A%84%E5%AE%B9%E9%87%8F%E6%B0%B8%E8%BF%9C%E6%98%AF2%E7%9A%84%E6%AC%A1%E5%B9%82"><span class="toc-text">HashMap的容量永远是2的次幂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E8%AE%BE%E7%BD%AE"><span class="toc-text">HashMap的初始化容量设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap"><span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable%EF%BC%88%E6%95%88%E7%8E%87%E4%BD%8E%EF%BC%8C%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-text">Hashtable（效率低，不常用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties-%E5%B1%9E%E6%80%A7%E7%B1%BB"><span class="toc-text">Properties 属性类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-text">TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">排序二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">红黑二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put-%E6%96%B9%E6%B3%95"><span class="toc-text">put() 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E4%B8%8D%E8%83%BD%E6%B7%BB%E5%8A%A0NULL"><span class="toc-text">总结：哪些集合不能添加NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">Collections 工具类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81IO%E6%B5%81"><span class="toc-text">八、IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="toc-text">IO流概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%B5%81%E5%90%91%E5%88%86"><span class="toc-text">根据流向分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%88%86"><span class="toc-text">根据读写数据的形式分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%B5%81%E5%9C%A8IO%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%88%86"><span class="toc-text">根据流在IO操作中的作用和实现方式分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">IO流体系结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileInputStream-%E7%B1%BB"><span class="toc-text">FileInputStream 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">常用构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int-read"><span class="toc-text">int read();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-read-byte-b"><span class="toc-text">int read(byte[] b);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-read-byte-b-int-off-int-len"><span class="toc-text">int read(byte[] b, int off, int len);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#long-skip-long-n"><span class="toc-text">long skip(long n);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-available"><span class="toc-text">int available();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-close-%EF%BC%9B"><span class="toc-text">void close()；</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileOutputStream"><span class="toc-text">FileOutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-text">常用构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#void-close"><span class="toc-text">void close();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-flush"><span class="toc-text">void flush();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-write-int-b"><span class="toc-text">void write(int b);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-write-byte-b"><span class="toc-text">void write(byte[] b);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-write-byte-b-int-off-int-len"><span class="toc-text">void write(byte[] b, int off, int len);</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TryWithResources-%E8%B5%84%E6%BA%90%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD-Java7%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">TryWithResources 资源自动关闭 Java7新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileReader-%E8%AF%BB%E5%8F%96%E6%99%AE%E9%80%9A%E6%96%87%E6%9C%AC"><span class="toc-text">FileReader 读取普通文本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileWriter"><span class="toc-text">FileWriter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84"><span class="toc-text">路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BufferedInputStream-BufferedOutputStream"><span class="toc-text">BufferedInputStream&#x2F;BufferedOutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">对缓冲流的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0"><span class="toc-text">标记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-text">如何解决乱码问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">对象的序列化与反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">序列化版本号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serial%E6%B3%A8%E8%A7%A3"><span class="toc-text">serial注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transient%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">transient关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81-PrintStream-PrintWriter"><span class="toc-text">打印流 PrintStream&#x2F;PrintWriter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PrintStream"><span class="toc-text">PrintStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrintWriter"><span class="toc-text">PrintWriter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81-System-in"><span class="toc-text">标准输入流 System.in</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81-System-out"><span class="toc-text">标准输出流 System.out</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-text">File类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E8%A7%81%E6%96%87%E6%A1%A3%E3%80%82"><span class="toc-text">常见方法见文档。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">读取属性配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceBundle%E8%BF%9B%E8%A1%8C%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A"><span class="toc-text">ResourceBundle进行资源绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">装饰器设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E6%B5%81"><span class="toc-text">压缩流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">压缩流的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">解压缩流的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E6%B5%81"><span class="toc-text">字节数组流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%B5%81%E8%A3%85%E9%A5%B0%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E6%B5%81"><span class="toc-text">使用对象流装饰字节数组流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B7%B1%E5%85%8B%E9%9A%86"><span class="toc-text">对象深克隆</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">九、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-text">并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C"><span class="toc-text">并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-text">并发与并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-text">线程的调度模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-text">分时调度模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-text">抢占式调度模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">实现多线程的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D"><span class="toc-text">第一种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D"><span class="toc-text">第二种</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-text">线程常用的三个方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%847%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="toc-text">线程生命周期的7个状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%91%E7%9C%A0"><span class="toc-text">线程的休眠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%91%E7%9C%A0"><span class="toc-text">中断线程的休眠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">停止运行线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-text">定时任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%88%E5%B9%B6"><span class="toc-text">线程合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A9%E4%BD%8D"><span class="toc-text">让位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">什么情况下需要考虑线程安全问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B"><span class="toc-text">一般情况下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">线程同步机制——互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">线程异步机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">涉及到的三个方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%AE%8C%E6%95%B4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">最完整的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">懒汉式单例模式的线程安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%9C%AA%E6%9D%A5%E4%BB%BB%E5%8A%A1"><span class="toc-text">创建线程的第三种方法——未来任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">创建线程的第四种方式——线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%8F%8D%E5%B0%84-reflect"><span class="toc-text">十、反射 reflect</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">获取Class的四种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D-1"><span class="toc-text">第一种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D-1"><span class="toc-text">第二种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D"><span class="toc-text">第三种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%A7%8D%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">第四种——使用类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">通过反射机制实例化对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AF%B9%E7%B1%BB%E4%BD%BF%E7%94%A8newInstance%E6%96%B9%E6%B3%95"><span class="toc-text">直接对类使用newInstance方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">使用构造方法实例化对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC"><span class="toc-text">通过反射为对象属性赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9F%90%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">反射某一个类的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">类加载的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%B8%89%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">虚拟机的三个类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B"><span class="toc-text">获取泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">获取父类的泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">获取接口的泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E4%B8%8A%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">获取属性上的泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8A%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">获取方法参数、返回值上的泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0%E4%B8%8A%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">获取构造方法函数上的泛型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%B3%A8%E8%A7%A3"><span class="toc-text">十一、注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-text">什么是注解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E4%B8%8E%E6%B3%A8%E9%87%8A"><span class="toc-text">注解与注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-text">框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-text">内置的注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Deprecated"><span class="toc-text">@Deprecated</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Override"><span class="toc-text">@Override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SuppressWarnings%EF%BC%88%E6%8A%91%E5%88%B6%E8%AD%A6%E5%91%8A%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%89"><span class="toc-text">@SuppressWarnings（抑制警告的注解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FunctionalInterface"><span class="toc-text">@FunctionalInterface</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">自定义注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-text">如何自定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-text">注解中定义属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">元注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Retention%EF%BC%9A%E8%AE%BE%E7%BD%AE%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BF%9D%E6%8C%81%E6%80%A7"><span class="toc-text">@Retention：设置注解的保持性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Target%EF%BC%9A%E8%AE%BE%E7%BD%AE%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">@Target：设置注解可以使用的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Documented%EF%BC%9A%E8%AE%BE%E7%BD%AE%E6%B3%A8%E8%A7%A3%E4%BC%9A%E8%A2%AB%E5%8C%85%E5%90%AB%E5%9C%A8API%E6%96%87%E6%A1%A3%E4%B8%AD"><span class="toc-text">@Documented：设置注解会被包含在API文档中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inherited%EF%BC%9A%E8%A2%AB%E6%A0%87%E6%B3%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF"><span class="toc-text">@Inherited：被标注的注解支持继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Repeatable%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%9C%B0%E6%96%B9%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E6%B3%A8%E8%A7%A3%EF%BC%88java8%EF%BC%89"><span class="toc-text">@Repeatable：设置后可以在一个地方重复使用同一注解（java8）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%B3%A8%E8%A7%A3"><span class="toc-text">反射注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">十二、网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7port"><span class="toc-text">端口号port</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-text">OSI参考模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-text">TCP&#x2F;IP参考模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%B1%BB"><span class="toc-text">网络编程基础类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InetAddress%E7%B1%BB"><span class="toc-text">InetAddress类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URL%E7%B1%BB"><span class="toc-text">URL类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-3"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-text">常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E4%B8%8E-UDP-%E5%8D%8F%E8%AE%AE"><span class="toc-text">TCP 与 UDP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">Socket 套接字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E3%80%81UDP%E5%8D%8F%E8%AE%AE"><span class="toc-text">TCP、UDP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E9%80%9A%E9%81%93%E6%89%93%E5%BC%80%EF%BC%89"><span class="toc-text">TCP 三次握手（通道打开）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E9%80%9A%E9%81%93%E5%85%B3%E9%97%AD%EF%BC%89"><span class="toc-text">四次挥手（通道关闭）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BC%96%E7%A8%8B"><span class="toc-text">基于TCP协议的编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket%E7%B1%BB"><span class="toc-text">Socket类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerSocket%E7%B1%BB"><span class="toc-text">ServerSocket类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">十三、lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Lambda和匿名内部类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">Lambda表达式的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B2%BE%E7%AE%80"><span class="toc-text">Lambda 表达式的语法精简</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">四个基本的函数式接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%88%E7%AE%80%E5%8C%96Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89"><span class="toc-text">Lambda表达式的方法引用（简化Lambda表达式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-text">方法引用的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">实例方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">静态方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">特殊方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">构造方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8"><span class="toc-text">数组引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E5%9C%A8%E9%9B%86%E5%90%88%E5%BD%93%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Lambda在集合当中的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach-%E6%96%B9%E6%B3%95"><span class="toc-text">forEach()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeIf-%E6%96%B9%E6%B3%95"><span class="toc-text">removeIf()方法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/08/app_class_2025_sum/exp5/" title="移动软件开发 实验5：第一个 HarmonyOS 应用">移动软件开发 实验5：第一个 HarmonyOS 应用</a><time datetime="2025-09-07T16:00:00.000Z" title="发表于 2025-09-08 00:00:00">2025-09-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/02/app_class_2025_sum/exp4/" title="移动软件开发 实验4：口述校史">移动软件开发 实验4：口述校史</a><time datetime="2025-09-01T16:00:00.000Z" title="发表于 2025-09-02 00:00:00">2025-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/01/app_class_2025_sum/exp3/" title="移动软件开发 实验3：微信小程序云开发">移动软件开发 实验3：微信小程序云开发</a><time datetime="2025-08-31T16:00:00.000Z" title="发表于 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/26/app_class_2025_sum/exp2/" title="移动软件开发 实验2：天气查询小程序">移动软件开发 实验2：天气查询小程序</a><time datetime="2025-08-25T16:00:00.000Z" title="发表于 2025-08-26 00:00:00">2025-08-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/25/app_class_2025_sum/exp1/" title="移动软件开发 实验1：第一个微信小程序">移动软件开发 实验1：第一个微信小程序</a><time datetime="2025-08-24T16:00:00.000Z" title="发表于 2025-08-25 00:00:00">2025-08-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://pic.imgdb.cn/item/6741310cd29ded1a8c7a7799.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By eric_zht</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>