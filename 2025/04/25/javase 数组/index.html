<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>javase 数组 | eric_zht</title><meta name="author" content="eric_zht"><meta name="copyright" content="eric_zht"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="四、数组数组概述 数组是引用数据类型，隐式继承Object，因此可以调用Object类中的方法 数组对象存储在堆内存中  数组的特点 数组长度一旦确定不可改变 所有数组对象都有length属性，用来获取数组元素个数  优点：  根据下标查找某个元素的效率极高  缺点：  随机增删的效率低，需要后移&#x2F;前移很多元素 无法存储大量数据，因为很难在内存上找到非常大的一块连续内存  一维数组静态初">
<meta property="og:type" content="article">
<meta property="og:title" content="javase 数组">
<meta property="og:url" content="http://example.com/2025/04/25/javase%20%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="eric_zht">
<meta property="og:description" content="四、数组数组概述 数组是引用数据类型，隐式继承Object，因此可以调用Object类中的方法 数组对象存储在堆内存中  数组的特点 数组长度一旦确定不可改变 所有数组对象都有length属性，用来获取数组元素个数  优点：  根据下标查找某个元素的效率极高  缺点：  随机增删的效率低，需要后移&#x2F;前移很多元素 无法存储大量数据，因为很难在内存上找到非常大的一块连续内存  一维数组静态初">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/icon.png">
<meta property="article:published_time" content="2025-04-24T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-23T07:25:43.467Z">
<meta property="article:author" content="eric_zht">
<meta property="article:tag" content="javase">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/icon.png"><link rel="shortcut icon" href="/image/favicon.png"><link rel="canonical" href="http://example.com/2025/04/25/javase%20%E6%95%B0%E7%BB%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'javase 数组',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/icon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">eric_zht</span></a><a class="nav-page-title" href="/"><span class="site-name">javase 数组</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">javase 数组</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-24T16:00:00.000Z" title="发表于 2025-04-25 00:00:00">2025-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-23T07:25:43.467Z" title="更新于 2025-05-23 15:25:43">2025-05-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">20.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>76分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h1><h2 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h2><ul>
<li>数组是引用数据类型，隐式继承Object，因此可以调用Object类中的方法</li>
<li>数组对象存储在堆内存中</li>
</ul>
<h2 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h2><ul>
<li>数组长度一旦确定不可改变</li>
<li>所有数组对象都有length属性，用来获取数组元素个数</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>根据下标查找某个元素的效率极高</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>随机增删的效率低，需要后移&#x2F;前移很多元素</li>
<li>无法存储大量数据，因为很难在内存上找到非常大的一块连续内存</li>
</ul>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="静态初始化一维数组"><a href="#静态初始化一维数组" class="headerlink" title="静态初始化一维数组"></a>静态初始化一维数组</h3><p><strong>已经知道数组中的值</strong>时使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;; 或者 <span class="type">int</span> arr[] = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;; <span class="comment">//后者不建议</span></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>用第一种就好了！</strong></p>
<h3 id="JDK5-新特性：增强for循环-for-each-循环"><a href="#JDK5-新特性：增强for循环-for-each-循环" class="headerlink" title="JDK5 新特性：增强for循环 &#x2F; for-each 循环"></a>JDK5 新特性：增强for循环 &#x2F; for-each 循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素数据类型 变量名:数组名)&#123; <span class="comment">// 变量名代表数组中的每个元素，可以自己取名</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：代码简洁</p>
<p>缺点：没有下标</p>
<h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><p><strong>不知道数组中具体存储哪些元素</strong>时使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 变量名 = <span class="keyword">new</span> 数据类型[长度]</span><br></pre></td></tr></table></figure>

<p>数组长度确定，数组中存储的每个元素将采用默认值。</p>
<h3 id="数组中如何存储不同类的对象"><a href="#数组中如何存储不同类的对象" class="headerlink" title="数组中如何存储不同类的对象"></a>数组中如何存储不同类的对象</h3><p>创建父类类型的数组，即可存子类的对象</p>
<p>eg.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Apple</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line"><span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">Object[] objs = &#123;a,b&#125;;</span><br></pre></td></tr></table></figure>

<p>存的是对象的<strong>地址</strong></p>
<h3 id="关于main方法的形参args"><a href="#关于main方法的形参args" class="headerlink" title="关于main方法的形参args"></a>关于main方法的形参args</h3><ul>
<li><p>作用：接收命令行参数用的</p>
</li>
<li><p>JVM负责调用main方法时用的 ——JVM负责给main方法准备一个String[ ]一维数组对象</p>
</li>
<li><p><code>java fileName abc def xyz</code>命令行参数：abc def xyz，JVM会将命令行参数以空格进行拆分，生成一个新的数组对象。</p>
<p>String[ ] args &#x3D; {“abc”,”def”,”xyz”};</p>
</li>
</ul>
<p>​		命令行参数有什么用？</p>
<p>​		需求：使用该系统的时候，需要提供正确的口令（用户名和密码），非法用户直接退出系统。</p>
<p>​		当两个字符串进行equals比较时，如果其中有一个字符串是字面量，建议将字面量写到前面。即：<code>&quot;string&quot;.equals(variable)</code>，避免出现空指针异常。</p>
<h3 id="可变长度的参数"><a href="#可变长度的参数" class="headerlink" title="可变长度的参数"></a>可变长度的参数</h3><p><code>function1(int ... nums)</code></p>
<ul>
<li>语法格式：<code>数据类型...</code>		</li>
<li>在形参列表中，可变长度的参数只能有一个，且只能在参数列表的末尾</li>
<li>可变长度的参数可以当做数组来看待 可通过这种方式访问：nums[0],nums[1]</li>
</ul>
<h3 id="一维数组的扩容"><a href="#一维数组的扩容" class="headerlink" title="一维数组的扩容"></a>一维数组的扩容</h3><ul>
<li><p>数组长度一旦确定不可改变</p>
</li>
<li><p>只能新建一个更大的数组，然后将原数组的数据全部拷贝到新数组中，可以使用<code>System.arraycopy()</code></p>
</li>
<li><p>数组扩容会影响程序的执行效率，因此尽可能预测数据量，减小扩容次数。</p>
</li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span> [][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>&#125;&#125;; </span><br><span class="line"><span class="comment">// 可以等长，也可以不等长</span></span><br></pre></td></tr></table></figure>

<h3 id="动态初始化-1"><a href="#动态初始化-1" class="headerlink" title="动态初始化"></a>动态初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等长</span></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 不等长</span></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>][];</span><br></pre></td></tr></table></figure>

<h2 id="Arrays-工具类"><a href="#Arrays-工具类" class="headerlink" title="Arrays 工具类"></a>Arrays 工具类</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250426165506063.png" alt="image-20250426165506063"></p>
<ul>
<li>自定义类型做比较的话，这个自定义类型必须实现Comparable接口，并实现compareTo方法。使用sort进行排序时也需要实现该方法。</li>
</ul>
<p><img src="https://pic.ericzht.space/PicGo/image-20250504092347101.png" alt="image-20250504092347101"></p>
<ul>
<li><code>int[] Arrays.copyOf()</code>是系统自动在内部新建一个数组，将原来的数组复制到新建的数组中，并返回新建的数组。而<code>System.arraycopy()</code>没有新建数组，是直接将内容复制到另一个数组中的。而且arraycopy是native方法，由c++代码实现，因此<strong>arraycopy的拷贝速度更快</strong>。</li>
</ul>
<h1 id="五、异常"><a href="#五、异常" class="headerlink" title="五、异常"></a>五、异常</h1><h2 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h2><p>java程序执行过程中的意外、错误、不正确的情况</p>
<h2 id="异常在java中的形式"><a href="#异常在java中的形式" class="headerlink" title="异常在java中的形式"></a>异常在java中的形式</h2><p>以<strong>类和对象</strong>的形式存在。</p>
<p>定义异常其实本质上就是定义一个类。</p>
<p>异常如果发生的话，在底层其实通过了这个类new了一个对象。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250504104320928.png" alt="image-20250504104320928"></p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ol>
<li>自定义异常的类需要继承Exception或者RuntimeException，如果继承的是Exception就认为这个异常是编译时异常。</li>
<li>提供两个构造方法，一个是无参数的，一个是带有String参数的，并且在构造方法中调用<code>super(String)；</code></li>
</ol>
<h2 id="处理异常的两种方法"><a href="#处理异常的两种方法" class="headerlink" title="处理异常的两种方法"></a>处理异常的两种方法</h2><ol>
<li><p>抛出异常：在类的声明中添加 <code>throws 异常类名</code></p>
<p>如果有些方法不允许使用thorws，也可以使用try catch然后在catch里面使用throw</p>
</li>
<li><p>捕捉异常</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 尝试执行的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>注：异常类型1,2,3，… 一定是从小到大的，否则如果第一个就是父类，那永远都不可能运行后面的异常处理代码了。</p>
<p>throw和throws的区别：</p>
<ol>
<li>throw是运行时的语句，真正地抛出一个异常实例</li>
<li>throws是编译时的声明，告诉编译器和调用者，如果出现这些问题就抛出。</li>
</ol>
<h2 id="JAVA7-新特性-——-异常统一处理方式"><a href="#JAVA7-新特性-——-异常统一处理方式" class="headerlink" title="JAVA7 新特性 —— 异常统一处理方式"></a>JAVA7 新特性 —— 异常统一处理方式</h2><p>1. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 尝试执行的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> | 异常类型<span class="number">2</span> 变量名)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h2 id="异常对象的方法"><a href="#异常对象的方法" class="headerlink" title="异常对象的方法"></a>异常对象的方法</h2><ul>
<li>getMessage</li>
<li>printStackTrace</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 尝试执行的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IllegalNameException e)&#123;</span><br><span class="line">    <span class="comment">// 这个方法可以获取当时创建异常对象时给异常构造方法传递的String message参数的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> e.getMessage(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印异常的堆栈信息</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">后面执行的代码</span><br></pre></td></tr></table></figure>

<p>异常的堆栈信息：</p>
<ul>
<li><p>异常信息的打印是符合栈这个数据结构的，因此优先看最上面的异常行数，最上面是最后执行的代码</p>
</li>
<li><p>打印异常堆栈信息可能出现在“后面执行的代码”前面，也可能在后面。因为高版本的底层是用多线程并行打印的。</p>
</li>
</ul>
<h2 id="finally-语句块"><a href="#finally-语句块" class="headerlink" title="finally 语句块"></a>finally 语句块</h2><p>放在该语句块中的代码是一定会执行的（无论前面的程序是否有异常），一般在finally语句块中完成资源的释放。</p>
<p>顺序：try…(catch)…finally</p>
<h2 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a>继承问题</h2><p>子类继承父类后，重写了父类的方法，重写之后<strong>不能抛出更多的异常</strong>，可以更少。</p>
<h1 id="六、常用类"><a href="#六、常用类" class="headerlink" title="六、常用类"></a>六、常用类</h1><h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h2><h3 id="为什么string-字面量不可变？"><a href="#为什么string-字面量不可变？" class="headerlink" title="为什么string 字面量不可变？"></a>为什么string 字面量不可变？</h3><p>因为底层代码中string是用byte数组存的，而byte数组是private final修饰的，因此无法修改它的值。（java8及之前是char数组）</p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><ul>
<li>如果拼接的两个字符串中有一个是变量，那么拼接后的新字符串<strong>不会</strong>放到字符串常量池中。而是在堆中。</li>
</ul>
<p>​		<strong>底层在进行拼接时，会创建一个StringBuilder对象，进行字符串拼接。最后自动调用StringBuilder对象中的<code>toString()</code>方法，再将StringBuilder对象转换成String对象。</strong></p>
<ul>
<li>两个字符串字面量拼接会在编译阶段做优化，在编译阶段进行拼接（可以这么理解，但不准确）因此<strong>字符串常量池中只有拼接后的内容</strong>。</li>
</ul>
<h3 id="怎么把字符串手动放进字符串常量池？"><a href="#怎么把字符串手动放进字符串常量池？" class="headerlink" title="怎么把字符串手动放进字符串常量池？"></a>怎么把字符串手动放进字符串常量池？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> m.intern(); <span class="comment">// 将&quot;test&quot;放入字符串常量池，并且将&quot;test&quot;对象的地址返回。如果字符串常量池已经存在&quot;test&quot;，那么就直接返回地址。</span></span><br></pre></td></tr></table></figure>

<p>只能加东西，不能删东西。</p>
<h3 id="String类常用的构造方法"><a href="#String类常用的构造方法" class="headerlink" title="String类常用的构造方法"></a>String类常用的构造方法</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250504170631964.png" alt="image-20250504170631964"></p>
<h3 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250504172720448.png" alt="image-20250504172720448"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250504174128601.png" alt="image-20250504174128601"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250505133142362.png" alt="image-20250505133142362"></p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250505134512560.png" alt="image-20250505134512560"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250505134535133.png" alt="image-20250505134535133"></p>
<h4 id="String-中正则表达式相关的方法"><a href="#String-中正则表达式相关的方法" class="headerlink" title="String 中正则表达式相关的方法"></a>String 中正则表达式相关的方法</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250505135051207.png" alt="image-20250505135051207"></p>
<h2 id="StringBuffer-与-StringBuilder-可变长度字符串"><a href="#StringBuffer-与-StringBuilder-可变长度字符串" class="headerlink" title="StringBuffer 与 StringBuilder 可变长度字符串"></a>StringBuffer 与 StringBuilder 可变长度字符串</h2><ul>
<li>这两个类是专门为频繁进行字符串拼接而准备的</li>
<li>StringBuffer是先出现的，Java5时新增了StringBuilder。StringBuffer是线程安全的，而StringBuilder效率更高。</li>
<li>两者底层都是byte[]数组，并且没有被final修饰，因此可以扩容。</li>
<li><strong>优化策略：创建对象时预估好字符串的长度，给定一个合适的初始化容量，减少底层数组扩容的次数。</strong></li>
<li>StringBuilder默认初始化容量：16</li>
<li><strong>StringBuilder扩容策略：每次扩容为原来的两倍+2</strong></li>
</ul>
<p><strong>为什么频繁拼接字符串时使用StringBuilder&#x2F;StringBuffer更好？</strong></p>
<p>使用“+”进行拼接，底层每次都会创建一个StringBuilder对象，然后再调用toString方法，10000次拼接就要创建10000次对象，同时给垃圾回收也造成了很大的压力。</p>
<p>而StringBuilder的append不创建新对象，直接在原来的位置进行拼接，且不调用toString方法，只有用print输出的时候才调用一次，因此节省了大量的时间。</p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250506204324943.png" alt="image-20250506204324943"></p>
<p>包装类中的6个数字类型都继承了Number类</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250506204542750.png" alt="image-20250506204542750"></p>
<p><strong>装箱boxing：</strong>将基本数据类型包装成引用数据类型 <code>Integer i = new Integer(100);</code></p>
<p>拆箱：<code>int num = i.intValue()</code></p>
<h3 id="Integer-常用方法"><a href="#Integer-常用方法" class="headerlink" title="Integer 常用方法"></a>Integer 常用方法</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250506205907163.png" alt="image-20250506205907163"></p>
<h3 id="String、int、Integer-三者相互转换"><a href="#String、int、Integer-三者相互转换" class="headerlink" title="String、int、Integer 三者相互转换"></a>String、int、Integer 三者相互转换</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250506211343316.png" alt="image-20250506211343316"></p>
<h3 id="自动装箱-拆箱（JAVA5新特性）"><a href="#自动装箱-拆箱（JAVA5新特性）" class="headerlink" title="自动装箱&#x2F;拆箱（JAVA5新特性）"></a>自动装箱&#x2F;拆箱（JAVA5新特性）</h3><p>编译阶段的功能，底层仍然是之前的装箱&#x2F;拆箱。只是让你编程的时候方便一点。</p>
<h4 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h4><p><code>Integer x = 100;</code></p>
<h4 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h4><p><code>int num = x;</code></p>
<h3 id="整数型常量池"><a href="#整数型常量池" class="headerlink" title="整数型常量池"></a>整数型常量池</h3><p>[-128~127]这些数字太常用了，为了提高效率，Java提供了一个整数型常量池。</p>
<p>这个常量池是一个数组：Integer[ ] integerCache; </p>
<p>数组中存储了256个Integer的引用，只要没有超出这个范围的数字，直接从整数型常量池中取。</p>
<h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>大数字：</p>
<ul>
<li>超过long了使用java.math.BigInteger</li>
<li>他的父类是Number</li>
<li>他是引用数据类型</li>
</ul>
<p>常用方法：</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250506213606778.png" alt="image-20250506213606778"></p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>浮点型超过double就使用BigDecimal</p>
<p>构造方法：BigDecimal(String val)</p>
<p>常用方法：</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507104150446.png" alt="image-20250507104150446"></p>
<h3 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>该类是专门用来对数字进行格式化的。</p>
<p>常用数字格式：</p>
<ul>
<li>###,###.##        三个数字为一组，组和组之间使用逗号隔开，保留两位小数</li>
<li>###,###.0000    三个数字为一组，组和组之间使用逗号隔开，保留4位小数，不够补0</li>
</ul>
<p>构造方法：DecimalFormat(String pattern)</p>
<p>常用方法：String format(数字)</p>
<h2 id="日期相关API"><a href="#日期相关API" class="headerlink" title="日期相关API"></a>日期相关API</h2><h3 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.Date 日期API</span></span><br><span class="line"><span class="comment">// 获取系统当前时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取指定的时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(输入毫秒数) <span class="comment">//1970年0时0分0秒 + 输入的毫秒数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取1970到当前的毫秒数,这是java.lang.System类的方法。</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure>

<h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTest01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(输入格式的字符串) <span class="comment">// 各种格式见文档</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sdf.format(输入要转换的时间) <span class="comment">// 日期转格式化字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将String转化成Date"><a href="#将String转化成Date" class="headerlink" title="将String转化成Date"></a>将String转化成Date</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> <span class="string">&quot;2008-08-08 08:08:08 888&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf2.parse(strDate); <span class="comment">// 用自己创建的格式去解析字符串中的日期</span></span><br></pre></td></tr></table></figure>

<h3 id="java-util-Calend-ar-日历类"><a href="#java-util-Calend-ar-日历类" class="headerlink" title="java.util.Calend ar 日历类"></a>java.util.Calend ar 日历类</h3><h4 id="获取当前时间的日历对象"><a href="#获取当前时间的日历对象" class="headerlink" title="获取当前时间的日历对象"></a>获取当前时间的日历对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure>

<h4 id="获取日历中的某部分"><a href="#获取日历中的某部分" class="headerlink" title="获取日历中的某部分"></a>获取日历中的某部分</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250507111805395.png" alt="image-20250507111805395"></p>
<h4 id="修改日历中的内容"><a href="#修改日历中的内容" class="headerlink" title="修改日历中的内容"></a>修改日历中的内容</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250507113921982.png" alt="image-20250507113921982"></p>
<h2 id="日历的新API（java8）"><a href="#日历的新API（java8）" class="headerlink" title="日历的新API（java8）"></a>日历的新API（java8）</h2><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>传统的日期API存在线程安全问题，于是java8提供了一套全新的日期API</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507114255117.png" alt="image-20250507114255117"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507114954817.png" alt="image-20250507114954817"></p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507115444014.png" alt="image-20250507115444014"></p>
<h3 id="计算时间间隔、日期间隔"><a href="#计算时间间隔、日期间隔" class="headerlink" title="计算时间间隔、日期间隔"></a>计算时间间隔、日期间隔</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507115627185.png" alt="image-20250507115627185"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507115736786.png" alt="image-20250507115736786"></p>
<h3 id="时间矫正器"><a href="#时间矫正器" class="headerlink" title="时间矫正器"></a>时间矫正器</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507115810587.png" alt="image-20250507115810587"></p>
<h3 id="日期格式化-1"><a href="#日期格式化-1" class="headerlink" title="日期格式化"></a>日期格式化</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507115949312.png" alt="image-20250507115949312"></p>
<p>注意：这里使用LocalDateTime去调用parse方法，还需要把格式作为参数传入。</p>
<h2 id="数学类-Math"><a href="#数学类-Math" class="headerlink" title="数学类 Math"></a>数学类 Math</h2><p>回顾：工具类的方法都是静态的，直接使用类名调用。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507141230707.png" alt="image-20250507141230707"></p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可读性强</li>
<li>做了类型的限定，在编译阶段就可以确定类型是否正确，不正确会报错</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举类型名 &#123;</span><br><span class="line">	枚举值<span class="number">1</span>,枚举值<span class="number">2</span>,枚举值<span class="number">3</span>,枚举值<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507142735026.png" alt="image-20250507142735026"></p>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250507143828351.png" alt="image-20250507143828351"></p>
<h2 id="Random-随机数生成器"><a href="#Random-随机数生成器" class="headerlink" title="Random 随机数生成器"></a>Random 随机数生成器</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250507144042746.png" alt="image-20250507144042746"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">101</span>); <span class="comment">// 生成一个[0,101)的随机数</span></span><br></pre></td></tr></table></figure>



<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250507165944744.png" alt="image-20250507165944744"></p>
<h2 id="UUID-通用唯一标识符"><a href="#UUID-通用唯一标识符" class="headerlink" title="UUID 通用唯一标识符"></a>UUID 通用唯一标识符</h2><p>UUID是一种软件构建的标准，用来生成具有唯一性的ID。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250507170341895.png" alt="image-20250507170341895"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> uuid.toString();</span><br></pre></td></tr></table></figure>



<h1 id="七、集合"><a href="#七、集合" class="headerlink" title="七、集合"></a>七、集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><ul>
<li><p>集合是一种容器，用来组织和管理数据。</p>
</li>
<li><p>Java的集合框架对应的这套类库其实就是<strong>对各种数据结构的实现</strong>。</p>
</li>
<li><p>集合存储的是<strong>引用</strong>。</p>
</li>
<li><p>默认情况下，如果不使用泛型，集合中可以存储任何类型的引用。</p>
</li>
</ul>
<p>Java集合框架分为两部分：</p>
<ol>
<li>Collection结构：元素以单个的形式存储</li>
<li>Map结构：元素以键值对的映射关系存储</li>
</ol>
<h2 id="Collection-关系图"><a href="#Collection-关系图" class="headerlink" title="Collection 关系图"></a>Collection 关系图</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250509151443189.png" alt="image-20250509151443189"></p>
<h2 id="Collection接口的通用方法"><a href="#Collection接口的通用方法" class="headerlink" title="Collection接口的通用方法"></a>Collection接口的通用方法</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250507205015673.png" alt="image-20250507205015673"></p>
<h2 id="Collection的通用遍历-迭代方式"><a href="#Collection的通用遍历-迭代方式" class="headerlink" title="Collection的通用遍历&#x2F;迭代方式"></a>Collection的通用遍历&#x2F;迭代方式</h2><p><strong>面向接口编程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步：获取集合的迭代器对象</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> col.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：判断光标当前指向的位置是否有元素</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">// 第三步：光标返回当前指向的内容，并移动到下一个元素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SequencedCollection接口"><a href="#SequencedCollection接口" class="headerlink" title="SequencedCollection接口"></a>SequencedCollection接口</h2><p>所有的有序集合都实现了SequencedCollection接口</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250508113038478.png" alt="image-20250508113038478"></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li>java5新特性，是编译阶段的功能。</li>
</ul>
<h3 id="泛型初体验"><a href="#泛型初体验" class="headerlink" title="泛型初体验"></a>泛型初体验</h3><ul>
<li>程序编写时看帮助文档中是否有”&lt;&gt;”符号，如果有这个符号就可以使用泛型。</li>
<li>创建一个集合，要求这个集合中只能存放某种类型的对象，就可以使用泛型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line"></span><br><span class="line">Iterator&lt;User&gt; it = users.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> it.next();</span><br><span class="line">    user.pay()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不用泛型，it.next()返回的类型是Object，还需要向下转型才能使用子类独有的方法。而使用了泛型后，迭代器返回的类型就自动向下转型为子类了。</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250509192841450.png" alt="image-20250509192841450"></p>
<h3 id="钻石表达式-（Java7新特性）"><a href="#钻石表达式-（Java7新特性）" class="headerlink" title="钻石表达式 （Java7新特性）"></a>钻石表达式 （Java7新特性）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() <span class="comment">// 后面尖括号中的内容可以省略</span></span><br></pre></td></tr></table></figure>



<h3 id="泛型擦除与补偿（了解）"><a href="#泛型擦除与补偿（了解）" class="headerlink" title="泛型擦除与补偿（了解）"></a>泛型擦除与补偿（了解）</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250508140247873.png" alt="image-20250508140247873"></p>
<h3 id="泛型的定义"><a href="#泛型的定义" class="headerlink" title="泛型的定义"></a>泛型的定义</h3><h4 id="在类上自定义泛型"><a href="#在类上自定义泛型" class="headerlink" title="在类上自定义泛型"></a>在类上自定义泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">vip</span>&lt;NameType, AgeType&gt;&#123; <span class="comment">// 在声明类时写上泛型名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">vip</span><span class="params">(NameType name, AgeType age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> NameType name;</span><br><span class="line">    <span class="keyword">private</span> AgeType age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在类上定义的泛型，在静态方法中无法使用。</strong>（因为静态方法直接通过类名调用，此时还没有通过声明类的对象来指定泛型的类型。）</p>
<h4 id="在静态方法上定义泛型"><a href="#在静态方法上定义泛型" class="headerlink" title="在静态方法上定义泛型"></a>在静态方法上定义泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(T element)</span>&#123; <span class="comment">// 在使用前需要先定义泛型</span></span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        test.print(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="在接口上定义泛型"><a href="#在接口上定义泛型" class="headerlink" title="在接口上定义泛型"></a>在接口上定义泛型</h4><p>和类定义泛型差不多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyCompare</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T element)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一种实现接口的方式：此时我已经知道泛型要用什么类型了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> <span class="keyword">implements</span> <span class="title class_">MyCompare</span>&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        比较的代码;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现接口的方式：此时还不知道泛型用什么类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyCompare</span>&lt;T&gt;&#123; <span class="comment">// 再给类定义一个泛型，然后等创建对象时再确定泛型的类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T a)</span>&#123; <span class="comment">// 或者这个时候就不要用泛型了，直接把参数的类型写成 Object</span></span><br><span class="line">        比较的代码;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><h5 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h5><?> 此处表示后面填写的泛型可以是任意数据类型。

![image-20250508151444447](https://pic.ericzht.space/PicGo/image-20250508151444447.png)



##### 上限通配符

<? extends Number> 表示泛型必须为Number及其子类



##### 下限通配符

<？ super Number> 表示泛型必须为Number及其父类



## 集合的并发修改问题 fail-fast 机制

- 集合中设置了一个modCount属性，用来记录修改的次数，使用集合对象执行增删改的操作时，modCount就会自动加1。

- 获取迭代器对象时，会给迭代器对象初始化一个expectedModCount属性，并且将modCount的值赋值给expectedModCount。

  即`int expectedModCount = modCount;`

- 当使用集合对象删除元素时，modCount会加1，但是迭代器中的expectedModCount没有加1。而当迭代起对象的`next()`方法执行时，会检测expectedModCount和modCount是否相等，如果不相等，就会抛出ConcurrentModificationException异常

- 而如果使用迭代起删除元素时，modCount和expectedModCount都会加1.这样next()方法在检测时就是相等的，不会出现异常。

注：即使没有使用多线程编程，但是用迭代器去遍历的同时使用集合去删除元素，这个行为将被认为并发修改。

**所以，迭代集合时，要使用 `迭代器对象.remove()`，移除的是当前光标所执行的元素。**



## List 接口

### 特点

有序、可重复

### 常见的实现类

- ArrayList 数组
- Vector、Stack 数组（线程安全的）
- LinkedList 双向链表

### List接口特有的方法

![image-20250508164614700](https://pic.ericzht.space/PicGo/image-20250508164614700.png)

### List特有的迭代方式

![image-20250508211934510](https://pic.ericzht.space/PicGo/image-20250508211934510.png)

注：调用迭代器的remove和set方法的前提是之前调用了next或者previous方法获取了一个元素，remove和set是作用于之前获取的那个元素上的。

### List接口使用Comparator排序

#### 回顾数组中自定义类型是如何排序的？

- 所有自定义类型排序时必须指定排序规则，实现Comparable接口，并重写compareTo方法。   *重写是override*

#### List集合的排序

- default void sort(Comparator<? super E> c);
- sort方法需要一个参数：java.util.Comparator ，我们把它叫做比较器，它是一个接口。
- 如何给自定义类型指定比较规则？可以对Comparator提供一个实现类，并重写compare方法来指定比较规则
- 这个实现类也可以看采用匿名内部类的方式。

**对数组的排序是在类里面重写比较规则，对List集合的排序是单独设定一个比较规则并在需要时使用。**



## ArrayList 类

### 回顾：数组的优缺点

#### 优点

数组在内存中是连续存储的，有下标就有偏移量，可以通过偏移量计算出对应元素的内存地址。检索效率高，时间复杂度O（1）

#### 缺点

1. 不能存储大数据（因为内存地址是连续的）
2. 随机增删元素耗时很长

#### 使用场景

需要频繁检索元素，很少进行随机增删的情况。

### ArrrayList扩容策略

1. 当调用无参构造方法时，初始化容量为0。
2. 当第一次调用add方法时，将ArrayList容量初始化为10个长度。
3. 后续扩容时，底层会创建一个新的数组，然后使用数组拷贝。新数组的容量是原容量的1.5倍。



## Vector 类（*不怎么使用了）

![image-20250509151626055](https://pic.ericzht.space/PicGo/image-20250509151626055.png)



## LinkedList 双向链表类 

![image-20250509161904153](https://pic.ericzht.space/PicGo/image-20250509161904153.png)



## 栈 数据结构

![image-20250509162034647](https://pic.ericzht.space/PicGo/image-20250509162034647.png)

![image-20250509162149438](https://pic.ericzht.space/PicGo/image-20250509162149438.png)

## 队列 数据结构

![image-20250509163049904](https://pic.ericzht.space/PicGo/image-20250509163049904.png)

入队：offer

出队：poll



## 三种Set

![image-20250509164743958](https://pic.ericzht.space/PicGo/image-20250509164743958.png)

map和set的关系

map是键值对，把键那一列单独拿出来，就是set集合。



## Map 

![image-20250509165852628](https://pic.ericzht.space/PicGo/image-20250509165852628.png)

### Map 接口的常用方法

![image-20250509193744059](https://pic.ericzht.space/PicGo/image-20250509193744059.png)

### Map 集合的遍历

#### 方法一：获取Map集合的所有key，然后遍历每个key，通过key获取value

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; keys = maps.keySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">Iterator&lt;Integer&gt; it = keys.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">	System.out.println(key + <span class="string">&quot;=&quot;</span> + maps.get(key))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">for</span>(Integer key : keys)&#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;=&quot;</span> + maps.get(key))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



#### 方法二：获取Map的内部类Map.Entry (效率更高，常用这个)

不需要再通过key去找value了

![image-20250509195622488](https://pic.ericzht.space/PicGo/image-20250509195622488.png)

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> entries.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;Integer,String&gt; entry = it.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer,String&gt; entry : entries)&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### HashMap

#### 哈希表存储原理

![image-20250509210206127](https://pic.ericzht.space/PicGo/image-20250509210206127.png)

#### ！！hashCode和equals方法要同时重写

使用equals的前提条件是两个元素计算得到的索引值是相同的，在同一个链表中。那么保证这两个元素使用hashCode()返回的结果是相同的才能准确的保证索引值相同。

**因此，存放在HashMap集合key部分的元素，以及存放在HashSet集合中的元素，需要同时重写hashCode和equals方法**



#### HashMap在Java8后的改进

##### 初始化时机

java8之前，构造方法执行初始化table数组

java8之后，第一次调用put方法时初始化table数组



##### 插入方法

java8之前：头插法

java8之后：尾插法



##### 数据结构

java8之前：数组+单向链表

java8之后：数组+单向链表/红黑树

- 如果结点数量>=8，且table长度>=64，单向链表转为红黑树
- 当删除红黑树上的结点，使节点数量<=6时，红黑树转换为单向链表



#### HashMap的容量永远是2的次幂

原因：

1. 提高哈希计算的效率（位运算的效率比%取模运算效率高）

   当length为2的次幂时,length-1的二进制低位全是1，此时`hash & (length - 1)` 相当于 **保留 `hash` 的低 `n` 位**，结果与`hash%length`一致，使用位运算效率更高。

2. 减少哈希冲突，让散列分布更加均匀

   假设length是偶数，length-1结果一定是奇数，它的二进制中的最后一位一定是1，和别人相与可能是0或1。如果length是奇数，length-1是偶数，那么二进制最后一位是0，和别人相与只能是0，那么最后table有一半都是空的，存不了东西。

   

#### HashMap的初始化容量设置

1. 当哈希表中的元素越来越多时，散列碰撞的几率就会越来越高，导致单链表过长，降低了哈希表的性能，此时要进行哈希表扩容
2. 而一旦进行扩容，由于length改变，所有元素的hash值都会改变，效率比较低，所以在初始化的时候最好设置好数组大小，避免过多次数的扩容。
3. 扩容时间点：当哈希表中的元素个数超过`数组大小*0.75`后进行扩容，新数组大小为`2*原数组大小`



### LinkedHashMap

1. LinkedHashMap是HashMap集合的子类
2. 用法和HashMap几乎一样
3. 只不过LinkedHashMap可以保证元素的插入顺序
4. 底层数据结构：哈希表+双向链表（记录顺序）

![image-20250511152438610](https://pic.ericzht.space/PicGo/image-20250511152438610.png)

### Hashtable（效率低，不常用）

![image-20250511153454341](https://pic.ericzht.space/PicGo/image-20250511153454341.png)

![image-20250511154424681](https://pic.ericzht.space/PicGo/image-20250511154424681.png)

![image-20250511154408581](https://pic.ericzht.space/PicGo/image-20250511154408581.png)

### Properties 属性类

![image-20250511155031484](https://pic.ericzht.space/PicGo/image-20250511155031484.png)

### TreeMap

#### 排序二叉树

按照左小右大存储，按照中序遍历自动得到升序排列的元素。

缺点：如果插入的节点集本来就是有序的，那么最后得到的二叉树其实就是一个普通链表，检索效率很差。

![image-20250511155728257](https://pic.ericzht.space/PicGo/image-20250511155728257.png)

#### 平衡二叉树

![image-20250511160248989](https://pic.ericzht.space/PicGo/image-20250511160248989.png)



#### 红黑二叉树

一棵自平衡的排序二叉树

#### 构造方法

一个是没有参数的，一个是需要传比较器的

#### put() 方法

先调用比较器，如果比较器是NULL，就使用类中的compareTo方法进行比较。

因此有两种方式来修改比较方法。

**法一：**实现Comparable<>接口，并重写compareTo方法

**适用于比较规则不会改变的情况**，比如数字、字符串的比较



**法二：**再写一个类去实现Comparator<>接口，重写compare方法，在创建对象时将比较器传递给TreeMap

适用于比较规则会改变的情况



### 总结：哪些集合不能添加NULL

- Hashtable的key、value

- Properties的key、value

- TreeMap的key

​        -> TreeSet不能添加null

### Collections 工具类

![image-20250512120540553](https://pic.ericzht.space/PicGo/image-20250512120540553.png)

# 八、IO流

## IO流概述

### 分类

#### 根据流向分

输入流（read）、输出流（write）

#### 根据读写数据的形式分

- 字节流：**一次读取一个字节**。适合读取非文本数据，比如图片、音频、视频等。

- 字符流：**一次读取一个字符**。只适合读取普通文本，不适合读取二进制文件。因为字符流统一使用Unicode编码，可以避免出现编码混乱的问题。

#### 根据流在IO操作中的作用和实现方式分

- 节点流：负责数据源和数据目的地的连接，是IO中最基本的组成部分。
- 处理流：处理流对节点流进行装饰/包装，提供更多高级处理操作，方便用户进行数据处理。

### IO流体系结构

![image-20250512150234321](https://pic.ericzht.space/PicGo/image-20250512150234321.png)

InputStream 字节输入流

OutputStream 字节输出流

Reader 字符输入流

Writer 字符输出流



- 所有流都实现了Closable接口，都有`close()`方法，流用完要关闭。

- 所有的输出流都实现了Flushable，都有`flush()`方法，flush方法的作用是，将缓存全部写出并清空。



## FileInputStream 类

称为文件字节输入流，是一个万能流，任何文件都能读，但还是建议读二进制文件，例如图片、声音、视频。

### 常用构造方法

`FileInputStream(String name)`通过文件路径构建一个文件字节输入流对象。

注意: 反斜杠需要使用转义字符，即两个反斜杠 `\\`

也可使用一个正的斜杠 `/`

### 使用方法

#### int read();

调用一次read()方法就读取一个字节，返回读到的字节本身。如果读不到任何数据则返回-1



#### int read(byte[] b);

一次最多可以读到b.length个字节（只要文件内容足够多），返回值是读取到的字节数。读取的内容存在b数组中。



#### int read(byte[] b, int off, int len);

一次读取len个字节，将读到的数据从byte数组的off位置开始放



#### long skip(long n);

跳过n个字节



#### int available();

获取流中剩余的预估计字节数。

可以用这个初始化数组长度，这样就不需要使用循环来判断是否还有可读取的内容。



#### void close()；

关闭流



## FileOutputStream

文件字节输出流，负责写。

### 常用构造方法

1. FileOutputStream(String name) 创建一个文件字节输出流对象，这个流在使用时，会先将原文件内容全部清空，然后写入。
2. FileOutputStream(String name, boolean append)

​		创建一个文件字节输出流对象，当append是true时，不会清空原文件的内容，在原文件末尾追加。

​		当append是false时，会清空原文件的内容，在原文件末尾追加。



### 常用方法

#### void close();

#### void flush();

刷新

#### void write(int b);

写一个字节

#### void write(byte[] b);

将整个byte字节数组写入

#### void write(byte[] b, int off, int len);

将byte字节数组的一部分写入



## TryWithResources 资源自动关闭 Java7新特性

凡是实现了AutoCloseable接口的流都可以使用try-with-resources，都会自动关闭。

格式：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(   </span><br><span class="line">   声明流;</span><br><span class="line">   声明流;</span><br><span class="line">   声明流;</span><br><span class="line">   声明流)&#123;  <span class="comment">// 最后一个不用写分号</span></span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

![image-20250512214659872](https://pic.ericzht.space/PicGo/image-20250512214659872.png)

## FileReader 读取普通文本

![image-20250513154453660](https://pic.ericzht.space/PicGo/image-20250513154453660.png)

## FileWriter

![image-20250513155041546](https://pic.ericzht.space/PicGo/image-20250513155041546.png)

**注意：只能复制普通文本文件！！！**

## 路径

绝对路径、相对路径、**类路径**

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;filename&quot;</span>).getPath();</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure>

`Thread.currentThread()` 获取当前线程

`Thread.currentThread().getContextClassLoader()` 获取当前线程的类加载器

`getResource("filename")` 从类的根路径下开始加载资源

**src文件夹是类路径的根路径**

优点：通用，在进行系统移植的时候，仍然可以使用。

注：这种方式只能从类路径中加载资源，如果这个资源在类路径之外，就无法访问到。

## BufferedInputStream/BufferedOutputStream

### 对缓冲流的理解

![image-20250514101835840](https://pic.ericzht.space/PicGo/image-20250514101835840.png)

### 使用

![image-20250514103000835](https://pic.ericzht.space/PicGo/image-20250514103000835.png)

**1️⃣为什么这里仍然需要使用数组呢？**

这个数组是接收缓冲区中的大数组中的内容，它本身不和文件进行交互。

### 标记

`mark()` 在当前位置打上标记

`reset()` 回到**上一次**打标记的位置

**一个文件中最多只有一个标记**

调用顺序：先调用mark，再调用reset

## 如何解决乱码问题

![image-20250514111017372](https://pic.ericzht.space/PicGo/image-20250514111017372.png)

> *所有输入输出底层都需要使用字节流，而字符流是将字节流包装后得到的。进行了这种包装操作的流叫包装流。*

- 使用InputStreamReader/OutputStreamWriter时可以指定解码的字符集。

- 常用构造方法：
  1. `InputStreamReader(InputStream in)` 采用平台默认的字符集进行解码
  2. `InputStreamReader(InputStream in, String charsetName)` 采用指定的字符集进行解码

- FileReader是InputStreamReader的子类，是一个包装流。

​		FileWriter同理。

- InputStreamReader/OutputStreamWriter 的创建需要传入字节流，而FileReader/FileWriter 的创建直接输入文件地址即可。



## 数据流

- 将java程序中的数据直接写入文件，写进去就是二进制。

- 效率很高——写的过程不用转码

- DataOutputStream写到文件中的数据，只能由DataInputStream来读取
- 读取顺序必须按照写入顺序！

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入</span></span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;filename&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">222</span>;</span><br><span class="line"></span><br><span class="line">dos.writeByte(b1);</span><br><span class="line">dos.writeShort(s1);</span><br><span class="line"></span><br><span class="line">dos.flush();</span><br><span class="line">dos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;filename&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> dis.readByte();</span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> dis.readShort();</span><br><span class="line">dis.close();</span><br></pre></td></tr></table></figure>

## 对象的序列化与反序列化

序列化：将对象变成二进制文件

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"><span class="type">Date</span> <span class="variable">nowDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 序列化Serial</span></span><br><span class="line">oos.writeObject(nowTime); </span><br><span class="line"></span><br><span class="line">oos.flush();</span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>



反序列化：将字节序列转换成JVM中的java对象

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject(); <span class="comment">// 如果明确知道对象的类型，可以强转。</span></span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure>

如果是多个对象，那就把这些对象放在集合中。

要参与序列化与反序列化的对象，**必须实现 `java.io.Serializable` 接口**。该接口是一个标志接口，没有任何方法。

- ObjectOutputStream也有关于数据输出的方法，比如`writeInt()`、`writeBoolean()`等，和DataOutputStream中的方法一样。

### 序列化版本号

- 为了保证序列化的安全，只有同一个类的对象才能序列化和反序列化。在java中 通过 类名 + 序列化版本号（serialVersionUID）来判断。

- 当类的内容修改后，serialVersionUID会改变，java程序不允许序列化版本号不同的类进行反序列化。

- 那如果几个月后，对这个类进行了升级，增加了一些内容怎么办？

​		如果确定这个类确实是之前的那个类，类本身是合法的，可以将序列化版本号**写死**。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1231231231231L</span>;</span><br></pre></td></tr></table></figure>

### serial注解

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serial</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serial</span> <span class="comment">// 会自动检查下面的序列号代码是否拼错，在这里alt+回车可以自动生成一个序列号版本。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1231231231231L</span>;</span><br></pre></td></tr></table></figure>

### transient关键字

transient关键字修饰的属性不会参与序列化。

所以进行反序列化的时候这个属性会赋默认值。

## 打印流 PrintStream/PrintWriter

### PrintStream

主要用于打印，提供便携的打印方法和格式化输出。主要打印内容到文件或控制台。

不需要手动刷新。

#### 构造方法

`PrintStream(OutputStream out);`

`PrintStream(String filename);`

#### 常用方法

`print(Type x);`

`println(Type x);`

![image-20250514160807745](https://pic.ericzht.space/PicGo/image-20250514160807745.png)

### PrintWriter

比PrintStream多一个构造方法：`PrintWriter(Writer);`



## 标准输入流 System.in

用来接收用户在控制台上的输入。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> System.in;</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> in.read(bytes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; readCount; i++)&#123;</span><br><span class="line">    System.out.println(bytes[i]); <span class="comment">// 这个是逐个输出每个字节的内容，不适合中文等内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

对于标准输入流来说，也可以改变数据源。不让其从控制台读数据，而是从文件中/网络中读取数据。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改标准输入流的数据源</span></span><br><span class="line">System.setIn(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> System.in;</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((readCount = in.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,readCount));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



## 标准输出流 System.out

用于输出内容到控制台。

改变输出方向：(常用于记录日志)

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;zhangsan&quot;</span>);</span><br></pre></td></tr></table></figure>



## File类

文件/目录的抽象表示形式。

### 构造方法

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:/filename&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不存在就以新文件的形式创建</span></span><br><span class="line"><span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不存在就以目录的形式创建</span></span><br><span class="line"><span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">    file.mkdir();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不存在就创建多层文件夹</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:/a/b/c/d&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!file2.exist())&#123;</span><br><span class="line">    file2.mkdirs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 常见方法见文档。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:/directoryAddress&quot;</span>);</span><br><span class="line">File[] files = file.listFiles() <span class="comment">// 直接获取所有文档</span></span><br><span class="line">File[] files2 = file.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>())&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.txt&quot;</span>); <span class="comment">// 进行判断，如果结果不是txt就返回false，就不选中这些文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 读取属性配置文件

- xxx.properties 文件称为属性配置文件
- 属性配置文件可以配置一些简单的信息，例如连接数据库的信息通常配置到属性文件中。这样可以做到在不修改java代码的前提下，切换数据库。
- 属性配置文件的格式:

​		key1 = value1

​		key2 = value2

​		...

​		注：使用#进行注释，key不能重复，否则value会被覆盖。等号两边不能有空格。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;filename&quot;</span>).getPath();</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(path);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建一个Map集合（属性类对象） </span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性配置文件中的配置信息加载到Properties对象中。</span></span><br><span class="line">pro.load(reader) </span><br><span class="line">    </span><br><span class="line"><span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br></pre></td></tr></table></figure>



### ResourceBundle进行资源绑定

![image-20250514215334331](https://pic.ericzht.space/PicGo/image-20250514215334331.png)



## 装饰器设计模式

符合OCP的情况下怎么完成对类功能的扩展？

- 使用子类对父类进行方法扩展。但这种方法会导致两个问题：代码耦合度高、类爆炸问题（会有很多类）
- 装饰器设计模式：可以做到在不修改原有代码的基础上，完成功能扩展，符合OCP原则，并且避免了使用继承带来的类爆炸问题。

装饰器设计模式中涉及的角色：

1. 抽象的装饰者
2. 具体的装饰者1、具体的装饰者2
3. 被装饰者
4. 装饰者和被装饰者的公共接口/公共抽象类

**IO流中使用了大量的装饰器设计模式。**

![image-20250515164725487](https://pic.ericzht.space/PicGo/image-20250515164725487.png)

## 压缩流

### 压缩流的使用

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GZIPOutputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件字节输入流（读某个文件，这个文件将来就是被压缩的。）</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;e:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个GZIP压缩流对象</span></span><br><span class="line">        <span class="type">GZIPOutputStream</span> <span class="variable">gzip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;e:/test.txt.gz&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始压缩（一边读一边写）</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((readCount = in.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            gzip.write(bytes, <span class="number">0</span>, readCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非常重要的代码需要调用</span></span><br><span class="line">        <span class="comment">// 刷新并且最终生成压缩文件。</span></span><br><span class="line">        gzip.finish();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭流</span></span><br><span class="line">        in.close();</span><br><span class="line">        gzip.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 解压缩流的使用

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GZIPInputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建GZIP解压缩流对象</span></span><br><span class="line">        <span class="type">GZIPInputStream</span> <span class="variable">gzip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;e:/test.txt.gz&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件字节输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;e:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一边读一边写</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((readCount = gzip.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes, <span class="number">0</span>, readCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭流</span></span><br><span class="line">        gzip.close();</span><br><span class="line">        <span class="comment">// 节点流关闭的时候会自动刷新，包装流是需要手动刷新的。</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**注：节点流关闭时会自动刷新，包装流需要手动刷新。**

## 字节数组流

1. ByteArrayInputStream、ByteArrayOutputStream都是内存操作流，不需要打开和关闭文件等操作。这些流是非常常用的，可以将它们看作开发中的常用工具，能够方便地读写字节数组、图像数据等内存中的数据。
2. 都是节点流。

![image-20250516105141032](https://pic.ericzht.space/PicGo/image-20250516105141032.png)

### 使用对象流装饰字节数组流

**！！为什么要这样做？**

你使用字节数组流直接写入、读出可能只能读取普通的字节数组，还需要自己实现一些转换成复杂类型（各种类）的方法，而包装流已经在内部包含了很多将复杂类型序列化的方法，**一行代码就可以帮你直接序列化复杂类型然后写入字节流**。



## 对象深克隆

目前为止对象拷贝方式：

1. 调用Object的clone方法，默认是浅克隆，需要深克隆的话，就需要重写clone方法
2. 可以通过序列化和反序列化完成对象的克隆（深克隆）

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCloneTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 准备对象</span></span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;朝阳&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>, addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将Java对象写到一个byte数组中。</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(user);</span><br><span class="line"></span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从byte数组中读取数据恢复java对象</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这就是那个经过深拷贝之后的新对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line"></span><br><span class="line">        user2.getAddr().setCity(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



# 九、多线程

## 概述

### 多线程

1. 进程：操作系统中的一段程序，具有独立的内存空间和系统资源，如文件、网络端口等。在计算机程序执行时，先创建进程，再在进程中进行程序的执行。
2. 线程：进程中的一个执行单元。每个线程都有自己的栈和程序计数器，并且可以共享进程的资源。多个线程可以在同一时刻执行不同操作，提高程序的执行效率。一个进程可以有多个线程。
3. 静态变量、实例变量是在堆中的，所以是共享的。

![image-20250516141939273](https://pic.ericzht.space/PicGo/image-20250516141939273.png)

### 并发

使用单核CPU时，同一时刻只能有一条指令执行，但多个指令被快速的轮换执行，使得在宏观上具有多个指令同时执行的效果。

![image-20250516143428949](https://pic.ericzht.space/PicGo/image-20250516143428949.png)

### 并行

多核CPU，同一时刻，多条指令在多个CPU上同时执行。（无论微观还是宏观）

![image-20250516143534577](https://pic.ericzht.space/PicGo/image-20250516143534577.png)

### 并发与并行

1. CPU比较繁忙时，如果开启了多个线程，则只能为一个线程分配仅有的CPU资源，多线程会竞争CPU资源。
2. 在CPU资源比较充足时，一个进程内的多个线程可以被分配到不同的CPU资源，实现并行。

**多线程实现的是并发还是并行？**如上所述，看运行时CPU的资源，**都有可能**。



### 线程的调度模型

多个线程抢夺一个CPU内核的执行权，需要线程调度策略。

#### 分时调度模型

所有线程轮流使用CPU的执行权，并且平均分配每个线程占用的CPU时间

#### 抢占式调度模型

让优先级高的线程以较大的概率优先获得CPU的执行权，如果线程的优先级相同，那么就随机选择一个线程获得CPU的执行权。

**JAVA采用的就是抢占式调度。**



## 实现多线程的方法

### 第一种

1. 编写一个类继承java.lang.Thread
2. 重写run方法
3. new线程对象
4. 调用线程对象的start()方法来启动线程

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        </span><br><span class="line">        mt.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        多线程执行的内容;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

start方法的任务是启动一个新线程，分配一个新的栈空间就结束了。

**java永远满足一个语法规则：必须自上而下依次逐行运行。**

![image-20250516145644299](https://pic.ericzht.space/PicGo/image-20250516145644299.png)

### 第二种

1. 编写一个类实现java.lang.Runnable接口
2. 实现接口中的run方法 （此处不能thorws异常）
3. new线程对象（把实现Runnable接口的类传给Thread构造方法）
4. 调用线程对象的start()方法来启动线程

**这种方式更好，因为以后还可以继承别的类。**而第一种已经使用掉继承一个类的名额了。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        多线程执行的内容;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

这种方式还可以使用匿名内部类：

1. 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                多线程执行的内容;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

​	2.

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                多线程执行的内容;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



## 线程常用的三个方法

1. String getName()； 获取线程对象的名字
2. void setName(String threadName); 修改线程的名字
3. static Thread currentThread(); 获取当前线程对象的引用

除了使用setName修改线程的名字，还可以使用有参构造方法。但是需要在类中实现这个有参构造方法。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String threadName)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(threadName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



## 线程生命周期的7个状态

1. 新建状态 NEW
2. 就绪状态 
3. 运行状态 （2-3 官方统称为可运行状态RUNNABLE）
4. 超时等待状态 TIMED_WAITING
5. 等待状态 WAITING
6. 阻塞状态 BLOCKED
7. 终止状态 TERMINATED

![image-20250517163614959](https://pic.ericzht.space/PicGo/image-20250517163614959.png)

## 线程的休眠

Thread.sleep(毫秒数);

在规定的时间内，当前线程没有权利抢夺CPU时间片了。



## 中断线程的休眠

- interrupt()是一个实例方法。

- `线程对象.interrupt();`可以中断线程的休眠。（当然要放在另一个线程里使用才能起作用）

- 底层原理是利用了异常处理机制。

  当调用这个方法的时候，如果t线程正在睡眠，必然会抛出：InterrupttedException，然后捕捉异常，终止睡眠。

  

## 停止运行线程

*线程对象.stop() 已经不建议使用*

一般是设置一个标记，然后在线程的循环中使用if语句判断这个标记。

比如 boolean run = true; 当达到某个条件后将run改为false，然后if(run){ 运行的内容 } else{return;} 

return后就终止这个线程了。



## 守护线程

在java中，线程被分为两类：守护线程、用户线程



- 所有用户线程结束后，守护线程自动退出/结束。

- 在JVM中，有一个隐藏的守护线程一直在守护着，它就是GC线程。

**将线程设置为守护线程：**

`线程对象.setDaemon(true);`



## 定时任务

java.util.Timer 定时器

java.util.TimerTask 定时任务

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建定时器对象（本质上就是一个线程）</span></span><br><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="literal">true</span>); <span class="comment">// 这里的true表示设置为守护线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定定时任务SimpleDateFormat </span></span><br><span class="line">sdf = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">firstTime</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2024-01-27 10:22:00&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名内部类的方式</span></span><br><span class="line">timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 执行任务</span></span><br><span class="line">                <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">                <span class="type">String</span> <span class="variable">strTime</span> <span class="operator">=</span> sdf.format(now);</span><br><span class="line">                System.out.println(strTime + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;,firstTime,<span class="number">1000</span>*<span class="number">5</span>)</span><br></pre></td></tr></table></figure>



## 线程合并

join() 方法是一个实例方法  

`t.join()` 是让当前线程进入阻塞状态，直到t线程结束，当前线程的阻塞状态结束。

个人理解：就是先让t线程打断当前线程自己运行，如果**设置的时间结束**或者**t线程在时间结束前已经运行完了**，那当前线程就继续执行。

![image-20250517113216785](https://pic.ericzht.space/PicGo/image-20250517113216785.png)

## 线程优先级

最低1(`Thread.MIN_PRIORITY`)，最高10(`Thread.MAX_PRIORITY`)

t.setPriority(传入优先级数值)



## 让位

静态方法：`Thread.yield()`

让当前线程让位。让位不会让其进入阻塞状态，只是放弃当前占有的CPU时间片，进入就绪状态，继续抢夺CPU时间片。



## 线程安全问题

### 什么情况下需要考虑线程安全问题？

1. 多线程并发
2. 有共享的数据
3. 共享数据涉及修改操作

### 一般情况下

局部变量不存在线程安全问题。（尤其是基本数据类型，但如果是引用数据类型就另说了。）

实例变量、静态变量可能存在线程安全问题。他们存放在堆中，堆是多线程共享的。

### 线程同步机制——互斥锁

**线程排队执行**

现有t1和t2线程，t1线程在执行的时候必须等待t2线程执行到某个位置之后，t1线程才能执行。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123; <span class="comment">// obj为共享对象，在银行取款的例子中，这个共享对象就是账户</span></span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

假设t1先抢到了CPU时间片，t1线程找到共享对象obj的对象锁后占有这把锁，t2只能在同步代码块之外等待，等t1线程执行完同步代码块之后，才会释放之前占有的对象锁。

**synchronized又被称为互斥锁。**

synchronized也可以作为标识符直接写在方法（实例方法、静态方法）声明上，

静态方法检测的是类锁，实例方法检测的是对象锁。



### 线程异步机制

**线程并发执行**

各自执行各自的，谁也不需要等对方。

效率高但可能存在安全隐患。



## 线程通信

### 涉及到的三个方法：

`wait()`、`notify()`、`notifyAll()`

- 以上三个方法都是Object类的方法。

![image-20250518151102310](https://pic.ericzht.space/PicGo/image-20250518151102310.png)

- 调用wait方法和notify方法是**通过共享对象去调用**的。

例如：obj.wait()的效果：在obj对象上活跃的**所有线程**进入无期限等待，直到调用了该共享对象的notify方法进行唤醒，唤醒后会接着上一次调用wait方法的位置继续执行。

- obj.wait() 调用后会释放之前占用的对象锁。
- obj.notify() 唤醒优先级最高的等待线程，如果优先级一样，就随机唤醒一个。
- obj.notifyAll() 唤醒所有在该共享对象上等待的线程

![image-20250518154905701](https://pic.ericzht.space/PicGo/image-20250518154905701.png)



## 最完整的生命周期

![image-20250518155732527](https://pic.ericzht.space/PicGo/image-20250518155732527.png)

## 懒汉式单例模式的线程安全问题

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取某个类。这是反射机制中的内容。</span></span><br><span class="line">        <span class="comment">/*Class stringClass = String.class;</span></span><br><span class="line"><span class="comment">        Class singletonClass = Singleton.class;</span></span><br><span class="line"><span class="comment">        Class dateClass = java.util.Date.class;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象t1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                s1 = Singleton.getSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象t2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                s2 = Singleton.getSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断这两个Singleton对象是否一样。</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非线程安全的。</span></span><br><span class="line">    <span class="comment">/*public static Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            singleton = new Singleton();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全的：第一种方案（同步方法），找类锁。</span></span><br><span class="line">    <span class="comment">/*public static synchronized Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            singleton = new Singleton();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全的：第二种方案（同步代码块），找的类锁</span></span><br><span class="line">    <span class="comment">/*public static Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        // 这里有一个知识点是反射机制中的内容。可以获取某个类。</span></span><br><span class="line"><span class="comment">        synchronized (Singleton.class)&#123;</span></span><br><span class="line"><span class="comment">            if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                    throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                singleton = new Singleton();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全的：这个方案对上一个方案进行优化，提升效率。</span></span><br><span class="line">    <span class="comment">/*public static Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        if(singleton == null)&#123;</span></span><br><span class="line"><span class="comment">            synchronized (Singleton.class)&#123;</span></span><br><span class="line"><span class="comment">                if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">                    try &#123;</span></span><br><span class="line"><span class="comment">                        Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">                    &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                        throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    singleton = new Singleton();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lock来实现线程安全</span></span><br><span class="line">    <span class="comment">// Lock是接口，从JDK5开始引入的。</span></span><br><span class="line">    <span class="comment">// Lock接口下有一个实现类：可重入锁（ReentrantLock）</span></span><br><span class="line">    <span class="comment">// 注意：要想使用ReentrantLock达到线程安全，假设要让t1 t2 t3线程同步，就需要让t1 t2 t3共享同一个lock。</span></span><br><span class="line">    <span class="comment">// Lock 和 synchronized 哪个好？Lock更好。为什么？因为更加灵活。synchronized代码块的大括号必须包住所有语句，而unlock()可以任意插入到一些语句中，但一定要记得执行unlock()</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁（需要100%保证解锁，怎么办？finally）</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**Lock 和 synchronized 哪个好？**

Lock更好，因为更加灵活。synchronized代码块的大括号必须包住所有语句，而unlock()可以任意插入到一些语句中，但一定要记得执行unlock()

## 创建线程的第三种方法——未来任务

优点：可以拿到线程执行结束的返回值

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建“未来任务”对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 处理业务......</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取“未来任务”线程的返回值</span></span><br><span class="line">            <span class="comment">// 阻塞当前线程，等待“未来任务”结束并返回值。</span></span><br><span class="line">            <span class="comment">// 拿到返回值，当前线程的阻塞才会解除。继续执行。</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> task.get();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

## 创建线程的第四种方式——线程池

服务器启动时，创建N个线程对象，直接放到线程池中，需要的时候把任务交给线程池即可。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个线程池对象（线程池中有3个线程）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务交给线程池（你不需要触碰到这个线程对象，你只需要将要处理的任务交给线程池即可。）</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后记得关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br></pre></td></tr></table></figure>



# 十、反射 reflect

## 概述

- 后续学的大量java框架都是基于反射机制实现的。
- 反射机制可以让程序更加灵活
- 反射机制最核心的几个类：

​		java.lang.Class : Class类型的实例代表硬盘上某个class文件，或者说代表某一种类型

​		java.lang.reflect.Filed : 实例代表类中的属性/字段

​		java.lang.reflect.Constructor : 它的实例代表类中的构造方法

​		java.lang.reflect.Method : 它的实例代表类中的方法



## 获取Class的四种方式

### 第一种

`Class c = Class.forName("完整的全限定类名");`

注：

1. 全限定类名是带有包名的，不可省略
2. 这是个字符串参数
3. 如果这个类根本不存在，会报异常：`java.lang.ClassNotFoundException`
4. 这个方法的执行会导致类的加载动作的发生



### 第二种

`Class c = obj.getClass();`



### 第三种

`Class c = 类名.class;`



### 第四种——使用类加载器

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; aClass = systemClassLoader.loadClass(<span class="string">&quot;完整的全限定类名&quot;</span>)</span><br></pre></td></tr></table></figure>



`Class.forName()` 和 `classLoader.loadClass()` 的区别：

​		`Class.forName()` ：类加载时会进行初始化（静态变量赋值、静态代码块执行）。

​		`classLoader.loadClass()`：类加载时不会进行初始化，直到第一次使用该类。



## 通过反射机制实例化对象

### 直接对类使用newInstance方法

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;test.User&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)userClass.newInstance();</span><br></pre></td></tr></table></figure>

使用反射机制，只要修改属性配置文件就可以完成不同对象的实例化。非常灵活

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;test.classInfo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;className&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">classObj</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> classObj.newInstance();</span><br></pre></td></tr></table></figure>

**使用这种方式必须要有一个无参数构造方法。如果没有会出现异常。**

**Java9时被标注已过时，不建议使用。**



### 使用构造方法实例化对象

无参构造：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;test.User&quot;</span>);</span><br><span class="line"><span class="comment">// 获取无参数构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">defaultCon</span> <span class="operator">=</span> userClass.getDeclaredConstructor();</span><br><span class="line"><span class="comment">// 通过无参数构造方法实例化对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> defaultCon.newInstance();</span><br></pre></td></tr></table></figure>

有参构造：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;test.User&quot;</span>);</span><br><span class="line"><span class="comment">// 获取有参构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">threeArgsCon</span> <span class="operator">=</span> userClass.getDeclaredConstructor(String.class, <span class="type">double</span>.class, String.class); <span class="comment">// 根据参数的类型，写上对应的类</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> threeArgsCon.newInstance(<span class="string">&quot;001215&quot;</span>, <span class="number">698.5</span>, <span class="string">&quot;未完成&quot;</span>);</span><br></pre></td></tr></table></figure>





## 通过反射为对象属性赋值

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.powernode.javase.reflect.Customer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取对应的Field</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法打破封装（原来类里设置的age是private）</span></span><br><span class="line">        ageField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改属性的值</span></span><br><span class="line">        <span class="comment">// 给对象属性赋值三要素：给哪个对象 的 哪个属性 赋什么值</span></span><br><span class="line">        ageField.set(customer, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取属性的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + ageField.get(customer));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射机制给name属性赋值，和读取name属性的值</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 修改属性name的值</span></span><br><span class="line">        nameField.set(customer, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取属性name的值</span></span><br><span class="line">        System.out.println(nameField.get(customer));</span><br></pre></td></tr></table></figure>



## 反射某一个类的方法



## 类加载的过程

![image-20250521121116429](https://pic.ericzht.space/PicGo/image-20250521121116429.png)

![image-20250521121330986](https://pic.ericzht.space/PicGo/image-20250521121330986.png)



## 虚拟机的三个类加载器

![image-20250521152802090](https://pic.ericzht.space/PicGo/image-20250521152802090.png)

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过自定义的类获取的类加载器是：应用类加载器。</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">appClassLoader</span> <span class="operator">=</span> ReflectTest15.class.getClassLoader();</span><br><span class="line">System.out.println(<span class="string">&quot;应用类加载器：&quot;</span> + appClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取应用类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">appClassLoader2</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(<span class="string">&quot;应用类加载器：&quot;</span> + appClassLoader2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取应用类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">appClassLoader3</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">System.out.println(<span class="string">&quot;应用类加载器：&quot;</span> + appClassLoader3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 getParent() 方法可以获取当前类加载器的 “父 类加载器”。</span></span><br><span class="line"><span class="comment">// 获取平台类加载器。</span></span><br><span class="line">System.out.println(<span class="string">&quot;平台类加载器：&quot;</span> + appClassLoader.getParent());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取启动类加载器。</span></span><br><span class="line"><span class="comment">// 注意：启动类加载器负责加载的是JDK核心类库，这个类加载器的名字看不到，直接输出的时候，结果是null。</span></span><br><span class="line">System.out.println(<span class="string">&quot;启动类加载器：&quot;</span> + 			appClassLoader.getParent().getParent());</span><br></pre></td></tr></table></figure>

## 双亲委派机制

1. 某个类加载器接收到加载类的任务时，通常委托给“父 类加载器”进行加载
2. 最大的“父 类加载器”无法加载时，一级一级向下委托加载任务

作用：

1. 保护程序的安全
2. 防止类加载重复



![image-20250521153555059](https://pic.ericzht.space/PicGo/image-20250521153555059.png)

## 获取泛型

### 获取父类的泛型

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类</span></span><br><span class="line">      Class&lt;Cat&gt; catClass = Cat.class;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取当前类的父类泛型</span></span><br><span class="line">      <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> catClass.getGenericSuperclass();</span><br><span class="line">      <span class="comment">//System.out.println(genericSuperclass instanceof Class);</span></span><br><span class="line">      <span class="comment">//System.out.println(genericSuperclass instanceof ParameterizedType);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果父类使用了泛型</span></span><br><span class="line">      <span class="keyword">if</span>(genericSuperclass <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">          <span class="comment">// 转型为参数化类型</span></span><br><span class="line">          <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">          <span class="comment">// 获取泛型数组</span></span><br><span class="line">          Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">          <span class="comment">// 遍历泛型数组</span></span><br><span class="line">          <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">              <span class="comment">// 获取泛型的具体类型名</span></span><br><span class="line">              System.out.println(a.getTypeName());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



### 获取接口的泛型

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;Mouse&gt; mouseClass = Mouse.class;</span><br><span class="line">        <span class="comment">// 获取接口上的泛型   类可以单继承、多实现，因此实现一个接口算一个Type，实现多个接口就需要数组了。每个接口上的泛型就是一个Type</span></span><br><span class="line">        Type[] genericInterfaces = mouseClass.getGenericInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Type g : genericInterfaces) &#123;</span><br><span class="line">            <span class="comment">// 使用了泛型</span></span><br><span class="line">            <span class="keyword">if</span>(g <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) g;</span><br><span class="line">                Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">                    System.out.println(a.getTypeName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>&lt;String, Integer&gt;, Comparable&lt;Mouse&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Mouse o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### 获取属性上的泛型

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 获取这个类</span></span><br><span class="line">        Class&lt;User&gt; userClass = User.class;</span><br><span class="line">        <span class="comment">// 需要先获取属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">mapField</span> <span class="operator">=</span> userClass.getDeclaredField(<span class="string">&quot;map&quot;</span>); <span class="comment">// 获取公开的以及私有的</span></span><br><span class="line">        <span class="comment">// 获取属性上的泛型</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericType</span> <span class="operator">=</span> mapField.getGenericType();</span><br><span class="line">        <span class="comment">// 用泛型了</span></span><br><span class="line">        <span class="keyword">if</span>(genericType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericType;</span><br><span class="line">            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">                System.out.println(a.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### 获取方法参数、返回值上的泛型

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Integer, Integer&gt; <span class="title function_">m</span><span class="params">(List&lt;String&gt; list, List&lt;Integer&gt; list2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 获取类</span></span><br><span class="line">        Class&lt;MyClass&gt; myClassClass = MyClass.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">mMethod</span> <span class="operator">=</span> myClassClass.getDeclaredMethod(<span class="string">&quot;m&quot;</span>, List.class, List.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法参数上的泛型</span></span><br><span class="line">        Type[] genericParameterTypes = mMethod.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type g : genericParameterTypes)&#123;</span><br><span class="line">            <span class="comment">// 如果这个参数使用了泛型</span></span><br><span class="line">            <span class="keyword">if</span>(g <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) g;</span><br><span class="line">                Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">                    System.out.println(a.getTypeName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法返回值上的泛型</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericReturnType</span> <span class="operator">=</span> mMethod.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span>(genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericReturnType;</span><br><span class="line">            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">                System.out.println(a.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### 获取构造方法函数上的泛型

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Map&lt;String ,Integer&gt; map)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class&lt;User&gt; userClass = User.class;</span><br><span class="line">        Constructor&lt;User&gt; con = userClass.getDeclaredConstructor(Map.class);</span><br><span class="line">        Type[] genericParameterTypes = con.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type g :genericParameterTypes)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) g;</span><br><span class="line">                Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span>(Type a : actualTypeArguments)&#123;</span><br><span class="line">                    System.out.println(a.getTypeName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



# 十一、注解

## 概述

### 什么是注解？

1. JDK1.5引入
2. 可以标注在类上、方法上、属性上、构造方法上、方法参数上等......
3. 注解可以做到在不改变代码逻辑的前提下在代码中嵌入补充信息

### 注解与注释

注解：给编译器或者其他程序看的，程序根据注解来决定不同的处理方式

注释：给程序员看

### 框架

框架 = 反射 + 注解 + 设计模式



## 内置的注解

### @Deprecated

用来标记过时的元素，在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的类、过时的方法、过时的属性等。



### @Override

修饰实例方法，则该方法必须是个重写方法，否则就会编译失败。



### @SuppressWarnings（抑制警告的注解）

在实际开发中，建议尽量不要忽略警告，而是真正的去解决警告。

- @SuppressWarnings("rawtypes")：抑制未使用泛型的警告

- @SuppressWarnings("resource")：抑制未关闭资源的警告

- @SuppressWarnings("deprecation")：抑制使用了已过时资源时的警告

- @SuppressWarnings("all")：抑制所有警告



### @FunctionalInterface

“函数式接口”的注解，这个是 JDK1.8 版本引入的新特性。使用@FunctionalInterface标注的接口，则该接口就**有且只能存在一个*抽象方法***，否则就会发生编译错误。

（注意：接口中的默认方法或静态方法可以有多个。）



## 自定义注解

### 如何自定义

创建一个annotation类型的文件，在文件中写入注解的定义。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 注解中定义属性

属性的类型只能是：

1. byte，short，int，long，float，double，boolean，char
2. String、Class、枚举类型、注解类型
3. 以上所有类型的一维数组形式

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String a;</span><br><span class="line">    <span class="type">int</span> b <span class="keyword">default</span> <span class="number">10</span>; <span class="comment">// 可以使用default语句指定默认值</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注解的使用</span></span><br><span class="line"><span class="meta">@interface(a=&quot;test&quot;,flag=0)</span> <span class="comment">//带默认值的属性可以不在此赋值</span></span><br></pre></td></tr></table></figure>

- 如果属性只有一个，并且属性名是value，那使用注解的时候可以省略value这个属性名。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface(&quot;test&quot;)</span></span><br></pre></td></tr></table></figure>

- 如果属性是一个数组，使用注解时，数组值只有一个，数组的大括号可以省略。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String[] value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface(&quot;test1&quot;)</span></span><br><span class="line"><span class="meta">@interface(&#123;&quot;test1&quot;,&quot;test2&quot;&#125;)</span></span><br></pre></td></tr></table></figure>



## 元注解

### @Retention：设置注解的保持性

注解存在阶段是保留在源代码（编译期），字节码（类加载）或者运行时（JVM中运行）

- `@Retention(RetentionPolicy.SOURCE)`：注解仅存在于源代码中，在字节码文件中不包含。

- `@Retention(RetentionPolicy.CLASS)`：注解在字节码文件中存在，但运行时无法获得（默认）。

- `@Retention(RetentionPolicy.RUNTIME)`：注解在字节码文件中存在，且运行时可通过反射获取。

### @Target：设置注解可以使用的位置

- `@Target(ElementType.TYPE)`：作用于接口、类、枚举、注解

- `@Target(ElementType.FIELD)`：作用于属性、枚举的常量

- `@Target(ElementType.METHOD)`：作用于方法

- `@Target(ElementType.PARAMETER)`：作用于方法参数

- `@Target(ElementType.CONSTRUCTOR)`：作用于构造方法

- `@Target(ElementType.LOCAL_VARIABLE)`：作用于局部变量

- `@Target(ElementType.ANNOTATION_TYPE)`：作用于注解

- `@Target(ElementType.PACKAGE)`：作用于包

- `@Target(ElementType.TYPE_PARAMETER)`：作用于泛型，即泛型方法、泛型类和泛型接口。

- `@Target(ElementType.TYPE_USE)`：作用于任意类型。

### @Documented：设置注解会被包含在API文档中

使用javadoc.exe工具可以从程序源代码中抽取类、方法、属性等注释形成一个源代码配套的API帮助文档，而该工具抽取时默认不包括注解内容。如果注解被@Documented标注，那么就能被javadoc.exe工具提取到API文档。

![image-20250521194851842](https://pic.ericzht.space/PicGo/image-20250521194851842.png)

### @Inherited：被标注的注解支持继承

使用后子类会继承父类的注解。



### @Repeatable：设置后可以在一个地方重复使用同一注解（java8）

`@Repeatable(原注解的复数形式)`

但是需要再声明一个原来注解的复数形式，并在其中包含原注解类型的数组。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Author(name = &quot;张三&quot;)</span></span><br><span class="line">    <span class="meta">@Author(name = &quot;李四&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Authors.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Author &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作者的名字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 作者的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authors &#123;</span><br><span class="line"></span><br><span class="line">    Author[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



## 反射注解

获取类上的所有注解

​		`Annotation[] annotations = clazz.getAnnotations();`

获取类上指定的某个注解

​		`clazz.isAnnotationPresent(AnnotationTest01.class)`

​		`AnnotationTest01 an = clazz.getAnnotation(AnnotationTest01.class);`

获取属性上的所有注解

​		`Annotation[] annotations = field.getAnnotations();`

获取属性上指定的某个注解

​		`field.isAnnotationPresent(AnnotationTest02.class)`

​		`AnnotationTest02 an = field.getAnnotation(AnnotationTest02.class);`

获取方法上的所有注解

​		`Annotation[] annotations = method.getAnnotations();`

获取方法上指定的某个注解

​		`method.isAnnotationPresent(AnnotationTest02.class)`

​		`AnnotationTest02 an = method.getAnnotation(AnnotationTest02.class);`

# 十二、网络编程

## 概述

网络编程的三个基本要素：

1. IP地址：定位网络中的某台计算机
2. 端口号port：定位计算机上的某个进程（某个应用）
3. 通信协议：通过IP地址和端口号定位后，如何保证数据可靠高效的传输，就需要依靠通信协议。



### IP地址

- IPv4：4字节，xxx.xxx.xxx.xxx 每个xxx表示8位二进制数，范围是0-255

​					前三个字节用于表示网络（省市区），最后一个字节用于表示主机（家门牌号）

​					一些IP地址被保留或者被私有机构使用，不能用于公网的地址分配；还有一些IP地址被用作多播地址，仅用于特定的应用场景。因此实际可以使用的IPv4地址少于总量。



- IPv6：16字节，由8组十六进制数表示，如 3ffe:3201:1401:1280:c8ff:fd54:db39:1984

- 本机地址：127.0.0.1，主机名：localhost

- 192.168.0.0-192.168.255.255为私有地址，属于非注册地址，专门为组织、机构内部使用。（用于局域网）



### 端口号port

用两个字节（无符号）表示的，取值范围0-65535，计算机端口号可以分为三大类：

1. 公认端口：0-1023，被预先定义的服务通信占用（如http占用80，FTP占用21，Telnet占用23等）
2. 注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。
3. 动态/私有端口：49152~65535。

通常情况下，服务器程序使用固定的端口号来监听客户端的请求，而客户端则使用随机端口连接服务器。



### OSI参考模型

![image-20250522114020569](https://pic.ericzht.space/PicGo/image-20250522114020569.png)

### TCP/IP参考模型

![image-20250522114318348](https://pic.ericzht.space/PicGo/image-20250522114318348.png)

## 网络编程基础类

### InetAddress类

1. java.net.IntAddress类用来封装计算机的IP地址和DNS（没有端口信息），它包括一个主机名和一个IP地址，是java对IP地址的高层表示。大多数其它网络类都要用到这个类，包括Socket、ServerSocket、URL、DatagramSocket、DatagramPacket等
2. 常用静态方法
   - `static InetAddress getLocalHost()` 得到本机的InetAddress对象，其中封装了IP地址和主机名
   - `lstatic InetAddress getByName(String host)` 传入目标主机的名字或IP地址得到对应的InetAddress对象，其中封装了IP地址和主机名（底层会自动连接DNS服务器进行域名解析）
3. 常用实例方法
   - `lpublic String getHostAddress()` 获取IP地址
   - `lpublic String getHostName()` 获取主机名/域名

### URL类

1. URL是统一资源定位符，是互联网上资源位置和访问方法的一种简介表示。每个文件具有唯一的URL。
2. URL由4部分组成：协议、存放资源的主机域名、端口号、资源文件名。如果未指定端口号，则使用协议默认的端口。HTTP协议的默认端口为80。
3. URL的标准格式：<协议>://<域名或IP>:<端口>/<路径>，其中端口和路径有时可以省略。
4. 为了方便程序员编程，JDK提供了java.net.URL类，该类封装了大量复杂的涉及从远程站点获取信息的细节，可以使用它的各种方法对URL对象进行分割、合并等处理

#### 构造方法

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://127.0.0.1:8080/oa/index.html?name=zhangsan#tip&quot;</span>);</span><br></pre></td></tr></table></figure>

#### 常用方法

获取协议：`url.getProtocol()`   获取域名：`url.getHost()`   

获取默认端口：`url.getDefaultPort()`   获取端口：`url.getPort()`   

获取路径：`url.getPath()`   获取资源：`url.getFile()` 

获取数据：`url.getQuery()`   获取锚点：`url.getRef()`

`openStream()`：可以打开到此URL的连接并返回一个用于从该连接读入的InputStream，实现最简单的爬虫。



## TCP 与 UDP 协议

### Socket 套接字

- Socket是传输层供给应用层的编程接口。使用Socket编程可以开发客户端和服务器应用程序，可以在本地网络上进行通信，也可以通过互联网在全球范围内通信。

- TCP协议和UDP协议是传输层的两种协议。Socket编程分为TCP编程和UDP编程两类。

### TCP、UDP协议

![image-20250522210035291](https://pic.ericzht.space/PicGo/image-20250522210035291.png)

####  TCP 三次握手（通道打开）

![image-20250522210727148](https://pic.ericzht.space/PicGo/image-20250522210727148.png)

1. 客户端发送SYN（同步）数据包，包含客户端的初始序列号（ISN）
2. 服务器收到SYN数据包后，发送SYN-ACK（同步确认）数据包，包含**服务器的初始序列号**（ISN）和**对客户端ISN的确认号**（ACK）
3. 客户端收到SYN-ACK数据包后，发送ACK（确认）数据包，包含**对服务器ISN的确认号**（ACK）

三次握手完成后，客户端和服务器就可以开始交换数据了。

三次握手的意义：不会丢失、重复、乱序，保证数据在两个设备之间可靠地传输。



#### 四次挥手（通道关闭）

![image-20250522211206176](https://pic.ericzht.space/PicGo/image-20250522211206176.png)

1. 客户端发送FIN（结束）数据包，表示客户端已经完成数据传输，希望关闭连接。
2. 服务器收到FIN数据包后，发送ACK（确认）数据包，表示服务器已经收到客户端的FIN数据包，同意关闭连接。
3. 服务器发送FIN数据包，表示服务器已经完成数据传输，希望关闭连接。
4. 客户端收到FIN数据包，发送ACK（确认）数据包。表示客户端已经收到服务器的FIN数据包，并同意关闭连接。

四次挥手完成后，客户端和服务器之间的连接就关闭了。

四次挥手的意义：不会丢失、重复、乱序，保证数据在两个设备之间可靠地传输。

### 基于TCP协议的编程

#### 概述

![image-20250522213820740](https://pic.ericzht.space/PicGo/image-20250522213820740.png)

1. 在网络通讯中，第一次主动发起通讯的程序被称作客户端(Client)，而在第一次通讯中等待连接的程序被称作服务端(Server)。一旦通讯建立，则客户端和服务器端完全一样，没有本质的区别。
2. 套接字与主机地址和端口号相关联，主机地址就是客户端或服务器程序所在的主机的IP地址，端口地址是指客户端或服务器程序使用的主机的通信端口。在客户端和服务器中，分别创建独立的Socket，并通过Socket的属性，将两个Socket进行连接，这样客户端和服务器通过套接字所建立连接并使用IO流进行通信。

#### Socket类

Socket实现客户端套接字。

**构造方法：**

`public Socket(InetAddress a, int p)` 创建套接字并连接到指定IP地址的指定端口号

**Socket类实例方法：**

`public InetAddress getInetAddress()` 返回此套接字连接到的远程 IP 地址

`public InputStream getInputStream()` 返回此套接字的输入流（接收网络消息）

`public OutputStream getOutputStream()` 返回此套接字的输出流（发送网络消息）

`public void shutdownInput()` 禁用此套接字的输入流

`public void shutdownOutput()` 禁用此套接字的输出流

`public synchronized void close()` 关闭此套接字（默认会关闭IO流）



#### ServerSocket类

ServerSocket类实现服务器套接字。服务器套接字等待请求通过网络传入，基于该请求执行某些操作，然后向请求者返回结果。

**构造方法：**

`public ServerSocket(int port)`

**ServerSocket类实例方法：**

`public Socket accept()` 侦听要连接到此套接字并接受它

`public InetAddress getInetAddress()` 返回此服务器套接字的本地地址

`public void close()` 关闭此套接字



# 十三、lambda表达式

- 面向对象的思想
  - 只做一件事情，找一个能解决这个事情的对象，然后调用对象的方法完成这件事情。
- 函数式编程思想
  - 只要能获得结果，谁去做的，怎么做的都不重要，重视结果，忽略实现过程

## Lambda和匿名内部类的区别

- 所需类型不同
  - 匿名内部类：可以是接口、抽象类、具体类
  - Lambda表达式：只能是接口
- 使用限制不同
  - 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类。
  - 如果接口中有多个抽象方法，就只能使用匿名内部类，而不能使用Lambda表达式。
- 实现原理不同
  - 匿名内部类：编译之后，会生成一个单独的.class字节码文件
  - Lambda表达式：编译之后，不会生成一个单独的.class字节码文件



## Lambda表达式的语法

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(形参列表) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">	方法体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

例：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">100</span>,<span class="number">200</span>,<span class="number">350</span>,<span class="number">300</span>);</span><br><span class="line"><span class="comment">// 对其进行排序</span></span><br><span class="line"><span class="comment">// 法一</span></span><br><span class="line">Collections.sort(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二：匿名内部类</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2-o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 法三：Lambda表达式</span></span><br><span class="line">Collections.sort(list,(Integer o1, Integer o2) -&gt; &#123;<span class="keyword">return</span> b-a;&#125;)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator = (Integer a, Integer b) -&gt; &#123;<span class="keyword">return</span> b-a&#125;;</span><br><span class="line">Collections.sort(list,comparator);</span><br></pre></td></tr></table></figure>



## Lambda 表达式的语法精简

四种情况：

1. 形参类型可以省略，如果需要省略，则每个形参的类型都要省略。
2. 如果形参列表只有一个形参，那么形参类型和小括号都可以省略。
3. 如果方法体重只有一行语句，那么方法体的大括号也可以省略。
4. 如果方法体中只有一条return语句，那么大括号可以省略，且必须去掉return关键字。



## 四个基本的函数式接口

| 名字 | 接口名         | 对应的抽象方法     |
| ---- | -------------- | ------------------ |
| 消费 | Consumer<T>    | void accept(T t);  |
| 生产 | Supplier<T>    | T get();           |
| 转换 | Function<T, R> | R apply(T t);      |
| 判断 | Predicate<T>   | boolean test(T t); |



## Lambda表达式的方法引用（简化Lambda表达式）

### 方法引用的概述

我们在使用Lambda表达式的时候，如果Lambda表达式的方法体中除了调用现有方法之外什么都不做，满足这样的条件就有机会使用方法引用来实现。
在以下的代码中，在重写的apply()方法中仅仅只调用了现有Math类round()方法，也就意味着Lambda表达式中仅仅只调用了现有Math类round()方法，那么该Lambda表达式就可以升级为方法引用，案例如下：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：实现小数取整的操作</span></span><br><span class="line"><span class="comment">// 方式一：使用匿名对象来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.round(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function1.apply(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function2 = aDouble -&gt; Math.round(aDouble);</span><br><span class="line">System.out.println(function2.apply(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function3 = Math :: round;</span><br><span class="line">System.out.println(function3.apply(<span class="number">3.14</span>));</span><br></pre></td></tr></table></figure>

对于方法引用，我们可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。
在Lambda表达式的方法引用中，主要有实例方法引用、静态方法引用、特殊方法引用和构造方法引用、数组引用这五种情况，接下来我们就对这五种情况进行讲解。

![](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&from=url&id=YyMKD&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

### 实例方法引用

语法：对象 :: 实例方法
特点：在Lambda表达式的方法体中，通过“对象”来调用指定的某个“实例方法”。
要求：函数式接口中抽象方法的返回值类型和形参列表       与          内部通过对象调用某个实例方法的返回值类型和形参列表            保持一致。
【示例】实例化Consumer接口的实现类对象，并在重写的accept()方法中输出形参的值

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Consumer&lt;String&gt; consumer1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">consumer1.accept(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Consumer&lt;String&gt; consumer2 = str -&gt; System.out.println(str);</span><br><span class="line">consumer2.accept(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Consumer&lt;String&gt; consumer3 = System.out :: println;</span><br><span class="line">consumer3.accept(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

【示例】实例化Supplier接口的实现类对象，并在重写方法中返回Teacher对象的姓名

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;ande&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Supplier&lt;String&gt; supplier1 = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> teacher.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(supplier1.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Supplier&lt;String&gt; supplier2 = () -&gt; teacher.getName();</span><br><span class="line">System.out.println(supplier2.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Supplier&lt;String&gt; supplier3 = teacher :: getName;</span><br><span class="line">System.out.println(supplier3.get());</span><br></pre></td></tr></table></figure>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&from=url&id=OXK1u&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

### 静态方法引用

语法：类 :: 静态方法
特点：在Lambda表达式的方法体中，通过“类名”来调用指定的某个“静态方法”。
要求：函数式接口中抽象方法的返回值类型和形参列表           与               内部通过类名调用某个静态方法的返回值类型和形参列表保持一致。

【示例】实例化Function接口的实现类对象，并在重写的方法中返回小数取整的结果

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.round(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function1.apply(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function2 = aDouble -&gt; Math.round(aDouble);</span><br><span class="line">System.out.println(function2.apply(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Function&lt;Double, Long&gt; function3 = Math :: round;</span><br><span class="line">System.out.println(function3.apply(<span class="number">3.14</span>));</span><br></pre></td></tr></table></figure>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&from=url&id=RpIg2&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

### 特殊方法引用

语法：类名 :: 实例方法
特点：在Lambda表达式的方法体中，通过方法的第一个形参来调用指定的某个“实例方法”。
要求：把函数式接口中抽象方法的第一个形参作为方法的调用者对象，并且从第二个形参开始（或无参）可以对应到被调用实例方法的参数列表中，并且返回值类型保持一致。
【示例】使用Comparator比较器，来判断两个小数的大小

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Comparator&lt;Double&gt; comparator1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Double&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Double o1, Double o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(comparator1.compare(<span class="number">10.0</span>, <span class="number">20.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Comparator&lt;Double&gt; comparator2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">System.out.println(comparator2.compare(<span class="number">10.0</span>, <span class="number">20.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Comparator&lt;Double&gt; comparator3 = Double :: compareTo;</span><br><span class="line">System.out.println(comparator3.compare(<span class="number">10.0</span>, <span class="number">20.0</span>));</span><br></pre></td></tr></table></figure>

需求：实例化Function接口的实现类对象，然后获得传入Teacher对象的姓名。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;ande&quot;</span>, <span class="number">18</span>);</span><br><span class="line">Function&lt;Teacher, String&gt; function1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Teacher, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Teacher teacher)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> teacher.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function1.apply(teacher));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Function&lt;Teacher, String&gt; function2 = e -&gt; e.getName();</span><br><span class="line">System.out.println(function2.apply(teacher));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Function&lt;Teacher, String &gt; function3 = Teacher :: getName;</span><br><span class="line">System.out.println(function3.apply(teacher));</span><br></pre></td></tr></table></figure>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&from=url&id=OKwVP&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

### 构造方法引用

语法：类名 :: new
特点：在Lambda表达式的方法体中，返回指定“类名”来创建出来的对象。
要求：创建对象所调用构造方法形参列表      和      函数式接口中的方法的形参列表       保持一致，并且方法的返回值类型和创建对象的类型保持一致。
【示例】实例化Supplier接口的实现类对象，然后调用重写方法返回Teacher对象

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Supplier&lt;Teacher&gt; supplier1 = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Teacher&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Teacher <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(supplier1.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Supplier&lt;Teacher&gt; supplier2 = () -&gt; <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">System.out.println(supplier2.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用构造方法引用来实现</span></span><br><span class="line"><span class="comment">// 注意：根据重写方法的形参列表，那么此处调用了Teacher类的无参构造方法</span></span><br><span class="line">Supplier&lt;Teacher&gt; supplier3 = Teacher :: <span class="keyword">new</span>;</span><br><span class="line">System.out.println(supplier3.get());</span><br></pre></td></tr></table></figure>

【示例】实例化Function接口的实现类对象，然后调用重写方法返回Teacher对象

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">Function&lt;String, Teacher&gt; function1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Teacher&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Teacher <span class="title function_">apply</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function1.apply(<span class="string">&quot;ande&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Function&lt;String, Teacher&gt; function2 = name -&gt; <span class="keyword">new</span> <span class="title class_">Teacher</span>(name);</span><br><span class="line">System.out.println(function2.apply(<span class="string">&quot;ande&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用构造方法引用来实现</span></span><br><span class="line"><span class="comment">// 注意：根据重写方法的形参列表，那么此处调用了Teacher类name参数的构造方法</span></span><br><span class="line">Function&lt;String, Teacher&gt; function3 = Teacher :: <span class="keyword">new</span>;</span><br><span class="line">System.out.println(function3.apply(<span class="string">&quot;ande&quot;</span>));</span><br></pre></td></tr></table></figure>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&from=url&id=mRxrx&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

### 数组引用

语法：数组类型 :: new
特点：在Lambda表达式的方法体中，创建并返回指定类型的“数组”。
要求：重写的方法有且只有一个整数型的参数，并且该参数就是用于设置数组的空间长度，并且重写方法的返回值类型和创建数组的类型保持一致。
【示例】实例化Function接口的实现类对象，并在重写方法中返回指定长度的int类型数组

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用匿名内部类来实</span></span><br><span class="line">Function&lt;Integer, <span class="type">int</span>[]&gt; function1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, <span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] apply(Integer integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[integer];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(Arrays.toString(function1.apply(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">Function&lt;Integer, <span class="type">int</span>[]&gt; function2 = num -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">System.out.println(Arrays.toString(function2.apply(<span class="number">20</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">Function&lt;Integer, <span class="type">int</span>[]&gt; function3 = <span class="type">int</span>[] :: <span class="keyword">new</span>;</span><br><span class="line">System.out.println(Arrays.toString(function3.apply(<span class="number">30</span>)));</span><br></pre></td></tr></table></figure>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&from=url&id=OzI2h&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

## Lambda在集合当中的使用

为了能够让Lambda和Java的集合类集更好的一起使用，集合当中也新增了部分方法，以便与Lambda表达式对接，要用Lambda操作集合就一定要看懂源码。

### forEach()方法

在Collection集合和Map集合中，都提供了forEach()方法用于遍历集合。
在Collection集合中，提供的forEach()方法的形参为Consumer接口（消费型接口），通过该方法再配合Lambda表达式就可以遍历List和Set集合中的元素。
【示例】遍历List集合中的元素

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>);</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">list.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得遍历出来的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 遍历出来的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer element)</span> &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">list.forEach(element -&gt; System.out.println(element));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">list.forEach(System.out :: println);</span><br></pre></td></tr></table></figure>

【示例】遍历Set集合中的元素

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list);</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">hashSet.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得遍历出来的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 遍历出来的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String element)</span> &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">hashSet.forEach(element -&gt; System.out.println(element));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：使用方法引用来实现</span></span><br><span class="line">hashSet.forEach(System.out :: println);</span><br></pre></td></tr></table></figure>

在Map集合中，提供的forEach()方法的形参为BiConsumer接口，而BiConsumer接口属于两个参数的消费型接口，通过该方法再配合Lambda表达式就可以遍历Map集合中的元素。
【示例】遍历Map集合中的元素

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化Map集合并添加键值对</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;重庆&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;王五&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得遍历出来的key和value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key：&quot;</span> + key + <span class="string">&quot;，value：&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key：&quot;</span> + k + <span class="string">&quot;，value：&quot;</span> + v));</span><br></pre></td></tr></table></figure>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/21376908/1692002570088-3338946f-42b3-4174-8910-7e749c31e950.jpeg#averageHue=%23f9f8f8&from=url&id=mHgqL&originHeight=78&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

### removeIf()方法

在Collection集合中，提供的removeIf()方法的形参为Predicate接口（判断型接口），通过该方法再配合Lambda表达式就可以遍历List和Set集合中的元素。
【示例】删除List集合中的某个元素

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建List集合并添加元素</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>));</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">list.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定的某个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 用于保存遍历出来的某个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true，代表删除；返回false，代表不删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String element)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bb&quot;</span>.equals(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list); <span class="comment">// 输出：[aa, cc, dd]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">list.removeIf(<span class="string">&quot;cc&quot;</span> :: equals);</span><br><span class="line">System.out.println(list); <span class="comment">// 输出：[aa, dd]</span></span><br></pre></td></tr></table></figure>

【示例】删除Set集合中的某个元素

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list);</span><br><span class="line"><span class="comment">// 方式一：使用匿名内部类来实现</span></span><br><span class="line">hashSet.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定的某个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 用于保存遍历出来的某个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true，代表删除；返回false，代表不删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String element)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bb&quot;</span>.equals(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(hashSet); <span class="comment">// 输出：[aa, cc, dd]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Lambda表达式来实现</span></span><br><span class="line">hashSet.removeIf(<span class="string">&quot;cc&quot;</span> :: equals);</span><br><span class="line">System.out.println(hashSet); <span class="comment">// 输出：[aa, dd]</span></span><br></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javase/">javase</a></div><div class="post-share"><div class="social-share" data-image="/image/icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/04/13/javase%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="javase 面向对象"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">javase 面向对象</div></div><div class="info-2"><div class="info-item-1">三、面向对象面向对象概述面向过程关注点在实现功能的步骤上 面向对象关注点在实现功能需要哪些对象的参与，可以把问题拆分成几个对象，对象协作起来解决问题。 面向对象开发方式耦合度低，扩展能力强。 面向对象的三大特征 封装 继承 多态  对象的创建1234[修饰符列表] class 类名&#123;    //属性    /&#125;    JVM内存分析元空间 metaspace元空间中存储的是类的元信息，字节码等。 元空间是java8之后引入的。是JVM规范中方法区的实现。 方法区：JVM规范 的叫法，各个厂商根据这个规范去实现具体的java虚拟机。 总结：方法区是规范，元空间是实现。java8之前使用永久代实现的。 堆内存所有new的对象，都存储在堆内存中。 栈方法被调用时会给该方法分配空间，在VM...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/11/javase%20%E5%BC%95%E5%85%A5%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" title="javase 引入、基本语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-11</div><div class="info-item-2">javase 引入、基本语法</div></div><div class="info-2"><div class="info-item-1">一、引入JAVA语言特性简单性：不像c++支持多继承，无指针。底层由c++实现。 面向对象 可移植性：一次编译，到处运行。在win上编译后可以在Linux上运行。 ​					Java程序在Java虚拟机上运行，JVM : Java virtual machine ​					JDK ：Java开发工具包 多线程 健壮性：产生的垃圾是自动回收的，不需要像c++一样手动回收内存空间。 安全性 JAVA的加载与执行 注：.class文件是字节码文件，不是纯粹的二进制文件，否则操作系统就可以直接运行了。 编译：使用JDK中自带的javac.exe进行编译使用方法： 1javac java源文件的路径   一个源文件可能生成多个.class文件 .class文件生成后，删除.java文件不影响程序的运行，但最好不要删掉，以防后面要修改。  运行：使用java.exe运行使用方法： 磁盘上有一个A.class 1java A...</div></div></div></a><a class="pagination-related" href="/2025/04/13/javase%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="javase 面向对象"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">javase 面向对象</div></div><div class="info-2"><div class="info-item-1">三、面向对象面向对象概述面向过程关注点在实现功能的步骤上 面向对象关注点在实现功能需要哪些对象的参与，可以把问题拆分成几个对象，对象协作起来解决问题。 面向对象开发方式耦合度低，扩展能力强。 面向对象的三大特征 封装 继承 多态  对象的创建1234[修饰符列表] class 类名&#123;    //属性    /&#125;    JVM内存分析元空间 metaspace元空间中存储的是类的元信息，字节码等。 元空间是java8之后引入的。是JVM规范中方法区的实现。 方法区：JVM规范 的叫法，各个厂商根据这个规范去实现具体的java虚拟机。 总结：方法区是规范，元空间是实现。java8之前使用永久代实现的。 堆内存所有new的对象，都存储在堆内存中。 栈方法被调用时会给该方法分配空间，在VM...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">eric_zht</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">四、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0"><span class="toc-text">数组概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">数组的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">静态初始化一维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK5-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF-for-each-%E5%BE%AA%E7%8E%AF"><span class="toc-text">JDK5 新特性：增强for循环 &#x2F; for-each 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">动态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">数组中如何存储不同类的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Emain%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82args"><span class="toc-text">关于main方法的形参args</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">可变长度的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-text">一维数组的扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">静态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-text">动态初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">Arrays 工具类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BC%82%E5%B8%B8"><span class="toc-text">五、异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-text">什么是异常？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%9C%A8java%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-text">异常在java中的形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">处理异常的两种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA7-%E6%96%B0%E7%89%B9%E6%80%A7-%E2%80%94%E2%80%94-%E5%BC%82%E5%B8%B8%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">JAVA7 新特性 —— 异常统一处理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">异常对象的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finally-%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-text">finally 语句块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-text">继承问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">六、常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-String"><span class="toc-text">字符串 String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88string-%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%9F"><span class="toc-text">为什么string 字面量不可变？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-text">字符串拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%8B%E5%8A%A8%E6%94%BE%E8%BF%9B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-text">怎么把字符串手动放进字符串常量池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">String类常用的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">String常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E4%B8%AD%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">String 中正则表达式相关的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer-%E4%B8%8E-StringBuilder-%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">StringBuffer 与 StringBuilder 可变长度字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Integer 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E3%80%81int%E3%80%81Integer-%E4%B8%89%E8%80%85%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">String、int、Integer 三者相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-%E6%8B%86%E7%AE%B1%EF%BC%88JAVA5%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-text">自动装箱&#x2F;拆箱（JAVA5新特性）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-text">自动装箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1"><span class="toc-text">自动拆箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%9E%8B%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">整数型常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigInteger"><span class="toc-text">BigInteger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal"><span class="toc-text">BigDecimal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DecimalFormat"><span class="toc-text">DecimalFormat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3API"><span class="toc-text">日期相关API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="toc-text">获取时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">日期格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86String%E8%BD%AC%E5%8C%96%E6%88%90Date"><span class="toc-text">将String转化成Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-Calend-ar-%E6%97%A5%E5%8E%86%E7%B1%BB"><span class="toc-text">java.util.Calend ar 日历类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E7%9A%84%E6%97%A5%E5%8E%86%E5%AF%B9%E8%B1%A1"><span class="toc-text">获取当前时间的日历对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%A5%E5%8E%86%E4%B8%AD%E7%9A%84%E6%9F%90%E9%83%A8%E5%88%86"><span class="toc-text">获取日历中的某部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%97%A5%E5%8E%86%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">修改日历中的内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%8E%86%E7%9A%84%E6%96%B0API%EF%BC%88java8%EF%BC%89"><span class="toc-text">日历的新API（java8）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F"><span class="toc-text">日期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">时间戳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E3%80%81%E6%97%A5%E6%9C%9F%E9%97%B4%E9%9A%94"><span class="toc-text">计算时间间隔、日期间隔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%9F%AB%E6%AD%A3%E5%99%A8"><span class="toc-text">时间矫正器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96-1"><span class="toc-text">日期格式化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E7%B1%BB-Math"><span class="toc-text">数学类 Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-text">高级用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Random-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">Random 随机数生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System%E7%B1%BB"><span class="toc-text">System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UUID-%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">UUID 通用唯一标识符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%9B%86%E5%90%88"><span class="toc-text">七、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-text">集合概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-text">Collection 关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Collection接口的通用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E7%9A%84%E9%80%9A%E7%94%A8%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F"><span class="toc-text">Collection的通用遍历&#x2F;迭代方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SequencedCollection%E6%8E%A5%E5%8F%A3"><span class="toc-text">SequencedCollection接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-text">泛型初体验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">泛型的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%BB%E7%9F%B3%E8%A1%A8%E8%BE%BE%E5%BC%8F-%EF%BC%88Java7%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-text">钻石表达式 （Java7新特性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E4%B8%8E%E8%A1%A5%E5%81%BF%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">泛型擦除与补偿（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">泛型的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E4%B8%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-text">在类上自定义泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8A%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-text">在静态方法上定义泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%8A%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-text">在接口上定义泛型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">泛型的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">泛型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">无限定通配符</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/25/javase%20%E6%95%B0%E7%BB%84/" title="javase 数组">javase 数组</a><time datetime="2025-04-24T16:00:00.000Z" title="发表于 2025-04-25 00:00:00">2025-04-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/13/javase%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="javase 面向对象">javase 面向对象</a><time datetime="2025-04-12T16:00:00.000Z" title="发表于 2025-04-13 00:00:00">2025-04-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/11/javase%20%E5%BC%95%E5%85%A5%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" title="javase 引入、基本语法">javase 引入、基本语法</a><time datetime="2025-04-10T16:00:00.000Z" title="发表于 2025-04-11 00:00:00">2025-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/05/C%E5%92%8CC++%E4%B8%AD%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/" title="C和C++中的易错点">C和C++中的易错点</a><time datetime="2025-03-04T16:00:00.000Z" title="发表于 2025-03-05 00:00:00">2025-03-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/28/Swin-Unet-%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95%EF%BC%88%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%A4%8D%E7%8E%B0%EF%BC%89/" title="Swin-Unet 复现记录（记第一次复现）">Swin-Unet 复现记录（记第一次复现）</a><time datetime="2025-02-28T06:44:00.000Z" title="发表于 2025-02-28 14:44:00">2025-02-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By eric_zht</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>