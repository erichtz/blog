<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>javase 面向对象 | eric_zht</title><meta name="author" content="eric_zht"><meta name="copyright" content="eric_zht"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="三、面向对象面向对象概述面向过程关注点在实现功能的步骤上 面向对象关注点在实现功能需要哪些对象的参与，可以把问题拆分成几个对象，对象协作起来解决问题。 面向对象开发方式耦合度低，扩展能力强。 面向对象的三大特征 封装 继承 多态  对象的创建1234[修饰符列表] class 类名&#123;    &#x2F;&#x2F;属性    &#x2F;&#125;    JVM内存分析元空间 metaspace元空间中存储的是类的">
<meta property="og:type" content="article">
<meta property="og:title" content="javase 面向对象">
<meta property="og:url" content="http://example.com/2025/04/13/javase%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="eric_zht">
<meta property="og:description" content="三、面向对象面向对象概述面向过程关注点在实现功能的步骤上 面向对象关注点在实现功能需要哪些对象的参与，可以把问题拆分成几个对象，对象协作起来解决问题。 面向对象开发方式耦合度低，扩展能力强。 面向对象的三大特征 封装 继承 多态  对象的创建1234[修饰符列表] class 类名&#123;    &#x2F;&#x2F;属性    &#x2F;&#125;    JVM内存分析元空间 metaspace元空间中存储的是类的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/icon.png">
<meta property="article:published_time" content="2025-04-12T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-08T06:09:34.828Z">
<meta property="article:author" content="eric_zht">
<meta property="article:tag" content="javase">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/icon.png"><link rel="shortcut icon" href="/image/favicon.png"><link rel="canonical" href="http://example.com/2025/04/13/javase%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'javase 面向对象',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/icon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pic.imgdb.cn/item/6741310cd29ded1a8c7a7799.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">eric_zht</span></a><a class="nav-page-title" href="/"><span class="site-name">javase 面向对象</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">javase 面向对象</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-12T16:00:00.000Z" title="发表于 2025-04-13 00:00:00">2025-04-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-08T06:09:34.828Z" title="更新于 2025-05-08 14:09:34">2025-05-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h1><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p>关注点在实现功能的步骤上</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>关注点在实现功能需要哪些对象的参与，可以把问题拆分成几个对象，对象协作起来解决问题。</p>
<p>面向对象开发方式耦合度低，扩展能力强。</p>
<h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] class 类名&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    /</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JVM内存分析"><a href="#JVM内存分析" class="headerlink" title="JVM内存分析"></a>JVM内存分析</h2><h3 id="元空间-metaspace"><a href="#元空间-metaspace" class="headerlink" title="元空间 metaspace"></a>元空间 metaspace</h3><p>元空间中存储的是类的元信息，字节码等。</p>
<p>元空间是java8之后引入的。是JVM规范中方法区的实现。</p>
<p>方法区：<strong>JVM规范</strong> 的叫法，各个厂商根据这个规范去实现具体的java虚拟机。</p>
<p>总结：方法区是规范，元空间是实现。java8之前使用永久代实现的。</p>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>所有new的对象，都存储在堆内存中。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>方法被调用时会给该方法分配空间，在VM Stack中压栈。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250414144722832.png" alt="image-20250414144722832"></p>
<p>JVM有自动垃圾回收机制，主要针对堆区。</p>
<h2 id="实例变量和实例方法"><a href="#实例变量和实例方法" class="headerlink" title="实例变量和实例方法"></a>实例变量和实例方法</h2><p>通常描述一个对象的行为动作时，不加static——称为实例方法</p>
<p>实例方法不能通过类访问，必须通过对象访问。</p>
<h2 id="方法调用传递引用数据类型"><a href="#方法调用传递引用数据类型" class="headerlink" title="方法调用传递引用数据类型"></a>方法调用传递引用数据类型</h2><p>传的是地址！！！</p>
<h2 id="！this关键字"><a href="#！this关键字" class="headerlink" title="！this关键字"></a>！this关键字</h2><ul>
<li>this本质是一个引用</li>
<li>this中保存的是当前对象的内存地址</li>
<li><code>this.</code>大部分情况可以省略，默认是访问当前的类的实例变量。当需要区分局部变量和实例变量时，不能省略。</li>
<li>this存储在栈帧的局部变量表的第0个槽位上。</li>
<li>this不能出现在静态方法中</li>
</ul>
<h3 id="this-实参"><a href="#this-实参" class="headerlink" title="this 实参"></a>this 实参</h3><ul>
<li>通过这种语法，可以在构造方法中调用本类的其他构造方法</li>
<li>作用：代码复用</li>
<li>this实参只能出现在构造方法的第一行！！！</li>
</ul>
<p><img src="https://pic.ericzht.space/PicGo/image-20250416141454757.png" alt="image-20250416141454757"></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>通过限制外部对对象内部的直接访问和修改，保证数据的安全性，并提高了代码的可维护性和可复用性。</p>
<ol>
<li>属性私有化：使用private修饰</li>
<li>对外提供接口</li>
</ol>
<h3 id="快速创建getter，setter方法"><a href="#快速创建getter，setter方法" class="headerlink" title="*快速创建getter，setter方法"></a>*快速创建getter，setter方法</h3><ol>
<li>alt + insert</li>
<li>选择getter and setter</li>
<li>选择要创建的内容</li>
</ol>
<h3 id="构造器（构造方法）"><a href="#构造器（构造方法）" class="headerlink" title="构造器（构造方法）"></a>构造器（构造方法）</h3><ol>
<li>对象的创建</li>
<li>对象的初始化（默认有<code>super();</code>，先对父类的变量进行初始化）</li>
</ol>
<p>这两个阶段不能颠倒，也不能分割。</p>
<ul>
<li><p>构造方法名需与类名一致。</p>
</li>
<li><p>不需要写return，不需要写返回值类型。</p>
</li>
<li><p>如果没有显式定义构造方法，系统会提供一个无参数的构造方法，并且会给属性赋默认值。</p>
</li>
<li><p>定义有参数的构造方法后，可以手动再写一个无参数的构造方法。【方法重载】</p>
</li>
</ul>
<h4 id="如何调用构造方法"><a href="#如何调用构造方法" class="headerlink" title="如何调用构造方法"></a>如何调用构造方法</h4><p><code>new 构造方法名（实参）</code></p>
<h4 id="写了构造方法，为什么还要单独写set方法？"><a href="#写了构造方法，为什么还要单独写set方法？" class="headerlink" title="写了构造方法，为什么还要单独写set方法？"></a>写了构造方法，为什么还要单独写set方法？</h4><p>构造方法是对象第一次创建时用于初始化的。set方法可以在后期<strong>修改属性值</strong>。</p>
<h4 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h4><h5 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#125; <span class="comment">//直接写在class体里面</span></span><br><span class="line">    <span class="comment">//每次new都会运行一次构造代码块中的内容，运行前对象已经创建好，并且完成了初始值的赋值。</span></span><br><span class="line">    <span class="comment">//！！！构造代码块是在构造方法执行之前执行的！！！</span></span><br></pre></td></tr></table></figure>

<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>如果所有的构造方法在最开始的时候有相同的一部分代码，可以将<strong>公共的代码</strong>放在构造代码块中，达到<strong>复用</strong>的效果。</p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol>
<li>new的时候在堆内存中开辟空间，给所有属性赋默认值</li>
<li>执行构造代码块进行初始化</li>
<li>执行构造方法体进行初始化</li>
<li>构造方法执行结束，对象初始化完毕</li>
</ol>
<h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><ul>
<li>static修饰静态变量，当所有对象的某个属性的值是相同的，建议将该属性定义为静态变量，来节省内存。</li>
<li>JDK8后，静态变量存储在<strong>堆内存</strong>中。在<strong>类加载</strong>时进行初始化。</li>
<li>静态变量可以通过“<code>引用.</code>”来访问，实际运行时和对象无关（不会出现空指针异常），但不建议。会让程序员造成误解。</li>
</ul>
<p><img src="https://pic.ericzht.space/PicGo/image-20250416143214835.png" alt="image-20250416143214835"></p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><ul>
<li>语法格式： static{ }</li>
<li>在类加载的时候执行，并且只执行一次。</li>
<li>可以有多个静态代码块，自上而下依次执行。</li>
<li>作用：在类加载的时候运行一段代码，可能是进行一些准备工作。</li>
</ul>
<h2 id="java虚拟机规范"><a href="#java虚拟机规范" class="headerlink" title="java虚拟机规范"></a>java虚拟机规范</h2><h3 id="运行时数据区的六个内容"><a href="#运行时数据区的六个内容" class="headerlink" title="运行时数据区的六个内容"></a>运行时数据区的六个内容</h3><ul>
<li>PC Register, PC计数器：是一块较小的内存空间，用于存储下一条要执行的字节码指令地址。</li>
<li>java Virtual Machine Stacks, java虚拟机栈：用于存储栈帧，栈帧存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>
<li>Heap, 堆：java虚拟机所管理的最大的一块内存，用于存储java对象实例以及数组。堆是垃圾回收器主要使用区域。</li>
<li>Method Area, 方法区：用于存储已被虚拟机加载的类信息、常量、<em>静态变量（hotspot把这个内容存到堆里去了）</em>、即时编译器编译后的代码等数据。</li>
<li>Run-Time Constant Pool, 常量池：方法区的一部分，用于存放编译期生成的各种字面量与符号引用（类名、方法名、属性名）。</li>
<li>method stacks, 本地方法栈：在本地方法的执行过程中，会使用本地方法栈。</li>
</ul>
<p><img src="https://pic.ericzht.space/PicGo/image-20250416160312404.png" alt="image-20250416160312404"></p>
<h2 id="GoF设计模式"><a href="#GoF设计模式" class="headerlink" title="GoF设计模式"></a>GoF设计模式</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>可以重复利用的一套方案</p>
<h3 id="GoF设计模式的分类"><a href="#GoF设计模式的分类" class="headerlink" title="GoF设计模式的分类"></a>GoF设计模式的分类</h3><ol>
<li>创建型：主要解决对象的创建问题</li>
<li>结构型：通过设计和构建对象之间的关系，以达到更好的重用性、扩展性和灵活性</li>
<li>行为型：主要用于处理对象之间的算法和责任分配</li>
</ol>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>属于创造型设计模式，确保一个类只有一个实例，并提供一个全局访问点来访问该实例。</p>
<h4 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h4><p><strong>类加载时对象就创建好了，不管这个对象用还是不用</strong></p>
<ol>
<li>构造方法私有化</li>
<li>定义一个静态变量，在类加载的时候初始化静态变量（只初始化一次）</li>
<li>对外提供一个公开的静态方法，用这个方法获取单个实例</li>
</ol>
<p><img src="https://pic.ericzht.space/PicGo/image-20250416162537904.png" alt="image-20250416162537904"></p>
<h4 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h4><p><strong>用到这个对象的时候再创建对象，别在类加载的时候创建对象</strong></p>
<ol>
<li>构造方法私有化</li>
<li>提供一个静态变量，但这个变量的值为NULL</li>
<li>对外提供一个静态方法，通过这个方法可以获取对象</li>
</ol>
<p><img src="https://pic.ericzht.space/PicGo/image-20250416162601772.png" alt="image-20250416162601772"></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul>
<li>代码复用</li>
<li>有了继承，才有了方法覆盖和多态机制</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] class 类名 extends 父类名 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>只支持单继承，一个类只能继承一个类</li>
<li>不支持多继承，但支持多重继承（多层继承）</li>
<li>子类继承父类的<strong>除私有的、构造方法</strong>以外的所有内容</li>
<li>一个类没有显式继承任何类时，默认继承java.lang.Object类</li>
</ul>
<h2 id="方法覆盖（重写）-overwrite"><a href="#方法覆盖（重写）-overwrite" class="headerlink" title="方法覆盖（重写） overwrite"></a>方法覆盖（重写） overwrite</h2><h3 id="什么时候使用？"><a href="#什么时候使用？" class="headerlink" title="什么时候使用？"></a>什么时候使用？</h3><p>当从父类继承过来的方法，无法满足子类的业务需求时。</p>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul>
<li>当子类将父类方法覆盖之后，将来子类对象调用方法的时候，一定会执行重写之后的方法。</li>
<li>注解：@override，在方法前写这个注解，在编译阶段会检查这个方法是否重写了父类的方法。</li>
<li>如果返回值类型是引用数据类型，那么这个返回值类型可以是原类型的子类型。</li>
<li>访问权限不能变低，可以变高。public最高</li>
<li>抛出异常不能变多，可以变少。</li>
<li>方法覆盖针对的是实例方法，和静态方法无关。</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="向上转型和向下转型的基本概念"><a href="#向上转型和向下转型的基本概念" class="headerlink" title="向上转型和向下转型的基本概念"></a>向上转型和向下转型的基本概念</h3><p>引用数据类型进行类型转换。</p>
<h4 id="向上转型：子–-父-（可以等同看做自动类型转换）"><a href="#向上转型：子–-父-（可以等同看做自动类型转换）" class="headerlink" title="向上转型：子–&gt;父 （可以等同看做自动类型转换）"></a>向上转型：子–&gt;父 （可以等同看做自动类型转换）</h4><p>父类型引用指向子类型对象，这是多态机制最核心的语法。</p>
<p>如果父类中没有某个方法，而子类中有，那么就需要向下转型。</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250416211915263.png" alt="image-20250416211915263"></p>
<h4 id="向下转型：父–-子（可以等同看做强制类型转换）"><a href="#向下转型：父–-子（可以等同看做强制类型转换）" class="headerlink" title="向下转型：父–&gt;子（可以等同看做强制类型转换）"></a>向下转型：父–&gt;子（可以等同看做强制类型转换）</h4><p><strong>当调用的方法是子类特有的方法，需要向下转型，进行强制转换。</strong></p>
<p>如果两个子类不是同一类，会出现ClassCastException异常</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250416212604349.png" alt="image-20250416212604349"></p>
<h3 id="如何避免ClassCastException异常？"><a href="#如何避免ClassCastException异常？" class="headerlink" title="如何避免ClassCastException异常？"></a>如何避免ClassCastException异常？</h3><p>使用运算符 <code>instanceof</code></p>
<p>语法格式：</p>
<p><code>引用 instanceof 类型</code></p>
<p>在进行向下转型之前，用if语句判断一下是否是要向下转型的类型，不是就不要转换了。</p>
<h3 id="静态方法和多态没有关系，因此静态方法和方法覆盖无关系。"><a href="#静态方法和多态没有关系，因此静态方法和方法覆盖无关系。" class="headerlink" title="静态方法和多态没有关系，因此静态方法和方法覆盖无关系。"></a>静态方法和多态没有关系，因此静态方法和方法覆盖无关系。</h3><h3 id="软件开发七大原则"><a href="#软件开发七大原则" class="headerlink" title="软件开发七大原则"></a>软件开发七大原则</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250417144316692.png" alt="image-20250417144316692"></p>
<h3 id="多态在开发中的作用"><a href="#多态在开发中的作用" class="headerlink" title="多态在开发中的作用"></a>多态在开发中的作用</h3><ol>
<li>降低程序耦合度，提高程序的扩展力</li>
<li>尽量使用多态，面向抽象编程，不要面向具体编程。</li>
</ol>
<h3 id="实例变量无法覆盖，根据声明的类型进行赋值"><a href="#实例变量无法覆盖，根据声明的类型进行赋值" class="headerlink" title="实例变量无法覆盖，根据声明的类型进行赋值"></a>实例变量无法覆盖，根据声明的类型进行赋值</h3><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Name</span>&#123; <span class="comment">//父类：所有子类的公共属性+公共方法的集合体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">functionName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象方法必须在抽象类中</span></span><br><span class="line"><span class="comment">//public 和 abstract的顺序没有要求</span></span><br><span class="line"><span class="comment">// ！！！继承该抽象类的子类必须覆盖这个抽象方法</span></span><br></pre></td></tr></table></figure>

<p><strong>存在的意义：</strong>强制子类<strong>重写</strong>抽象方法，编译器会报错。如果类中有一些方法无法实现或者没有意义，就可以将方法定义为抽象方法。</p>
<ul>
<li>abstract 关键字不能和private、final、static关键字共存</li>
</ul>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><ul>
<li>当子类和父类有名称相同的属性&#x2F;方法，此时调用父类中继承而来的属性&#x2F;方法需要使用<code>super.属性/方法</code></li>
<li>super不能在静态方法中使用</li>
<li>this可以单独输出（本质是引用，内容是地址），super不能单独输出（本质不是引用，只是代表了对象父类型特征的那部分）</li>
</ul>
<h3 id="如何在子类中在使用父类方法的基础上进行方法覆盖？"><a href="#如何在子类中在使用父类方法的基础上进行方法覆盖？" class="headerlink" title="如何在子类中在使用父类方法的基础上进行方法覆盖？"></a>如何在子类中在使用父类方法的基础上进行方法覆盖？</h3><p>按正常方法覆盖，但是方法体中先写一个<code>super.方法名()</code>调用一下父类的方法，再写需要添加的内容。</p>
<h3 id="在子类中调用父类的构造方法"><a href="#在子类中调用父类的构造方法" class="headerlink" title="在子类中调用父类的构造方法"></a>在子类中调用父类的构造方法</h3><p>在子类的构造方法中使用<code>super(参数);</code></p>
<p>通过此方法可以给继承过来的父类特征进行初始化，达到代码复用。</p>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><ul>
<li>final修饰的类不可以被继承</li>
<li>final修饰的方法无法被覆盖</li>
<li>final修饰的变量一旦赋值，不能重新赋值</li>
<li>final修饰的实例变量必须在构造方法执行完之前手动赋值。这种变量一般和static联用，得到<strong>常量</strong>（单词全部大写，每个单词用_连接）</li>
<li>final修饰的引用一旦指向某个对象，不能再指向其他对象。但指向的对象内部的数据可以修改。</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>要想解耦合，就是多态+接口</p>
<p>接口在Java中表示一种规范或契约，它定义了一组抽象方法和常量，用来描述一些实现这个接口的类应该具有哪些行为和属性。接口和类一样，也是一种引用数据类型。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li>普通接口</li>
<li>起标志的作用</li>
</ol>
<h3 id="如何定义"><a href="#如何定义" class="headerlink" title="如何定义"></a>如何定义</h3><p>[修饰符列表] interface 接口名{}</p>
<h3 id="接口是完全抽象的"><a href="#接口是完全抽象的" class="headerlink" title="接口是完全抽象的"></a>接口是完全抽象的</h3><p>抽象类是半抽象的（可以定义抽象的方法，也可以定义非抽象的方法）</p>
<p>接口是<strong>完全抽象</strong>的，没有构造方法，也无法实例化。</p>
<h3 id="JDK8之前的语法规则"><a href="#JDK8之前的语法规则" class="headerlink" title="JDK8之前的语法规则"></a>JDK8之前的语法规则</h3><p>接口中只能定义：常量+抽象方法</p>
<p>接口中的常量的static final可以省略，抽象方法的abstract可以省略。</p>
<p>所有方法和变量都是public的</p>
<h3 id="接口与接口之间可以多继承"><a href="#接口与接口之间可以多继承" class="headerlink" title="接口与接口之间可以多继承"></a>接口与接口之间可以多继承</h3><h3 id="类和接口的关系——实现"><a href="#类和接口的关系——实现" class="headerlink" title="类和接口的关系——实现"></a>类和接口的关系——实现</h3><p><em>这里的实现可以等同看做继承。（接口是父，类是子）  这个说法仅供理解</em></p>
<p>使用implements关键字进行接口的实现。</p>
<h3 id="一个非抽象的类实现接口必须将接口中所有抽象方法全部实现（否则编译器报错）"><a href="#一个非抽象的类实现接口必须将接口中所有抽象方法全部实现（否则编译器报错）" class="headerlink" title="一个非抽象的类实现接口必须将接口中所有抽象方法全部实现（否则编译器报错）"></a>一个非抽象的类实现接口必须将接口中所有抽象方法全部实现（否则编译器报错）</h3><h3 id="一个类可以实现多个接口"><a href="#一个类可以实现多个接口" class="headerlink" title="一个类可以实现多个接口"></a>一个类可以实现多个接口</h3><p><code>class 类名 implements 接口A,接口B&#123; &#125;</code></p>
<h3 id="使用了接口之后，为了降低程序的耦合度，一定要让接口和多态联合起来使用"><a href="#使用了接口之后，为了降低程序的耦合度，一定要让接口和多态联合起来使用" class="headerlink" title="使用了接口之后，为了降低程序的耦合度，一定要让接口和多态联合起来使用"></a>使用了接口之后，为了降低程序的耦合度，一定要让接口和多态联合起来使用</h3><p>父类型的引用指向子类型的对象。</p>
<h3 id="JDK8后，接口中允许出现默认方法和静态方法"><a href="#JDK8后，接口中允许出现默认方法和静态方法" class="headerlink" title="JDK8后，接口中允许出现默认方法和静态方法"></a>JDK8后，接口中允许出现默认方法和静态方法</h3><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>引入默认方法是为了演变接口演变问题。</p>
<p>接口可以定义抽象方法，但不能实现这些方法。所有实现接口的类都必须实现这些抽象方法，这会导致接口升级问题——当我们向接口添加或删除一个抽象方法时，这会破坏该接口的所有实现，所有与它有关的类都需要修改代码。</p>
<h4 id="覆盖会使用静态方法"><a href="#覆盖会使用静态方法" class="headerlink" title="覆盖会使用静态方法"></a>覆盖会使用静态方法</h4><p>只能通过接口名去调用</p>
<p>通常<strong>将接口作为工具使用</strong>时，会使用静态方法</p>
<h3 id="JDK9之后允许定义私有实例方法（为默认方法服务）和私有静态方法（为静态方法服务）"><a href="#JDK9之后允许定义私有实例方法（为默认方法服务）和私有静态方法（为静态方法服务）" class="headerlink" title="JDK9之后允许定义私有实例方法（为默认方法服务）和私有静态方法（为静态方法服务）"></a>JDK9之后允许定义私有实例方法（为默认方法服务）和私有静态方法（为静态方法服务）</h3><p>私有静态方法便于将静态方法拆分为多个方法，免得一个方法中有几千行。便于代码复用</p>
<h3 id="所有接口隐式继承object，因此接口也可以调用object类的相关方法"><a href="#所有接口隐式继承object，因此接口也可以调用object类的相关方法" class="headerlink" title="所有接口隐式继承object，因此接口也可以调用object类的相关方法"></a>所有接口隐式继承object，因此接口也可以调用object类的相关方法</h3><h3 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h3><ul>
<li>调用者和实现者通过接口达到了解耦合。调用者不需要关心具体的实现者，实现者也不许要关心具体的调用者，双方只要遵循规范，面向接口进行开发。</li>
<li>面向抽象编程，面向接口编程，可以降低程序的耦合度，提高程序的扩展力。</li>
</ul>
<h3 id="接口和抽象类的选择"><a href="#接口和抽象类的选择" class="headerlink" title="接口和抽象类的选择"></a>接口和抽象类的选择</h3><ul>
<li><strong>抽象类主要用于公共代码的提取。</strong>多个类有共同的属性和方法时，提取出一个父类。</li>
<li><strong>接口主要用于功能的扩展。</strong>有一些类需要实现某个方法，另一些类不需要，那就将这个方法定义到接口中，需要这个方法的就去实现这个接口。</li>
</ul>
<h3 id="一个类单继承父类，多实现接口"><a href="#一个类单继承父类，多实现接口" class="headerlink" title="一个类单继承父类，多实现接口"></a>一个类单继承父类，多实现接口</h3><p>extends在前，implements在后</p>
<h2 id="UML-统一建模语言"><a href="#UML-统一建模语言" class="headerlink" title="UML 统一建模语言"></a>UML 统一建模语言</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250423171427415.png" alt="image-20250423171427415"></p>
<h3 id="类之间的六种关系"><a href="#类之间的六种关系" class="headerlink" title="类之间的六种关系"></a>类之间的六种关系</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250423180648373.png" alt="image-20250423180648373"></p>
<p>聚合关系：整体和部分各自有自己的生命周期</p>
<p>组合关系：整体和部分有相同的生命周期。eg.人死了，四肢也没了。</p>
<h3 id="三个比较重要的关系"><a href="#三个比较重要的关系" class="headerlink" title="三个比较重要的关系"></a>三个比较重要的关系</h3><p>l</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250423174945893.png" alt="image-20250423174945893"></p>
<h3 id="其他的关系"><a href="#其他的关系" class="headerlink" title="其他的关系"></a>其他的关系</h3><h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250423175943893.png" alt="image-20250423175943893"></p>
<h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250423180306838.png" alt="image-20250423180306838"></p>
<h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p><img src="https://pic.ericzht.space/PicGo/image-20250423180526190.png" alt="image-20250423180526190"></p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250423180542254.png" alt="image-20250423180542254"></p>
<h2 id="访问控制权限"><a href="#访问控制权限" class="headerlink" title="访问控制权限"></a>访问控制权限</h2><p><img src="https://pic.ericzht.space/PicGo/image-20250423202738814.png" alt="image-20250423202738814"></p>
<ul>
<li>类的访问权限只有两种：public和缺省</li>
<li>访问权限控制符不能修饰局部变量</li>
</ul>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><h3 id="toString-：将java对象转换成字符串型"><a href="#toString-：将java对象转换成字符串型" class="headerlink" title="toString ：将java对象转换成字符串型"></a>toString ：将java对象转换成字符串型</h3><p>但默认的方法输出的是地址，因此需要自己覆盖方法。</p>
<p>调用<code>print()</code>打印<strong>类</strong>时，会自动调用<strong>类的</strong><code>toString()</code>（和自己调用toString方法有区别，因为它会先判断是否是NULL，再使用toString）</p>
<h3 id="equal-：判断两个对象是否相等"><a href="#equal-：判断两个对象是否相等" class="headerlink" title="equal ：判断两个对象是否相等"></a>equal ：判断两个对象是否相等</h3><p>默认方法是判断地址是否相等，也需要自己重写方法。</p>
<h3 id="hashCode-：返回一个对象的哈希值"><a href="#hashCode-：返回一个对象的哈希值" class="headerlink" title="hashCode ：返回一个对象的哈希值"></a>hashCode ：返回一个对象的哈希值</h3><p>通常用来在哈希表中查找该对象的键值。</p>
<p>默认实现是根据对象的内存地址生成一个哈希码（将对象的内存地址转换为整数作为哈希值）。</p>
<p>该方法是为了HashMap、Hashtable、HashSet等集合类进行优化而设置的，便于更快地查找和存储对象。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><ul>
<li>实现对象拷贝。通常在开发中需要保护原对象数据结构，于是克隆出一份新对象，对新对象进行操作。</li>
<li>默认实现：是protected类型，专门给子类使用的。（本地方法，调用C++程序实现的）<strong>【浅克隆】</strong></li>
<li>怎么解决克隆方法调用问题？—— 在子类中重写clone方法，并且为了保证clone方法在任何位置都可以调用，建议将其修饰符修改为public</li>
<li>凡是参加克隆的对象，必须实现一个标志接口：<code>java.lang.Cloneable</code></li>
</ul>
<p>需要重写变成<strong>【深克隆】</strong></p>
<p>就是先完成浅克隆，再单独克隆其中包含的类，然后赋值给克隆出来的东西。</p>
<p>eg.</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250425160124895.png" alt="image-20250425160124895"></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="什么是内部类"><a href="#什么是内部类" class="headerlink" title="什么是内部类"></a>什么是内部类</h3><p>定义在一个类中的类</p>
<h3 id="什么时候使用内部类"><a href="#什么时候使用内部类" class="headerlink" title="什么时候使用内部类"></a>什么时候使用内部类</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250425161313968.png" alt="image-20250425161313968"></p>
<h3 id="四种内部类"><a href="#四种内部类" class="headerlink" title="四种内部类"></a>四种内部类</h3><p><img src="https://pic.ericzht.space/PicGo/image-20250425161340502.png" alt="image-20250425161340502"></p>
<p>匿名内部类：</p>
<p><img src="https://pic.ericzht.space/PicGo/image-20250425171754060.png" alt="image-20250425171754060"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javase/">javase</a></div><div class="post-share"><div class="social-share" data-image="/image/icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/25/javase%20%E6%95%B0%E7%BB%84/" title="javase 数组"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">javase 数组</div></div><div class="info-2"><div class="info-item-1">四、数组数组概述 数组是引用数据类型，隐式继承Object，因此可以调用Object类中的方法 数组对象存储在堆内存中  数组的特点 数组长度一旦确定不可改变 所有数组对象都有length属性，用来获取数组元素个数  优点：  根据下标查找某个元素的效率极高  缺点：  随机增删的效率低，需要后移&#x2F;前移很多元素 无法存储大量数据，因为很难在内存上找到非常大的一块连续内存  一维数组静态初始化一维数组已经知道数组中的值时使用 1234// 第一种int[] arr = &#123;11,22,33&#125;; 或者 int arr[] = &#123;11,22,33&#125;; //后者不建议// 第二种int[] arr = new int[] &#123;11,22,33&#125;;  用第一种就好了！ JDK5 新特性：增强for循环 &#x2F; for-each 循环123for(元素数据类型 变量名:数组名)&#123; // 变量名代表数组中的每个元素，可以自己取名   ...</div></div></div></a><a class="pagination-related" href="/2025/04/11/javase%20%E5%BC%95%E5%85%A5%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" title="javase 引入、基本语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">javase 引入、基本语法</div></div><div class="info-2"><div class="info-item-1">一、引入JAVA语言特性简单性：不像c++支持多继承，无指针。底层由c++实现。 面向对象 可移植性：一次编译，到处运行。在win上编译后可以在Linux上运行。 ​					Java程序在Java虚拟机上运行，JVM : Java virtual machine ​					JDK ：Java开发工具包 多线程 健壮性：产生的垃圾是自动回收的，不需要像c++一样手动回收内存空间。 安全性 JAVA的加载与执行 注：.class文件是字节码文件，不是纯粹的二进制文件，否则操作系统就可以直接运行了。 编译：使用JDK中自带的javac.exe进行编译使用方法： 1javac java源文件的路径   一个源文件可能生成多个.class文件 .class文件生成后，删除.java文件不影响程序的运行，但最好不要删掉，以防后面要修改。  运行：使用java.exe运行使用方法： 磁盘上有一个A.class 1java A...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/11/javase%20%E5%BC%95%E5%85%A5%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" title="javase 引入、基本语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-11</div><div class="info-item-2">javase 引入、基本语法</div></div><div class="info-2"><div class="info-item-1">一、引入JAVA语言特性简单性：不像c++支持多继承，无指针。底层由c++实现。 面向对象 可移植性：一次编译，到处运行。在win上编译后可以在Linux上运行。 ​					Java程序在Java虚拟机上运行，JVM : Java virtual machine ​					JDK ：Java开发工具包 多线程 健壮性：产生的垃圾是自动回收的，不需要像c++一样手动回收内存空间。 安全性 JAVA的加载与执行 注：.class文件是字节码文件，不是纯粹的二进制文件，否则操作系统就可以直接运行了。 编译：使用JDK中自带的javac.exe进行编译使用方法： 1javac java源文件的路径   一个源文件可能生成多个.class文件 .class文件生成后，删除.java文件不影响程序的运行，但最好不要删掉，以防后面要修改。  运行：使用java.exe运行使用方法： 磁盘上有一个A.class 1java A...</div></div></div></a><a class="pagination-related" href="/2025/04/25/javase%20%E6%95%B0%E7%BB%84/" title="javase 数组"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-25</div><div class="info-item-2">javase 数组</div></div><div class="info-2"><div class="info-item-1">四、数组数组概述 数组是引用数据类型，隐式继承Object，因此可以调用Object类中的方法 数组对象存储在堆内存中  数组的特点 数组长度一旦确定不可改变 所有数组对象都有length属性，用来获取数组元素个数  优点：  根据下标查找某个元素的效率极高  缺点：  随机增删的效率低，需要后移&#x2F;前移很多元素 无法存储大量数据，因为很难在内存上找到非常大的一块连续内存  一维数组静态初始化一维数组已经知道数组中的值时使用 1234// 第一种int[] arr = &#123;11,22,33&#125;; 或者 int arr[] = &#123;11,22,33&#125;; //后者不建议// 第二种int[] arr = new int[] &#123;11,22,33&#125;;  用第一种就好了！ JDK5 新特性：增强for循环 &#x2F; for-each 循环123for(元素数据类型 变量名:数组名)&#123; // 变量名代表数组中的每个元素，可以自己取名   ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">eric_zht</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/erichtz"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">三、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">面向对象概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-text">面向过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-text">面向对象的三大特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">对象的创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-text">JVM内存分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4-metaspace"><span class="toc-text">元空间 metaspace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-text">堆内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">实例变量和实例方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">方法调用传递引用数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%81this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">！this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E5%AE%9E%E5%8F%82"><span class="toc-text">this 实参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BAgetter%EF%BC%8Csetter%E6%96%B9%E6%B3%95"><span class="toc-text">*快速创建getter，setter方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">构造器（构造方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">如何调用构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E4%BA%86%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E5%8D%95%E7%8B%AC%E5%86%99set%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">写了构造方法，为什么还要单独写set方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">构造代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">语法格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-text">流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">static 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">静态代码块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83"><span class="toc-text">java虚拟机规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E5%85%AD%E4%B8%AA%E5%86%85%E5%AE%B9"><span class="toc-text">运行时数据区的六个内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">GoF设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">什么是设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">GoF设计模式的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">饿汉式单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">懒汉式单例模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-text">特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89-overwrite"><span class="toc-text">方法覆盖（重写） overwrite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">什么时候使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7-1"><span class="toc-text">特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">向上转型和向下转型的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A%E5%AD%90%E2%80%93-%E7%88%B6-%EF%BC%88%E5%8F%AF%E4%BB%A5%E7%AD%89%E5%90%8C%E7%9C%8B%E5%81%9A%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-text">向上转型：子–&gt;父 （可以等同看做自动类型转换）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9A%E7%88%B6%E2%80%93-%E5%AD%90%EF%BC%88%E5%8F%AF%E4%BB%A5%E7%AD%89%E5%90%8C%E7%9C%8B%E5%81%9A%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-text">向下转型：父–&gt;子（可以等同看做强制类型转换）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DClassCastException%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-text">如何避免ClassCastException异常？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%A4%9A%E6%80%81%E6%B2%A1%E6%9C%89%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%9B%A0%E6%AD%A4%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E6%97%A0%E5%85%B3%E7%B3%BB%E3%80%82"><span class="toc-text">静态方法和多态没有关系，因此静态方法和方法覆盖无关系。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-text">软件开发七大原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">多态在开发中的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E6%97%A0%E6%B3%95%E8%A6%86%E7%9B%96%EF%BC%8C%E6%A0%B9%E6%8D%AE%E5%A3%B0%E6%98%8E%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E8%B5%8B%E5%80%BC"><span class="toc-text">实例变量无法覆盖，根据声明的类型进行赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">抽象类和抽象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">super 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AD%90%E7%B1%BB%E4%B8%AD%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%BF%9B%E8%A1%8C%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%EF%BC%9F"><span class="toc-text">如何在子类中在使用父类方法的基础上进行方法覆盖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">在子类中调用父类的构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89"><span class="toc-text">如何定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%AE%8C%E5%85%A8%E6%8A%BD%E8%B1%A1%E7%9A%84"><span class="toc-text">接口是完全抽象的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8%E4%B9%8B%E5%89%8D%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-text">JDK8之前的语法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E5%8F%AF%E4%BB%A5%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">接口与接口之间可以多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0"><span class="toc-text">类和接口的关系——实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%9D%9E%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%BF%85%E9%A1%BB%E5%B0%86%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%89%80%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%85%A8%E9%83%A8%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%90%A6%E5%88%99%E7%BC%96%E8%AF%91%E5%99%A8%E6%8A%A5%E9%94%99%EF%BC%89"><span class="toc-text">一个非抽象的类实现接口必须将接口中所有抽象方法全部实现（否则编译器报错）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-text">一个类可以实现多个接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%86%E6%8E%A5%E5%8F%A3%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%B8%BA%E4%BA%86%E9%99%8D%E4%BD%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%80%A6%E5%90%88%E5%BA%A6%EF%BC%8C%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81%E8%81%94%E5%90%88%E8%B5%B7%E6%9D%A5%E4%BD%BF%E7%94%A8"><span class="toc-text">使用了接口之后，为了降低程序的耦合度，一定要让接口和多态联合起来使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8%E5%90%8E%EF%BC%8C%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%85%81%E8%AE%B8%E5%87%BA%E7%8E%B0%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">JDK8后，接口中允许出现默认方法和静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-text">默认方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%BC%9A%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">覆盖会使用静态方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK9%E4%B9%8B%E5%90%8E%E5%85%81%E8%AE%B8%E5%AE%9A%E4%B9%89%E7%A7%81%E6%9C%89%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%BA%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E6%9C%8D%E5%8A%A1%EF%BC%89%E5%92%8C%E7%A7%81%E6%9C%89%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%BA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%9C%8D%E5%8A%A1%EF%BC%89"><span class="toc-text">JDK9之后允许定义私有实例方法（为默认方法服务）和私有静态方法（为静态方法服务）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%E9%9A%90%E5%BC%8F%E7%BB%A7%E6%89%BFobject%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%8E%A5%E5%8F%A3%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8object%E7%B1%BB%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-text">所有接口隐式继承object，因此接口也可以调用object类的相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">接口的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">接口和抽象类的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8D%95%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%EF%BC%8C%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">一个类单继承父类，多实现接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80"><span class="toc-text">UML 统一建模语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB"><span class="toc-text">类之间的六种关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">三个比较重要的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">其他的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-text">聚合关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-text">组合关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-text">依赖关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90"><span class="toc-text">访问控制权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-%EF%BC%9A%E5%B0%86java%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B"><span class="toc-text">toString ：将java对象转换成字符串型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equal-%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-text">equal ：判断两个对象是否相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode-%EF%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-text">hashCode ：返回一个对象的哈希值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone"><span class="toc-text">clone</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">什么是内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">什么时候使用内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">四种内部类</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/01/app_class_2025_sum/exp3/" title="移动软件开发 实验3：微信小程序云开发">移动软件开发 实验3：微信小程序云开发</a><time datetime="2025-08-31T16:00:00.000Z" title="发表于 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/26/app_class_2025_sum/exp2/" title="移动软件开发 实验2：天气查询小程序">移动软件开发 实验2：天气查询小程序</a><time datetime="2025-08-25T16:00:00.000Z" title="发表于 2025-08-26 00:00:00">2025-08-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/25/app_class_2025_sum/exp1/" title="移动软件开发 实验1：第一个微信小程序">移动软件开发 实验1：第一个微信小程序</a><time datetime="2025-08-24T16:00:00.000Z" title="发表于 2025-08-25 00:00:00">2025-08-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/24/Redis/" title="Redis">Redis</a><time datetime="2025-07-23T16:00:00.000Z" title="发表于 2025-07-24 00:00:00">2025-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/JavaWeb/" title="JDBC">JDBC</a><time datetime="2025-06-03T16:00:00.000Z" title="发表于 2025-06-04 00:00:00">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://pic.imgdb.cn/item/6741310cd29ded1a8c7a7799.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By eric_zht</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>